<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018-年度总结</title>
    <url>/2019/01/14/2018-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>拖了半个月，最后还是动笔写一份总结。</p>
<a id="more"></a>

<p>说起来，已经记不太清一整年里各个事情发生的时间了，尤其是上半年，记忆更模糊了，只能是拾起一些碎片。</p>
<h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><ul>
<li>是想要和某人说新年快乐的第二年，只是这个人啊，总是在新年前脱单，17年我还能厚着脸打个电话，18年就只能发个短信。时间渐渐抚平回忆的皱褶，我或许连个污点都算不上。</li>
<li>寒假还考虑出门旅游，最后也没能成行，我有时也想不清楚该怎样生活，需要做出改变吗？我只知道当下的生活，是真的快乐，所以我才沉沦其中。</li>
<li>参加Intel软件创新大赛，考虑不周，早早地各回各家，团队氛围还没搞起来，工作也没有个进度，最后不了了之。我这个人真是做什么事都没决心。</li>
<li>应班主任邀约，给学弟学妹加油鼓劲，想想那时我还是有激情的，带了几十张明信片，跟大家吹交大还可以，对自己当年高考的状态还十分满意。放下一句“不后悔”，一转身就是三年。</li>
</ul>
<h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><ul>
<li>假期生活只有打游戏、看书、聚会。</li>
<li>家里的电脑并不太好，只能玩玩魔兽争霸，网络延迟也很高。印象中我还去了好多次网吧，那会主要玩的还是跳伞。</li>
<li>看书的话，寒假里应该学习了《Python参考手册》，《鸟叔Linux》，读了余秋雨的《借我一生》，岛田的《占星术杀人魔法》，或许还有些别的，记得那段时间读了特别多推理小说，开学后还看了行人的馆系列。即使到现在我还是想说，《钟表馆》神作呀。</li>
<li>年后和几个同学到班主任家里吃饭，不得不说，这个鸭子肉确实有一手。老师家的狗狗叫花卷，以前只见过照片，这次真碰上了，喜欢往人身上钻，讲道理是有点吓人的（或许是因为长的并不小巧可爱，还喜欢舔吧，舔狗nb）。</li>
<li>饭桌上的闲谈，让人意识到，我们已经各自走出好远了。以前曹老师讲，高中同学是一种特别的感情，有同学生了病，还集资给他治疗。到了我这，高中同学好像也没什么特别。上海太远了，不仅是地理。</li>
<li>他们不能理解我，我也不能理解过往。</li>
</ul>
<h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><ul>
<li>这个学期最喜欢的课是ics和web开发，其实数据库蒋老师也超好。总之这学期的课真的很快乐。</li>
<li>准备参加微信小程序开发大赛，也是从这时候，和阿文、阿鄢建立深厚革命友谊。</li>
<li>入手了kindle，开始更加快乐的读书之旅。</li>
</ul>
<h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><ul>
<li>我也记不清ics期中考试是什么时候了，差不多是一炮打响，声名鹊起的感觉，听说平均分只有57，80分以上有三人，90分只有我一个。</li>
<li>我很清楚，不过是一时好运。我这个人俏皮乖张爱水群，不想做学霸，也没能力做学霸。朋友们抬举，只能是好好学习，争取不太菜吧。</li>
<li>web开发课程的作业进度很快，自学了很久的ssh，其中的每一项都单独学了一本书，感谢当初我还有这种精神，现在看起来非常sb，应用级的技术，多学也没什么用。</li>
<li>那时还觉得React天下第一，现在看，我再也不想写前端了。</li>
</ul>
<h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><ul>
<li>差不多是这个时间，在Summer上注册了账号，能领十几块钱红包，非常快乐。</li>
<li>当时满脑子想的是，太强了，我还在写没什么用的小软件，别人已经有创意有作品，拉到投资了。</li>
<li>现在匿名社交软件挺多的，soul的下载量挺大，而且在知乎上广告很多。我觉得这其中确实有一个痛点，就是人们每年认识的新朋友不多，人和人的关系越来越难维持，我们也的的确确会有许多不需要维持的关系，该消失的就消失。</li>
<li>至于一些阴暗的东西就不谈了，我至今未能理解那些思维。</li>
</ul>
<h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><ul>
<li>六月高考，我还小紧张了一下，因为之前回母校，是给文理科的前十名分享经验，我还是很希望他们能考好的，有几个小朋友的理想还是交大。</li>
<li>可惜最后折戟沉沙，都不怎么理想。乱世之中，一起争渡。</li>
<li>微信小程序比赛真是做到头疼，我气到说，原来积极性不能代表生产力。整个工程几乎是我一个人做的，阿鄢和阿阳着实坑了我一把。</li>
<li>我想证明自己，也想简历上能多点东西，好将来本科毕业直接找工作跑路，经历两次大赛失败，令人伤感。</li>
<li>还是那句话，我做什么事，都没有必杀决心，走一步看一步，最后随波逐流。</li>
</ul>
<h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><ul>
<li>小学期软院欢乐小黑屋，大家坐在一起写代码，一个月输出几千行。</li>
<li>那时候最快乐的是和阿鄢阿文吃五餐二楼，阿姨打菜，手不仅不抖，还打得超多，根本吃不完，我一度怀疑她是想早点打完早点下班。</li>
</ul>
<h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><ul>
<li>放假后继承了学长的实验室项目，我觉得这个只是随便玩玩的小项目，这情景就像，一个不懂软件开发的产品经理，有了一个idea，想要做出来看看具体什么样，然后让咱们这些学生实现一个。</li>
<li>没想到的是，我还要写微信小程序前端，我真是b了狗了。</li>
<li>假期里依然是看书打游戏聚会。</li>
<li>这次看的是《网络：自顶向下方法》，一本大部头够一个月看的。聚会成功将一些不懂得桌游魅力的老同学拉入坑，陪我一起玩沙雕桌游。</li>
<li>假期里，实验室小组还有电话会议，督促学习，认真学习了kubernetes和scheduling，最后还是啥也不会。</li>
<li>入手新的mbp，终于能体验macOS是什么感觉了，就是这个，确实很贵。</li>
</ul>
<h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><ul>
<li>转眼成了大三老狗，选了系统软件方向，只因为想学分布式系统和操作系统，并因此陷入了编译原理的坑，内心是很抗拒的，编译原理是真的没意思，尽管我写的还算轻松。</li>
<li>信息系统工程的wtm老师是真的得劲，上课讲脏话，课件二十年前。只是这门课真的击碎了我的梦想，我预感得分会很糟糕，考试没有用心准备。</li>
<li>每天一道leetcode，才知我是真的不行。</li>
</ul>
<h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><ul>
<li>我又老了一岁，爱我的人还没出现，所有的社团活动都成为往事，这一学期格外凄凉，课不多，只能面对电脑打发时间。</li>
<li>IPADS面试，给了一个月时间准备论文阅读，我只读了一两遍，稍微看看大意，因为实在也理解不了发生了什么。我始终觉得，一是我不知道怎样去完全弄懂，二是性价比太低，搞懂这一两篇论文对我并没有什么帮助。反倒是花了不少时间去学习区块链，虽然最后也用不上，但的确是开拓视野的技术。</li>
<li>没能加入IPADS，对我人生轨迹是一个大影响，不然我读研的概率会更大点，现在来看，优先考虑就业。</li>
<li>我还是很喜欢夏老师，真是对不住。</li>
</ul>
<h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><ul>
<li>接了企业项目，这次又有了新团队，这种实验性质的项目还是很轻松，没有什么实现限制，大家合作研究。</li>
<li>我一会想做运维，一会想写论文，最后一事无成。</li>
<li>参加Kubecon，感觉超酷，我应该是喜欢做工程师的。</li>
<li>elastic的一个人看我的牌子写着交大，问我是不是老师，差点要给我名片，我连忙表明沙雕本科生身份，然后他收了回去并介绍了一下他们的一些和学生有关的项目。我觉得我当时的表现真的很不堪，内心对elastic毫无兴趣，表面上又不世故，不知道客套两句，直接将内心的不屑表现在了眼神中，只点头不扫码，好在大叔并没有跟我这种小年轻计较。以后的表现还是要多点操作性才好。</li>
</ul>
<h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><ul>
<li>编译原理超级lab终于来了，虽然最后来看，我并没有很肝，但做的时候，我内心真的很崩溃，无助又绝望。</li>
<li>收获了软展的奖金，七百块感觉血赚，买的em2耳机太骚了，打算送给老同学。</li>
</ul>
<h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><ul>
<li>在写的过程中，写到后面的时间了，前面时间没写的某件事又浮现眼前，真想记住所有的过去，但我知道，再写也没有意义了，记得不记得，又有什么重要呢。就写这么些能被第一时间想起的事情吧。</li>
<li>这一年觉得自己变化很大，摆脱了过去，也学会了太多的知识和道理。</li>
<li>新的一年里，继续加油。</li>
</ul>
]]></content>
      <categories>
        <category>Annual-Summary</category>
      </categories>
  </entry>
  <entry>
    <title>2019-年度总结</title>
    <url>/2019/12/18/2019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>时光易逝。</p>
<a id="more"></a>

<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本来我都忘记了这件事，结果Gaocegege的总结又让我自卑了，没办法，姑且想点东西来写吧。到今年，就是高中过去整整三年了。</p>
<h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><p>现在想起一月，最有意思的还是面试Jump。HR是个外国人，但是口音特别好听，以至于我还能听懂不少。鲁莽了一把，相信自己leetcode两百题的水平，直接Rush了笔试，然后得到了电面。电面的面试官有点小胖，看着也很和蔼，现在想来，那时候的英语真的尴尬，连Requirement都想不起来。</p>
<p>买了Switch，玩了塞尔达。因为米法那一段太感人，都玩不下去后面的内容了，一直搁浅到现在。此外，超级马里奥勾起童年，现在我终于有了可以一直玩的游戏机，却失去了好些激情。</p>
<h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><p>去了Jump在上海的办公室，坐落在环球金融中心。老实说，都没进过几次城，看到这么酷的大楼，还是有被震撼的感觉。简历上唯一被面试官注意的点是，我学过CSAPP，太感人了。</p>
<h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><p>面试了一些公司，觉得国内大厂的笔试题，是真的，很难，难到都想不清楚怎么做。至于电面，非常尴尬，没有很用心地聊天，那时候我给人的感觉就是，过于憨憨。印象特别深刻，被问了一个i++和++i有什么区别，觉得这什么玩意，不去也罢。</p>
<h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>终于做完了Kafka合作项目，去公司里做最后的presentation。当时什么都不懂，在一群CPP开发者面前讲容器，实在是让人提不起兴趣。</p>
<h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><p>面完了Optiver，侥幸拿到offer，人生轨迹就此改变，跑去打工了。虽然从去年就想着要去Optiver康康，最后愿望达成，还是很感慨，我本想装作无动于衷，但这个钱实在是太多了。</p>
<h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>给实验室的机器装机，整了个openstack。一套连招上去，就拥有了几百个核，上千GB的内存。最懵的是感觉Neutron-openswitch-agent有内存泄漏，每次跑一段时间之后就只有重启才能恢复。其他的没发现什么问题。</p>
<h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>刚到公司的一两周非常害怕，害怕大家觉得我是被老师+学长们抬进来的，被吹过头了。而且还要写C#，从零开始，做了个垃圾桌面端。结果后来贼鸡儿顺手，还和交易员沟通了一下，加强了好多功能，得到了称赞，高兴过头，连吃东西都吃得更多了，胖了好几斤。</p>
<p>公司里每天的水果，养乐多，酸奶，坚果，真的太香。</p>
<h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><p>领到了人生头一回工资，也没啥地方好花。后知后觉地发现，自己都忘记回家，没见到老同学，有些怅然若失。人生都会越来越忙碌吗，我不知道。</p>
<p>同组的实习生，是一个跨专业考研的哥们，但他对于栈，编译器都有所了解，让我惊讶他的功底。在九月里，我和他合作了第二个项目，这次总算是c++的了，还要写单元测试，GTest真秀。</p>
<h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p>参加国赛，代码写得挺多，越写越觉得还可以。现在想想，写的部分很有问题，描述得非常不清晰。</p>
<p>新的学期来临，我只有一节通识课了，想着水一水毕设，就可以快乐一年了。公司组织的年度旅游，跑去青岛爽了一波，认识了超级，超级，超级厉害的北大数学系小姐姐。她说她都第七份实习了，我顿时觉得我之前的紧张，不值一提。</p>
<h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><p>二十二岁，一天之间整了仨蛋糕，把前面二十多年的都挣回来了。原来我很快乐，只是不愿承认。</p>
<h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><p>一边带着小朋友们做项目，一边忙毕设，同时还喜欢打游戏，桌球技术也得到了极大提高。我开始以为事情都会很简单，我甚至还能有时间谈恋爱，后来发现，人是没有的，时间也是没有的。</p>
<h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><p>弄了一个AIdungeon玩，写上了Xiao Tan的快乐一生。</p>
<p>开始在联盟里征战，一手ADC强无敌。</p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>越写越是流水账，今年过得太快，什么都没记住。</p>
]]></content>
      <categories>
        <category>Annual-Summary</category>
      </categories>
  </entry>
  <entry>
    <title>2020-年度总结</title>
    <url>/2020/12/29/2020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我在哪里。</p>
<a id="more"></a>

<h2 id="艰难一年"><a href="#艰难一年" class="headerlink" title="艰难一年"></a>艰难一年</h2><p>今年对很多人来说，是异常艰难的一年，我们一起见证了新冠肺炎，美股熔断，全城封锁等诸多事件。而我，也经历了人生又一个转折点。顺利地从交大毕业，成为社会人，打工仔。</p>
<p>这一年里，完成了曾经憧憬不已的毕业论文，开始以为会是非常艰深而有意思的工作，后来发现自己终究是才疏学浅，只能尽量写一点。</p>
<h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><p>记得这时，还在忙毕业论文的事情，导师希望我顺带地水一篇论文到期刊会议上，<br>对我这个微小的个体来说，记忆里全是窝在家里写论文，打游戏之类的。</p>
<p>想着这最后半年会有不少空闲时光，就报名了学车，甚至幻想有空出去旅游一趟，奈何疫情让一切都成空。<br>最后是疫情好转了一些之后，过去学了一段时间，在工作接着周末有空去学一学。虽然开车很难，但考试很简单，中国人做题属实有一套。<br>而且，学车这件事让我大开眼界。现在回过头看，它是完完全全的考试导向，倒车不用左顾右盼，只用盯着看是不是到了固定点位，做题甚至不用读题，只需要记一些奇怪的口诀，其中最令我吃惊的口诀是类似于，如果答案出现1、2、3、4，选3，如果是2、3、4、5，选2之类的。</p>
<p>在家里呆久了就觉得无聊，屏幕太小，椅子桌子也不怎么合适，说不上来是时代在进步，科技在发展，还是我变得挑剔了，总之在很多方面都喜欢更精致一些。</p>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><p>在公司工作，脑子里还是以前实习那一套，觉得事情都比较简单，学的很多东西都派不上用场。</p>
<p>直到我真正犯了一些错误，反思的时候才意识到，在工作中输出自己的能力，是另一种艺术。</p>
<p>比方说，凡事要遵循个流程，该汇报的汇报，该开会的开会，这并不是形式主义，扪心自问，是否让别人都清楚了你的工作。</p>
<p>我个人感觉就是不停在换位思考，如果我是提出需求的，我希望对方怎么做。如果我现在是提出方案的，我又希望对方怎么做。在小公司里我的确有机会扮演各种角色，这让我体会到许多。</p>
<p>反思就会发现不足，从而做的更细致。就像打游戏拉扯，讲的是细节。</p>
<p>但总体来说我十分乐观，这些所谓工作的技巧，在三五年后，大概都会达到顶峰吧，并没有什么难的。</p>
]]></content>
      <categories>
        <category>Annual-Summary</category>
      </categories>
  </entry>
  <entry>
    <title>An interesting bug in openstack live migration</title>
    <url>/2019/11/19/An-interesting-bug-in-openstack-live-migration/</url>
    <content><![CDATA[<p>这个机器自闭了，得赶紧吃了它。</p>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>在openstack上，热迁移节点后，机器所能读到的网卡MAC地址会发生变化。</li>
<li>在Centos中，<code>/etc/udev/rules.d/70-persistent-net.rules</code>，记录了网卡的MAC地址和逻辑名称。</li>
<li>这里会出现不一致，从而导致网卡加载失败。</li>
<li>至于这是一个稳定的bug还是偶尔热迁移出错，并不清楚。</li>
</ul>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><code>ip addr</code>可查看修改后的mac地址。</li>
<li>重写<code>/etc/udev/rules.d/70-persistent-net.rules</code>。</li>
</ul>
<h2 id="问题的严重性"><a href="#问题的严重性" class="headerlink" title="问题的严重性"></a>问题的严重性</h2><ul>
<li>令人苦恼的在于，虚拟机网卡加载失败，就无法再ssh连接到机器上，想要修改文件也变得很难。</li>
</ul>
<h2 id="Guestfish"><a href="#Guestfish" class="headerlink" title="Guestfish"></a>Guestfish</h2><ul>
<li>由此，发现了一个修改虚拟机文件系统的好东西。</li>
<li><a href="https://www.cyberciti.biz/faq/how-to-reset-forgotten-root-password-for-linux-kvm-qcow2-image-vm/" target="_blank" rel="noopener">参考网页</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install libguestfs-tools</span><br><span class="line">guestfish --rw -a diskfile</span><br><span class="line">run</span><br><span class="line">list-filesystem</span><br><span class="line"></span><br><span class="line">mount /dev/sda1 /</span><br><span class="line"></span><br><span class="line">vi /etc/shadow</span><br></pre></td></tr></table></figure>

<ul>
<li>注意修改的时候把虚拟机关机。</li>
<li>如果不小心搞崩了文件系统，可以用fsck恢复。</li>
</ul>
<p>docker run –rm -it -v /home/lib/docker/volumes/nova_compute/_data/:/var/lib/nova -v /tmp:/tmp xword/guestfish -r -a /var/lib/nova/instances/87d9b0e0-46f6-4308-b8b3-67f3f2d91bc9/disk</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Openstack</tag>
        <tag>Linux</tag>
        <tag>Centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible部署Hadoop</title>
    <url>/2018/11/26/Ansible%E9%83%A8%E7%BD%B2Hadoop/</url>
    <content><![CDATA[<p>CSE lab4，在四台腾讯云服务器上部署Hadoop。</p>
<a id="more"></a>

<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><p>Python编写的运维工具，在我看来很好地解决了一些常见问题，比如，自己编写shell的话，会需要编写很多关于ssh、loop等等的内容，但实际上没有什么业务意义，我更关心的是软件安装包、上传下载、运行脚本等等。</p>
<h3 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h3><p>一般的机器都默认开启了公钥认证，就是第一次连接时会验证一下地址，并交互式的确定，然后存在kown_hosts文件中。  </p>
<p>这是为了安全考虑，但是不便于脚本执行，可以关闭掉这个验证。</p>
<ul>
<li><p>配置文件/etc/ansible/ansible.cfg的[defaults]中打开注释</p>
  <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncomment this to disable SSH key host checking</span></span><br><span class="line"><span class="string">host_key_checking</span> <span class="string">=</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><h4 id="User-Group"><a href="#User-Group" class="headerlink" title="User, Group"></a>User, Group</h4><ul>
<li>用于管理用户和用户组，语法简单，基本靠state就够了。</li>
<li>用户shell设为bash会比较强大。</li>
<li>设置密码有点麻烦，需要sha加密。</li>
<li>使用这个模块需要root权限。</li>
</ul>
<h4 id="Authorized-keys-hostname"><a href="#Authorized-keys-hostname" class="headerlink" title="Authorized_keys, hostname"></a>Authorized_keys, hostname</h4><ul>
<li>添加key，主要参数有user和key。</li>
<li>hostname用name参数就可以。</li>
</ul>
<h4 id="template-jinja2"><a href="#template-jinja2" class="headerlink" title="template(jinja2)"></a>template(jinja2)</h4><ul>
<li>功能非常强大的模板，平时就用于修改配置文件。</li>
<li>分布式系统，不同节点上的配置文件可能会不一样，即使是一样也可能部分配置是动态读取的。这个时候就可以用jinja2的一些语法，替换变量、条件分支、循环等等。</li>
<li>这里的变量可以依靠facts获取。</li>
</ul>
<h4 id="apt-yum"><a href="#apt-yum" class="headerlink" title="apt, yum"></a>apt, yum</h4><ul>
<li>安装软件包的模块。</li>
</ul>
<h4 id="copy-unarchive-lineinfile"><a href="#copy-unarchive-lineinfile" class="headerlink" title="copy, unarchive, lineinfile"></a>copy, unarchive, lineinfile</h4><ul>
<li>传送文件、文件夹和压缩包。</li>
<li>lineinfile可能更适合修改profile、hosts等文件，它具有幂等性。</li>
</ul>
<h4 id="shell-command-script"><a href="#shell-command-script" class="headerlink" title="shell, command, script"></a>shell, command, script</h4><ul>
<li>执行命令，command更安全，shell会起实例。</li>
</ul>
<h4 id="register与when"><a href="#register与when" class="headerlink" title="register与when"></a>register与when</h4><ul>
<li>register写在一个task里，用于获取返回值，when是条件判断，用于决定任务执行时间。</li>
</ul>
<h4 id="setup-facts"><a href="#setup-facts" class="headerlink" title="setup, facts"></a>setup, facts</h4><ul>
<li>获取巨量硬件信息，比如系统版本，节点名称，然后会作为变量被使用。</li>
<li>可以设定参数，gather-fact false关闭这个功能。</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer System Engineering 课程笔记</title>
    <url>/2019/01/03/Computer-System-Engineering-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>等到学期末才发现，CSE这门课干货太多，复习的时候需要整理整理。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h2><h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><ul>
<li>两种路由选择算法是以Dijkstra和bellman-ford为基础的，一开始没注意到这一点，总觉得非常困惑，不知道为什么算法是正确的。</li>
</ul>
<h2 id="Fault-Tolerating"><a href="#Fault-Tolerating" class="headerlink" title="Fault Tolerating"></a>Fault Tolerating</h2><ul>
<li>我觉得这句话说的太好了，一切容错基于冗余（redundancy）。</li>
<li>要么是空间冗余，要么是时间冗余。</li>
</ul>
<h2 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h2><ul>
<li>TODO</li>
</ul>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><ul>
<li>见Paper-note。</li>
</ul>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul>
<li>TODO</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Dive into nginx http_ssl and upstream ssl</title>
    <url>/2019/06/11/Dive-into-nginx-http-ssl-and-upstream-ssl/</url>
    <content><![CDATA[<p>重新从应用层面考量ssl，思考在四层转发和七层转发中，实现ssl会有何问题。</p>
<a id="more"></a>

<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><ul>
<li>TLS是SSL的升级版，TLS 1.0是目前应用最广泛的。</li>
<li>TLS介于TCP和HTTP之间，但其实TLS已经和上层应用无关了。</li>
</ul>
<h2 id="stream-ssl"><a href="#stream-ssl" class="headerlink" title="stream ssl"></a>stream ssl</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream  horizon &#123;</span><br><span class="line">         server 10.1.0.254:80;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen                5000 ssl;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">        ssl_certificate     &#x2F;root&#x2F;horizon-ssl&#x2F;ssl.crt;</span><br><span class="line">        ssl_certificate_key &#x2F;root&#x2F;horizon-ssl&#x2F;ssl.key;</span><br><span class="line">        ssl_session_cache   shared:iSSL:10m;</span><br><span class="line">        ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">        proxy_pass            horizon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在stream上开启ssl，就是直接加了一层TLS，转发不影响后端应用。</li>
<li>但坑爹是后端的redirect不能正常运行。</li>
<li>如果后端是一个http服务器，那么redirection就会是<code>http://server</code>。</li>
<li>并且此时不能应用proxy_redirect。</li>
</ul>
<h2 id="http-ssl"><a href="#http-ssl" class="headerlink" title="http ssl"></a>http ssl</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8080 ssl;</span><br><span class="line">        server_name 202.120.40.8:1180</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;</span><br><span class="line">        ssl_certificate     &#x2F;root&#x2F;horizon-ssl&#x2F;ssl.crt;</span><br><span class="line">        ssl_certificate_key &#x2F;root&#x2F;horizon-ssl&#x2F;ssl.key;</span><br><span class="line">        ssl_session_cache   shared:SSL:10m;</span><br><span class="line">        ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;10.1.0.254:80;</span><br><span class="line">           proxy_redirect http:&#x2F;&#x2F; https:&#x2F;&#x2F;;</span><br><span class="line">           proxy_set_header Host      $host:1180;</span><br><span class="line">           proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page  497  https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>http转发就复杂了，nginx会重新拟http请求报文，后端接收到的http和用户原本的就不太一样了。</li>
<li>所以这里设置了一些参数，让几个header和用户的相同。</li>
<li>这里服务端返回的redirect会是http，所以需要重写成https。</li>
</ul>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK+Kafka日志收集分析</title>
    <url>/2018/11/17/ELK-Kafka%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>一些系统运行时生成log文件，搭建一套系统，完成从log file中获取数据，并收集到一个统一的数据中心。</p>
<a id="more"></a>

<h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>elasticsearch、logstash、kibana。曾经使用过elastic技术栈，现在看来它发展挺快的，但是这次实际使用发现，它的性能表现不太好。</p>
<h3 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h3><p>logstash负责对数据进行格式化处理，类似产品有fluentd。</p>
<ul>
<li><p>配置简单，流水线式的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats&#123;</span><br><span class="line">      port &#x3D;&gt; 5644</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">      match &#x3D;&gt; &#123;</span><br><span class="line">          &quot;message&quot; &#x3D;&gt; [&quot;%&#123;PARAMS_APACHELOG&#125;&quot;, &quot;%&#123;NO_PARAMS_APACHELOG&#125;&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">      remove_field &#x3D;&gt; [&quot;host&quot;, &quot;timestamp&quot;, &quot;httpversion&quot;, &quot;@version&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">      hosts &#x3D;&gt; [&quot;elastic:9200&quot;]</span><br><span class="line">      index &#x3D;&gt; &quot;logstash-test-%&#123;type&#125;-%&#123;host&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>grok是一个常用且强大的处理工具，可以提取timestamp，拆分信息等。</p>
</li>
</ul>
<h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><p>Beats是elastic recommend 的工作方式。数据流向：Beats =&gt; logstash =&gt; elasticsearch。目前已经有了很多种类的beat，一般来说，beat放在客户端，logstash放在服务端。</p>
<ul>
<li>尝试中发现，filebeat给logstash发送消息，性能并不高。</li>
<li>虽然beat比较轻量级，但实际上它的功能也很强大，比如filebeat还具有regex match， field filter（processor）。</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>最终在Beat和Logstash之间加了一层Kafka，好处有性能提升，容灾增强，流量控制等。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang的奇妙之旅</title>
    <url>/2020/02/24/Golang%E7%9A%84%E5%A5%87%E5%A6%99%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>实践过程中的一些小问题。</p>
<a id="more"></a>

<h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul>
<li><p>Golang的包管理极其玄幻，在1.11以前，依赖库均下载到GOPATH/src，安装到GOPATH/pkg。首先，难以维护多个版本，或者说对依赖库就没有版本的限定，其次，正在开发的项目也要放到GOPATH里，整个依赖树才能正常运行。</p>
</li>
<li><p>Go 1.11之后，Go modules略微改善了这个状况，在我的视角来看，现在的包管理变成：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init</span><br><span class="line">go get xxx</span><br></pre></td></tr></table></figure>

<p>也不用再配置GOPATH，默认为用户目录，下载的包位置即<code>~/go/pkg/mod</code>。在项目里多了go.mod和go.sum两个文件，以控制依赖库的版本。</p>
</li>
<li><p>有趣的是，不一定要先go get，在源码里直接import之后，go build会自动将依赖下载并添加到go.mod中。<code>go mod tidy</code>则用来去除多余的依赖。</p>
</li>
</ul>
<h2 id="切片类型"><a href="#切片类型" class="headerlink" title="切片类型"></a>切片类型</h2><ul>
<li>Golang的切片类型十分有趣，从原理上讲，它是一个特殊的结构，包含指向相关数组的指针，切片长度以及切片容量。</li>
<li>切片只是底层数组的一个片段引用，比裸指针使用起来多了更多检查，不至于Segmentation fault。</li>
<li>append函数，可以将一个或多个新元素追加到某个切片后，当底层数组的长度足够，那就只需要修改切片长度，并且复制元素。当底层数组cap用尽，append会分配一块新的内存，并将原有数组拷贝。很显然，这时指针会发生变化，因此，append总是以<code>a = append(a, x1, x2)</code>形式出现。</li>
</ul>
<h2 id="非侵入式接口"><a href="#非侵入式接口" class="headerlink" title="非侵入式接口"></a>非侵入式接口</h2><ul>
<li>真正的鸭子类型，并且在编译期就做足了检查，非常美妙。</li>
<li>只要一个struct实现了某个interface要求的所有接口，那它就可以被当作interface类型，不需要声明implement。</li>
<li>感觉对代码重构提供不少便利，也不必先设计接口再实现，只管先实现一些模块，当发现方法和参数相同或接近时，再稍作调整，外部声明一个interface，就可以实现多态的用法。</li>
</ul>
<h2 id="if-err的哲学"><a href="#if-err的哲学" class="headerlink" title="if err的哲学"></a>if err的哲学</h2><ul>
<li><p>Golang的代码里，if err满天飞。</p>
</li>
<li><p>典型的C风格错误处理，try catch主要的好处是可以跨层抛出，将错误处理留给外层合适的函数来处理。使用return的方式抛出异常，则需要调用链上的每一层都写错误处理代码，冗余很多。</p>
</li>
<li><p>此外，Golang的函数并不声明返回的err具体包括哪些类型，往往需要付出更多代价，查阅源码或文档，才能写好错误处理。</p>
</li>
<li><p>error本身只是一个接口，里面只有一个error() string 方法，返回错误信息。官方建议是，每个错误都声明新的类型，实现error方法，上层用type-switch判断错误类型。</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Square %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Circle %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>哲学在于一句话：让代码更容易看出控制流走向。虽然if-err结构很多，但它也算是让代码更可读了。</p>
</li>
</ul>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><ul>
<li>编写网络服务的过程中，很自然地想要使用epoll去管理网络连接。随后我发现，Golang中的网络库已经结合了epoll。</li>
<li>简而言之，只需要创建多个Go routine，直接以同步阻塞的方式去编写代码。</li>
</ul>
<h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><ul>
<li>算是对结构体的一种超级加强。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> innerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    in1 <span class="keyword">int</span></span><br><span class="line">    in2 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> outerS <span class="keyword">struct</span> &#123;</span><br><span class="line">    b    <span class="keyword">int</span></span><br><span class="line">    c    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">int</span>  <span class="comment">// anonymous field</span></span><br><span class="line">    innerS <span class="comment">//anonymous field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在结构体里直接写某一种类型名，同种类型只能写一个，这时使用<code>o.in2</code>直接访问内嵌的数据。</li>
<li>显然，会出现命名冲突的情况，首先外层地会覆盖内层，如果同级，则程序员显式地指出<code>o.innerS.in2</code>。</li>
<li>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型继承了这些方法：将父类型放在子类型中来实现亚型。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</li>
</ul>
<h2 id="一等公民：函数"><a href="#一等公民：函数" class="headerlink" title="一等公民：函数"></a>一等公民：函数</h2><ul>
<li>Golang中的函数也是可以当作函数参数的类型。</li>
<li>具备闭包特性。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>强烈推荐，值得反复查阅： <a href="https://github.com/unknwon/the-way-to-go_ZH_CN" target="_blank" rel="noopener">The way to Go</a></li>
<li>起步时参考的项目：<a href="https://github.com/drone/drone" target="_blank" rel="noopener">Drone</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>How Does Openstack MTU influence Virtual Network like Calico</title>
    <url>/2019/06/11/How-Does-Openstack-MTU-influence-Virtual-Network-like-Calico/</url>
    <content><![CDATA[<p>MTU也听说了好多次了，这次还是头一回仔细想这个参数。</p>
<a id="more"></a>

<h2 id="Overlay-Network"><a href="#Overlay-Network" class="headerlink" title="Overlay Network"></a>Overlay Network</h2><ul>
<li>overlay，指的是一种网络架构上叠加的虚拟化技术模式，其大体框架是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其它网络业务分离，并且以基于IP的基础网络技术为主。Overlay 技术是在现有的物理网络之上构建一个虚拟网络，上层应用只与虚拟网络相关。</li>
</ul>
<h2 id="Vxlan"><a href="#Vxlan" class="headerlink" title="Vxlan"></a>Vxlan</h2><ul>
<li>Vxlan就是一种应用广泛，成熟度高的overlay技术。它通过MAC in UDP的形式包装报文。<br><img src="/2019/06/11/How-Does-Openstack-MTU-influence-Virtual-Network-like-Calico/How-Openstack-MTU-influences-Virtual-Network-like-Calico/vxlan-packet.png" alt="图片加载失败"></li>
<li>VNI就是用来标示不同的Vxlan平面，24bits要比vlan的12bits更多。</li>
<li>基于UDP，便于兼容一些现有的设备，如NAT。</li>
<li>增加的报文头部共20+8+8+14=50字节。 （IP包应为20字节，图有问题）</li>
</ul>
<h2 id="Ethernet-Frame"><a href="#Ethernet-Frame" class="headerlink" title="Ethernet Frame"></a>Ethernet Frame</h2><ul>
<li>在以太网链路上的数据包称作以太帧。以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。</li>
<li>以太帧的头尾大小加起来18字节，而标准的帧大小为1518字节。这个数值是一个折中的选择，因为网络是分时复用的，帧过大，latency增加，过小，则浪费资源。一个帧的传输是连续的。</li>
</ul>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><ul>
<li>Maximum Transmission Unit，最大传输单元。</li>
<li>MTU是数据链路层的概念。MTU限制的是数据链路层的payload，也就是上层协议的大小，例如IP，ICMP等。</li>
<li>这个值会影响各个网络传输设备组织自己发出去包的形式，一般来说，超出大小的，会被切分成多个包。</li>
<li>以太帧大小为1518字节，除去自己的头尾，就剩下1500字节。所以平时电脑上网卡显示的MTU都是1500字节。</li>
</ul>
<h2 id="Openstack-VM-（OVS）"><a href="#Openstack-VM-（OVS）" class="headerlink" title="Openstack VM （OVS）"></a>Openstack VM （OVS）</h2><ul>
<li>基于OVS的neutron网络，通常提供给VM的网络就是Vxlan实现。创建出来的VM，MTU默认为1450，源于标准的1500减去Vxlan增加的头部大小。这样设置对网络效率有利。</li>
<li>如果不刻意去算MTU，一般也发现不了有什么问题，大多数网络设备都会将包分片，从而支持不同的MTU大小，只是网络速度上略微有些影响，平时感觉不出来。</li>
<li>但是，OVS非常暴力，不会帮助切片，只是丢弃掉超出大小的包，所以如果VM发的包有问题，就会出现简单的ping可达，应用却经常timeout。（因为ping报文小，没有触及MTU）</li>
</ul>
<h2 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h2><ul>
<li><p>问题终于出现了，当在虚拟机上运行有关网络虚拟化的程序时，大多程序都不能正确设置自己的MTU大小，它们通常使用默认值1500，然后被OVS无情丢弃。</p>
</li>
<li><p>虚拟化网络组件会创建自己的虚拟网卡，连接虚拟网关，这张虚拟卡，MTU需要仔细考量。</p>
</li>
<li><p>Calico如果开启了IP in IP功能，那么Calico自己也会在报文上增加20字节头，实现自己的Overlay，这时候MTU要设置成1430才能正常工作。</p>
</li>
<li><p><a href="https://docs.projectcalico.org/v3.5/usage/configuration/mtu" target="_blank" rel="noopener">Calico Configure MTU Docs</a></p>
</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li>Docker创建的网关，MTU会和host一致，而且此时linux bridge会帮助切片，不会引发断网现象，但有关性能。</li>
<li>容器里感知到的MTU改成1450会更合适一些，这个在<code>daemon.json</code>中可以设置。</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Openstack</tag>
        <tag>Calico</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>How to limit bandwidth in Swarm overlay network</title>
    <url>/2019/04/11/How-to-limit-bandwidth-in-Swarm-overlay-network/</url>
    <content><![CDATA[<p>Use wondershaper in Docker Swarm.</p>
<a id="more"></a>

<h2 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h2><ul>
<li>A useful tool: <a href="https://github.com/magnific0/wondershaper" target="_blank" rel="noopener">wondershaper</a><ul>
<li><code>Wonder Shaper is a script that allow the user to limit the bandwidth of one or more network adapters. It does so by using iproute&#39;s tc command, but greatly simplifies its operation.</code></li>
</ul>
</li>
</ul>
<h2 id="Normal-Container"><a href="#Normal-Container" class="headerlink" title="Normal Container"></a>Normal Container</h2><ul>
<li><p>A normal container’s network is in an absolute namespace, we can verify this by below instructions.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it $&#123;container_id&#125; /bin/bash</span><br><span class="line">ip addr</span><br><span class="line">---</span><br><span class="line">  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">  inet 127.0.0.1/8 scope host lo</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 ::1/128 scope host</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN qlen 1</span><br><span class="line">      link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">  16042: eth0@if16043: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">      link/ether 02:42:ac:13:00:04 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">      inet 172.19.0.4/16 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">      inet6 fe80::42:acff:fe13:4/64 scope link</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">ifconfig</span><br><span class="line">---</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:13:00:04</span><br><span class="line">        inet addr:172.19.0.4  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">        inet6 addr: fe80::42:acff:fe13:4/64 Scope:Link</span><br><span class="line">        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">        RX packets:159995 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">        TX packets:318058 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">        collisions:0 txqueuelen:0</span><br><span class="line">        RX bytes:13868114 (13.2 MiB)  TX bytes:23103415 (22.0 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">        inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">        inet6 addr: ::1/128 Scope:Host</span><br><span class="line">        UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">        RX packets:39 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">        TX packets:39 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">        collisions:0 txqueuelen:1</span><br><span class="line">        RX bytes:2994 (2.9 KiB)  TX bytes:2994 (2.9 KiB)</span><br></pre></td></tr></table></figure>

<p>In host:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">---</span><br><span class="line">br-2555d002131c: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">      inet 172.19.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">      inet6 fe80::42:afff:fe8a:31a4  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">      ether 02:42:af:8a:31:a4  txqueuelen 0  (Ethernet)</span><br><span class="line">      RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">      RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">      TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">ip link</span><br><span class="line">---</span><br><span class="line"> 16043:</span><br><span class="line">      veth429e849@if16042: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-2555d002131c state UP mode DEFAULT</span><br><span class="line">      link/ether ee:e7:70:1b:b8:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 28</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">ethtool -S veth429e849</span><br><span class="line">---</span><br><span class="line">NIC statistics:</span><br><span class="line">  peer_ifindex: 16042</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">route</span><br><span class="line">---</span><br><span class="line">172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-2555d002131c</span><br></pre></td></tr></table></figure>
</li>
<li><p>eth0@16042 in container and veth@16043 in host is a pair</p>
</li>
<li><p>bridge mode: the veth in host connect to a bridge, if we connect several veth to the same bridge.</p>
</li>
<li><p>Container set its default dev as eth0</p>
</li>
<li><p>host insert a record into the route table: xxx.xxx.xxx.xxx/xx -&gt; br-xx</p>
</li>
</ul>
<h2 id="Interact-with-external-network"><a href="#Interact-with-external-network" class="headerlink" title="Interact with external network"></a>Interact with external network</h2><ul>
<li>MASQUERADE策略用来将请求包中的源地址转换成一个网络设备的地址，当容器需要和宿主机的外部网络通信，那么ip需要做一次转换。<ul>
<li><code>sudo sysctl -w net.ipv4.conf.all.forwarding=l</code></li>
<li><code>sudo iptables -t nat -A POSTROUTING -s 172.19.0.0/24 -o ethO -j MASQUERADE</code></li>
</ul>
</li>
<li>DNAT则用来映射容器的服务到host ip上，也就是通常的port映射。<ul>
<li><code>sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to- destination 172.19.0.2 : 80</code></li>
</ul>
</li>
</ul>
<h2 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h2><ul>
<li><p>This case is the same as a container joinning different bridges.</p>
</li>
<li><p>In container, there are two veths. One connects the host and another connects the overlay network.</p>
</li>
<li><p>It’s interesting that overlay network has its own namespace.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">  NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">  8af77005fccd        bridge              bridge              local</span><br><span class="line">  0a9f19fcc8f6        docker_gwbridge     bridge              local</span><br><span class="line">  4ff101446cb3        host                host                local</span><br><span class="line">  lcm7v5396eh8        ingress             overlay             swarm</span><br><span class="line">  j1fvxxfk00l1        net1                overlay             swarm</span><br><span class="line">  bc58f94703ff        none                null                local</span><br><span class="line"></span><br><span class="line">nsenter --net=/var/run/docker/netns/1-j1fvxxfk00 ifconfig</span><br><span class="line">  veth73: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">      ether 3a:6c:9f:88:87:f1  txqueuelen 0  (Ethernet)</span><br><span class="line">      RX packets 10034  bytes 56493239 (53.8 MiB)</span><br><span class="line">      RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">      TX packets 10498  bytes 3671156 (3.5 MiB)</span><br><span class="line">      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nsenter</code> helps us to enter a network namespace (placed in <code>/var/run/docker/netns/</code>).</p>
</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>Finally, we found the veth-peer which connects the container to overlay net. We can limit the bandwidth in specific namespace. Since docker doesn’t create a symlink in <code>/var/run/netns</code> for its netns, we can’t use <code>ip</code>. Here is a method to fix this.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PID=$(docker inspect -f '&#123;&#123;.State.Pid&#125;&#125;' $CONTAINER_ID)</span><br><span class="line">ln -sfT /proc/$PID/ns/net /var/run/netns/$CONTAINER_ID</span><br><span class="line">ip netns exec $CONTAINER_ID ip link add ifb0 type ifb</span><br><span class="line">ip netns exec $CONTAINER_ID ip link set dev ifb0 up</span><br><span class="line">ip netns exec $CONTAINER_ID ./wondershaper -a eth0 -u $U_LIMIT -d $D_LIMIT</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nsenter</code> is easier to use.</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nsenter /var/run/netns/$CONTAINER_ID ip link add ifb0 type ifb</span><br><span class="line">nsenter /var/run/netns/$CONTAINER_ID ip link set dev ifb0 up</span><br><span class="line">nsenter /var/run/netns/$CONTAINER_ID  ./wondershaper -a eth0 -u $U_LIMIT -d $D_LIMIT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-Stream流式处理</title>
    <url>/2019/01/03/Kafka-Stream%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>恰好接触了Kafka，顺便再用Kafka-Stream编写一个基于流式处理的监控程序。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>流处理是一个比较新的概念。与之相对的是批处理，一般认为，批处理可以增加系统的吞吐量，但对于其中单个请求，latency可能会增加。</li>
<li>使用流处理是为了得到更低的延迟、更快的反馈，很多信息的价值是随着时间降低的。</li>
</ul>
<h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><ul>
<li>流处理非常适合时间序列的数据，检测模式发生改变的数据。</li>
<li>如果数据需要被多次传递和访问，就不太适合流处理，比如机器学习算法。</li>
</ul>
<h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka-Stream"></a>Kafka-Stream</h3><ul>
<li>Kafka是一个消息中间件，具有很高的读写性能。</li>
<li>Kafka-Stream是一个轻量的java库，可以用流的方式读取和处理Kafka中的消息，并且输出结果到其他地方或写回Kafka。</li>
</ul>
<h3 id="KStream、KTable"><a href="#KStream、KTable" class="headerlink" title="KStream、KTable"></a>KStream、KTable</h3><ul>
<li>Kafka-Stream的处理流程可以表示为图，有input、processor、output，其中的input一定是某个topic，processor、output则可以完全自定义。</li>
</ul>
<p><img src="http://kafka.apache.org/21/images/streams-architecture-topology.jpg" alt="图片加载失败"></p>
<ul>
<li>KStream、KTable则是功能强大的内置processor（从概念上讲如此，但是库的接口设计，看起来有所区别）。</li>
<li>需要注意的是，流处理的过程中，总是指明serde类型能避免类型错误。</li>
<li>KStream的对象具有key-value，常用操作为map。</li>
<li>KStream经过group就能变成KTable，然后可以使用聚合操作，比如count。</li>
<li>当使用count，有一个隐式的memory-state-store被使用，这也是我认为KTable、KStream只是特殊的processor的原因。我们完全可以自己声明processor和store，实现相同的效果。</li>
<li>TODO：memory-state如何实现并发？</li>
</ul>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><ul>
<li>Window是一类特殊的KTable，它的key是KTable的key在加上时间。</li>
<li>时间窗口用于处理实时集合数据。</li>
<li>一个非常有意思的问题是，即使是Window，count也不会report 0。KTable无法report 0是很显然的，没有某个消息，那么就没有那个key。我们大多数时候都不清楚有多少个key。</li>
<li>Window也有相同问题，但是Window的key有两段意义，即消息key+时间key，某些场景下，我们希望能捕捉在某个时间段缺失的数据。</li>
<li>遗憾的是，Window是KTable子类，处理方式相同，如果消息key出现过，但是某个时间没有，这个Window仍然不存在。</li>
<li><a href="https://stackoverflow.com/questions/45097611/kafka-stream-count-on-time-window-not-reporting-zero-values" target="_blank" rel="noopener">Related Problem on stackoverflow</a></li>
</ul>
<h3 id="Fault-Tolerant-State-Store"><a href="#Fault-Tolerant-State-Store" class="headerlink" title="Fault-Tolerant State Store"></a>Fault-Tolerant State Store</h3><ul>
<li>state-store默认是会发送change-log给kafka的，从而持久化state。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB混合编程</title>
    <url>/2020/03/29/MATLAB%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>出于一些奇怪的原因，尝试了一把MATLAB混合编程。<br>Java等语言更适合搭建Web Server，处理文件，而MATLAB有许多优秀的内置函数，用起来十分方便。<br>两者结合，就能写出提供一些计算函数的后端服务，配合上前端，就能在网页上用MATLAB了。</p>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用其他编程语言调用MATLAB，有两种办法，一种是使用MATLAB ENGINE的API，另一种是MATLAB COMPILER将MATLAB函数打包成其他语言的形式。<br>我主要使用第二种，原因是在部署机上没有MATLAB的LICENSE，而且也不想在每个Server上都运行一个完整的MATLAB。第二种方式，最终执行函数的机器，<br>只需要安装了MCR（MATLAB COMPILER RUNTIME）就可以了。</p>
<h2 id="MATLAB-COMPILER-RUNTIME"><a href="#MATLAB-COMPILER-RUNTIME" class="headerlink" title="MATLAB COMPILER RUNTIME"></a>MATLAB COMPILER RUNTIME</h2><p>在官网上下载安装包，按照步骤安装即可，但要注意版本保证和MATLAB的版本一致。</p>
<h2 id="MATLAB-COMPILER"><a href="#MATLAB-COMPILER" class="headerlink" title="MATLAB COMPILER"></a>MATLAB COMPILER</h2><p>安装MATLAB的时候勾选这类产品即可。</p>
<p>使用时，在命令行输入<code>deploytools</code>即可调出界面，在里面配置好编译的选项。</p>
<p>对于JAVA Library，需要勾选输入的.m文件，设定Java类名，检查方法名。<br>JAVA_HOME一定要设置对，COMPILER会使用到javac进行编译。<br>最后打包出来就是一个jar包，在项目中导入使用即可。<br>Java应用还需要导入<code>javabuiler.jar</code>，这个包在MATLAB或者MCR的安装目录下都会有。</p>
<p>以Linux上的v95版本MCR为例（对应MATLAB 2018b），路径为<br><code>/usr/local/MATLAB/MATLAB_Runtime/v95/toolbox/javabuilder/jar/javabuiler.jar</code></p>
<h2 id="Call-MATLAB-Function-From-JAVA"><a href="#Call-MATLAB-Function-From-JAVA" class="headerlink" title="Call MATLAB Function From JAVA"></a>Call MATLAB Function From JAVA</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% usersolve.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[outputArg1,outputArg2, outputArg3]</span> = <span class="title">usersolve</span><span class="params">(arg)</span></span></span><br><span class="line">options = optimoptions(<span class="string">'fsolve'</span>,<span class="string">'Display'</span>,<span class="string">'off'</span>);</span><br><span class="line">[outputArg1, outputArg2, outputArg3] = fsolve(@InputSolve, arg, options);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>打包成<code>usersolve.jar</code>，放到java项目的lib目录下，添加maven引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>algo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>usersolve<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/usersolve.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller代码。这里我犯了一个错误，我以为MCR会如同MATLAB一样，从Documents/MATLAB目录下加载.m文件。但是其实，MCR只能执行编译过的文件，而且会为这些具体函数建立一个cache，目录为<code>$USER_HOME/.mcrCache9.5/userso2/</code>。<br>这个目录里可以看到，所有的函数都是二进制格式。<br>所以我虽然接收并存储了用户的函数代码，但实际上执行的还是之前打包进来的InputSolve函数，并不能动态加载函数，这是个失败例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSolve</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserSolveService userSolveServicej;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/usersolve"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> UserSolveResponseBody <span class="title">userSolve</span><span class="params">(@RequestBody UserSolveBody userSolveBody)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        UserSolveResponseBody userSolveResponseBody = <span class="keyword">new</span> UserSolveResponseBody();</span><br><span class="line">        String funcFile = System.getProperty(<span class="string">"juser.home"</span>) + <span class="string">"/Documents/MATLAB/InputSolve.m"</span>;</span><br><span class="line">        OutputStream f = <span class="keyword">new</span> FileOutputStream(funcFile);</span><br><span class="line">        f.write(userSolveBody.getFunction().getBytes());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] res = userSolveService.solve(userSolveBody.getSolution());</span><br><span class="line">            userSolveResponseBody.setFlag(((MWNumericArray)res[<span class="number">2</span>]).getInt());</span><br><span class="line"></span><br><span class="line">            List&lt;List&lt;Double&gt;&gt; x = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Object[] xObj = ((MWNumericArray) res[<span class="number">0</span>]).toArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; xObj.length; i++) &#123;</span><br><span class="line">                x.add(DoubleStream.of((<span class="keyword">double</span>[]) xObj[i]).boxed().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            userSolveResponseBody.setX(x);</span><br><span class="line">            List&lt;List&lt;Double&gt;&gt; fval = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Object[] fvalObj = ((MWNumericArray) res[<span class="number">1</span>]).toArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fvalObj.length; i++) &#123;</span><br><span class="line">                fval.add(DoubleStream.of((<span class="keyword">double</span>[]) fvalObj[i]).boxed().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            userSolveResponseBody.setFval(fval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MWException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            userSolveResponseBody.setErrorInfo(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userSolveResponseBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSolveService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserSolve userSolve;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserSolveService</span><span class="params">()</span> <span class="keyword">throws</span> MWException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userSolve = <span class="keyword">new</span> UserSolve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] solve(List&lt;List&lt;Double&gt;&gt; solution) <span class="keyword">throws</span> MWException &#123;</span><br><span class="line">        Object[] objects = <span class="keyword">new</span> Object[solution.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solution.size(); i++) &#123;</span><br><span class="line">            objects[i]  = solution.get(i).toArray();</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] result = &#123;<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>&#125;;</span><br><span class="line">        Object[] input = &#123;objects&#125;;</span><br><span class="line">        userSolve.usersolve(result, input);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的事情是，给MATLAB函数传参数，统统都是用Object[]。<br>并且对象数组可以嵌套，而可用的基本类型有double、int、long。<br>matlab里的矩阵就可以用<code>double[][]</code>表示，虽然先声明<code>Object[]</code>，<br>在逐层向里面加入数据更为灵活。</p>
<p>MATLAB返回的参数，要么会用NumericArray包装，要么就是裸的数据类型。<br>只是，不同的内置函数的返回类型究竟对应什么，我也没有弄很清楚。</p>
<p>函数画图可以采用webfigure，java这里就对应jsp。</p>
<p>springboot里要启用jsp，添加如下参数。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.mvc.view.prefix=/WEB-INF/jsp/</span></span><br><span class="line"><span class="string">spring.mvc.view.suffix=.jsp</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"MyFigure"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weibull</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WeibullService weibullService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/weibull"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">weibull</span><span class="params">(@RequestBody WeibullInputBody weibullInputBody, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MWNumericArray numericArray = (MWNumericArray) weibullService.evaluate(weibullInputBody.getData());</span><br><span class="line">            model.addAttribute(<span class="string">"a1"</span>, numericArray.getDouble(<span class="number">1</span>));</span><br><span class="line">            model.addAttribute(<span class="string">"a2"</span>, numericArray.getDouble(<span class="number">2</span>));</span><br><span class="line">            model.addAttribute(<span class="string">"MyFigure"</span>, weibullService.plot(numericArray));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MWException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"weibull"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"wf"</span> uri=<span class="string">"http://www.mathworks.com/builderja/webfigures.tld"</span> %&gt;</span><br><span class="line">&lt;wf:web-figure name=<span class="string">"MyFigure"</span> scope=<span class="string">"session"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>但是，这个jsp里的web-figure会被替换成一段iframe，然后指向了地址<code>$HOST/WebFigures/$name</code>。也就是说，还会有二次请求，那么显然这个地址会404，因为我们没有配置关于这个地址的处理函数。<br>实际上它的处理函数应该对应MATLAB提供的一个Servlet：<br><code>com.mathworks.toolbox.javabuilder.webfigures.WebFiguresServlet</code>。</p>
<p>那么springboot里怎么简单地加入一个别人写的servlet呢，<br>因为我只找到了一个<code>WebServlet</code>注解，然后它只能加在某个类上，<br>又因为这个类不是我写的，我只能使了个小技巧，继承了这个类。<br>或者退回到使用mvc的方式，在web.xml里写servlet标签。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"MyServlet"</span>,urlPatterns = <span class="string">"/WebFigures/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Webfigure</span> <span class="keyword">extends</span> <span class="title">WebFiguresServlet</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App处加上扫描Servlet的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(App<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MATLAB 函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">df</span> = <span class="title">getWebFigure</span><span class="params">()</span></span></span><br><span class="line">    f=<span class="built_in">figure</span>(<span class="string">'Visible'</span>, <span class="string">'off'</span>);</span><br><span class="line">    <span class="comment">% plot()</span></span><br><span class="line">    df = webfigure(f)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>JAVA接收webfigure。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((MWJavaObjectRef)result[<span class="number">0</span>]).get()</span><br><span class="line"><span class="comment">// 然后把这个对象设置成session的key-value</span></span><br><span class="line"><span class="comment">// key为jsp中对应的figure name</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Mastering Git</title>
    <url>/2019/10/08/Mastering-Git/</url>
    <content><![CDATA[<p>Git心路历程：  </p>
<ol>
<li><p>这是啥，我做了啥，怎么conflict了。</p>
</li>
<li><p>我会了，交给我，都可以。</p>
</li>
<li><p>学不会，怎么还有rebase·cherry-pick·reflog·bisect。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ul>
<li>clone, init, add, mv, reset, rm, bisect, log, status</li>
<li>branch, checkout, commit, diff, merge, rebase, tag</li>
<li>fetch, pull, push</li>
</ul>
<h2 id="项目历史管理"><a href="#项目历史管理" class="headerlink" title="项目历史管理"></a>项目历史管理</h2><ul>
<li><p>有向无环图，Git中用DAG表达历史记录，每个节点表示一个版本。</p>
</li>
<li><p>分支和标签也都是节点，同时它们指向它们各自对应的版本。而HEAD指针通常指向分支节点，但HEAD也可以直接指向版本节点。</p>
</li>
<li><p><code>git merge-base</code> 查询两个提交的分叉点</p>
</li>
<li><p>父引用</p>
<ul>
<li><code>^</code>后缀表示父对象，如<code>HEAD^</code>指向<code>HEAD</code>的父对象。</li>
<li>如果节点有多个父对象，则用数字区分，<code>HEAD^1 HEAD^2</code>。</li>
<li><code>~</code>后缀是父对象的链式表达。</li>
<li><code>HEAD~2</code>等于<code>HEAD^^</code>。</li>
</ul>
</li>
<li><p><code>git-name-rev - Find symbolic names for given revs</code>。</p>
<ul>
<li><code>git log | git name-rev --stdin</code></li>
<li>可打印出历史记录相对当前提交的关系。</li>
</ul>
</li>
<li><p>reflog</p>
</li>
<li><p>修订区间查询</p>
<ul>
<li><code>git log</code>显示一组提交</li>
<li>双点符号，表示两个修订之间的所有记录，<code>HEAD~2..HEAD</code>包括<code>HEAD HEAD^</code>。</li>
<li><code>^</code>前缀表示排除。<code>git log master maint ^next</code>显示master和maint分支的提交，同时排除在next中也存在的提交。</li>
</ul>
</li>
<li><p><code>git log</code>格式</p>
<ul>
<li><code>--pretty</code>用来调整输出格式</li>
<li><code>git log --graph --oneline</code>可以图形化输出记录，同时每个提交只有一行信息。</li>
</ul>
</li>
</ul>
<h2 id="使用Git进行程序开发"><a href="#使用Git进行程序开发" class="headerlink" title="使用Git进行程序开发"></a>使用Git进行程序开发</h2>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Version Control</tag>
      </tags>
  </entry>
  <entry>
    <title>Xv6内核学习笔记</title>
    <url>/2019/03/22/Xv6%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>深入理解操作系统，学习内核。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>从应用程序员的观念转换到系统程序员，软硬件高度耦合。</p>
<h2 id="Booting"><a href="#Booting" class="headerlink" title="Booting"></a>Booting</h2><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><h3 id="kinit1"><a href="#kinit1" class="headerlink" title="kinit1()"></a>kinit1()</h3><ul>
<li>phys page allocator</li>
<li>采取链表管理物理页，但实际上不需要使用物理地址，一切都用虚拟地址，在内核address space中，物理地址 = 虚拟地址 - KERNBASE。</li>
<li>从 “first address after kernel loaded from ELF file” 开始，对齐，然后分配最多到4MB位置的页。</li>
</ul>
<h3 id="kvmalloc"><a href="#kvmalloc" class="headerlink" title="kvmalloc()"></a>kvmalloc()</h3><ul>
<li>kernel page table</li>
<li>初始化page table，xv6使用tow-level Page Table ，巧妙之处在于先实现一些小函数（walk、mappage）。</li>
<li><strong>end使用0，非常精彩，因为是unsigned，0 - x等同于max - x + 1</strong></li>
<li>xv6中没有使用大页，比较简单。</li>
</ul>
<h3 id="mpinit-detect-other-processors"><a href="#mpinit-detect-other-processors" class="headerlink" title="mpinit();        // detect other processors"></a>mpinit();        // detect other processors</h3><h3 id="lapicinit-interrupt-controller"><a href="#lapicinit-interrupt-controller" class="headerlink" title="lapicinit();     // interrupt controller"></a>lapicinit();     // interrupt controller</h3><h3 id="seginit-segment-descriptors"><a href="#seginit-segment-descriptors" class="headerlink" title="seginit();       // segment descriptors"></a>seginit();       // segment descriptors</h3><h3 id="picinit-disable-pic"><a href="#picinit-disable-pic" class="headerlink" title="picinit();       // disable pic"></a>picinit();       // disable pic</h3><h3 id="ioapicinit-another-interrupt-controller"><a href="#ioapicinit-another-interrupt-controller" class="headerlink" title="ioapicinit();    // another interrupt controller"></a>ioapicinit();    // another interrupt controller</h3><h3 id="consoleinit-console-hardware"><a href="#consoleinit-console-hardware" class="headerlink" title="consoleinit();   // console hardware"></a>consoleinit();   // console hardware</h3><h3 id="uartinit-serial-port"><a href="#uartinit-serial-port" class="headerlink" title="uartinit();      // serial port"></a>uartinit();      // serial port</h3><h3 id="pinit-process-table"><a href="#pinit-process-table" class="headerlink" title="pinit();         // process table"></a>pinit();         // process table</h3><h3 id="tvinit-trap-vectors"><a href="#tvinit-trap-vectors" class="headerlink" title="tvinit();        // trap vectors"></a>tvinit();        // trap vectors</h3><h3 id="binit-buffer-cache"><a href="#binit-buffer-cache" class="headerlink" title="binit();         // buffer cache"></a>binit();         // buffer cache</h3><h3 id="fileinit-file-table"><a href="#fileinit-file-table" class="headerlink" title="fileinit();      // file table"></a>fileinit();      // file table</h3><h3 id="ideinit-disk"><a href="#ideinit-disk" class="headerlink" title="ideinit();       // disk"></a>ideinit();       // disk</h3><h3 id="startothers-start-other-processors"><a href="#startothers-start-other-processors" class="headerlink" title="startothers();   // start other processors"></a>startothers();   // start other processors</h3><h3 id="kinit2-P2V-410241024-P2V-PHYSTOP-must-come-after-startothers"><a href="#kinit2-P2V-410241024-P2V-PHYSTOP-must-come-after-startothers" class="headerlink" title="kinit2(P2V(410241024), P2V(PHYSTOP)); // must come after startothers()"></a>kinit2(P2V(4<em>1024</em>1024), P2V(PHYSTOP)); // must come after startothers()</h3><h3 id="userinit-first-user-process"><a href="#userinit-first-user-process" class="headerlink" title="userinit();      // first user process"></a>userinit();      // first user process</h3><h3 id="mpmain-finish-this-processor’s-setup"><a href="#mpmain-finish-this-processor’s-setup" class="headerlink" title="mpmain();        // finish this processor’s setup"></a>mpmain();        // finish this processor’s setup</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><ul>
<li>512 Bytes， 结尾两个字节0x55 0xAA。</li>
<li>BIOS加电后会读取引导扇区，确认有效性，然后转移控制权。</li>
</ul>
<h3 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h3><ul>
<li>段寄存器，有cs、ss等，每个段寄存器还跟着隐藏的描述符高速缓存器，每次对地址进行转换（其实就是段地址+偏移量），都是直接使用缓存里的值。</li>
<li>实模式下，cs里存段地址，没有保护位和界限。（从offset的位数来讲，段空间有一个上限）</li>
<li>保护模式下，cs里存段描述符的偏移量，比如0x8，gdt寄存器则存段描述符的起始地址，两者相加得到描述符地址。描述符里记录了段地址、界限和属性。</li>
<li>总的来说，描述符的结构非常复杂，知道保护模式的保护来源于此即可，并不是所有人都能修改描述符。</li>
</ul>
<h3 id="Interrupt-Descriptor-Table"><a href="#Interrupt-Descriptor-Table" class="headerlink" title="Interrupt Descriptor Table"></a>Interrupt Descriptor Table</h3><ul>
<li>IDTR指向IDT，在分页内存下为虚地址。</li>
<li>CPU会根据异常的编号获取不同的表项，表中存的依然是虚地址，指向handler入口。</li>
<li>（Xv6）handler并不处理异常，只是将参数入栈，统一跳转到alltraps，由traps函数处理。由于某些异常里，cpu保存的栈不相同（没有error code），所以需要多压栈一个0。</li>
</ul>
<h3 id="Exception、Interrupt、Traps"><a href="#Exception、Interrupt、Traps" class="headerlink" title="Exception、Interrupt、Traps"></a>Exception、Interrupt、Traps</h3><ul>
<li>能够预知的就是Exception，不能预知的是Interrupt。</li>
<li>Trap通常指用户态到内核态。</li>
</ul>
<h3 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h3><ul>
<li>分段针对的是物理地址，而且出现的原因是历史上，16位寄存器为了兼容20位地址线，从而使用了段寄存器。</li>
<li>到寄存器和地址线一样大之后，段寄存器的意义就不大了。在保护模式下增加了额外功能，即段描述符，可以增加一定的权限保护。</li>
<li>分页机制出现后，权限保护也可以由Page Table实现，从而分段变得毫无意义，现代操作系统中关闭分段。</li>
</ul>
<h3 id="CPL、DPL、RPL"><a href="#CPL、DPL、RPL" class="headerlink" title="CPL、DPL、RPL"></a>CPL、DPL、RPL</h3><ul>
<li><a href="https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86" target="_blank" rel="noopener">A answer on stackoverflow</a></li>
<li>CPL是cs寄存器的后两位。</li>
</ul>
<h3 id="INT和IRET"><a href="#INT和IRET" class="headerlink" title="INT和IRET"></a>INT和IRET</h3><ul>
<li>弄懂INT和IRET两个指令做的事情，就能知道异常是怎么处理的了，只是，INT指令的action和很多标志位相关，不能简单概括。</li>
<li>总的来说，这两条指令会负责保存和恢复CS:IP，状态位寄存器，调用IDT。</li>
<li>至于其他寄存器，则由软件自行处理，粗暴一点的可以直接pushal。</li>
</ul>
<h3 id="Trible-Interrupt"><a href="#Trible-Interrupt" class="headerlink" title="Trible Interrupt"></a>Trible Interrupt</h3><ul>
<li>Trible Interrupt被认为是error，OS正常运行中不会引发三次以上的Nested Interrupt。</li>
<li>从Xv6的代码中，其实看不出来Nested Interrupt有什么影响，Switch函数总是能将最新的context保存在proc结构中。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Advance</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>api管理工具yapi</title>
    <url>/2020/04/07/api%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7yapi/</url>
    <content><![CDATA[<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>在写js的时候，经常为某些结构量没有类型而感到痛苦，访问属性必须查阅另外的手册，在typescript出来以后，可以为某些常用的结构定义类型暗示，在使用时就有类型检查和自动补全了。</p>
<p>于是，前后端交互的接口，是不是也应该有某种工具，自动生成ts版本的接口呢？让js开发能够直接传入具有类型的参数，返回值也有对应的类型，restful的api会变得非常简单，js调用后端接口等同于调用生成出来的函数。而且，在生成函数这里，还可以实现切面编程，做一些mock、filter的工作。</p>
<p>最后，我找到了yapi、rap这样的工具，不过在考察的时候，意识到grpc也可能是不错的选择。</p>
<h2 id="Yapi"><a href="#Yapi" class="headerlink" title="Yapi"></a>Yapi</h2><p>首先，java开发后端时，使用<a href="https://github.com/diwand/YapiIdeaUploadPlugin" target="_blank" rel="noopener">idea插件</a>，可以将controller定义的接口，推送至yapi。插件还支持一些注解，提供mock、注释等功能。</p>
<p>前端可以用<a href="https://github.com/fjc0k/yapi-to-typescript" target="_blank" rel="noopener">yapi-to-ts</a>生成ts代码。</p>
<p>java插件用起来没什么大问题，推送很方便。</p>
<p>web插件有些许的问题，作者保留了一些接口，让用户来填写实现，比如最终生成的请求方式，是需要自己实现的。</p>
<p>我实现了一个用fetch请求后端的版本，同时还支持路径参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baseUrl = options.server === <span class="string">'mock'</span></span><br><span class="line">      ? payload.mockUrl</span><br><span class="line">      : options.server === <span class="string">'dev'</span></span><br><span class="line">        ? payload.devUrl</span><br><span class="line">        : payload.prodUrl</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求地址</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;payload.path&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (payload.paramNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 路径参数</span></span><br><span class="line">      <span class="keyword">const</span> pathParas: string[] = []</span><br><span class="line">      url = url.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\&#123;(\\w*)\\&#125;'</span>), (s, paraName) =&gt; &#123; pathParas.push(paraName); <span class="keyword">return</span> payload.data[paraName] &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// url paras</span></span><br><span class="line">      <span class="keyword">const</span> urlParas = payload.paramNames.filter(<span class="function">(<span class="params">value</span>) =&gt;</span> pathParas.includes(value))</span><br><span class="line">      url = url + <span class="string">'?'</span></span><br><span class="line">      urlParas.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        url = url + value + <span class="string">'='</span> + payload.data[value] + <span class="string">'&amp;'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> bodyParas: string[] = <span class="built_in">Object</span>.keys(payload.data).filter(<span class="function">(<span class="params">value: string</span>) =&gt;</span> !payload.paramNames.includes(value))</span><br><span class="line">    <span class="keyword">let</span> req</span><br><span class="line">    <span class="comment">// 具体请求逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (payload.requestBodyType === RequestBodyType.form) &#123;</span><br><span class="line">      <span class="keyword">const</span> formdata = <span class="keyword">new</span> FormData()</span><br><span class="line">      bodyParas.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        formdata.append(value, payload.data[value])</span><br><span class="line">      &#125;)</span><br><span class="line">      req = fetch(url, &#123; <span class="attr">method</span>: payload.method, <span class="attr">headers</span>: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;, <span class="attr">body</span>: formdata &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (payload.requestBodyType === RequestBodyType.json) &#123;</span><br><span class="line">      req = fetch(url, &#123; <span class="attr">method</span>: payload.method, <span class="attr">headers</span>: &#123; <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> &#125;, <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(payload.data, bodyParas) &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      req = fetch(url, &#123; <span class="attr">method</span>: payload.method &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (payload.responseBodyType === ResponseBodyType.json) &#123;</span><br><span class="line">        response.json().then(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(body)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          reject(res)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.text().then(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">          resolve(body <span class="keyword">as</span> any)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          reject(res)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      reject(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>生成函数的名字，要符合js的规范，所以也稍作调整，把一些非法字符去掉。</p>
<p>idea插件推送的类型名称和yapi默认名称不对应，导致前端插件无法正常识别，做一个预处理转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Config, ExtendedInterface, ChangeCase, Interface &#125; <span class="keyword">from</span> <span class="string">'yapi-to-typescript'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config: Config = [</span><br><span class="line">  &#123;</span><br><span class="line">    serverUrl: <span class="string">'http://'</span>,</span><br><span class="line">    typesOnly: <span class="literal">false</span>,</span><br><span class="line">    reactHooks: &#123;</span><br><span class="line">      enabled: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    prodEnvName: <span class="string">'production'</span>,</span><br><span class="line">    devEnvName: <span class="string">'dev'</span>,</span><br><span class="line">    outputFilePath: <span class="string">'src/api/index.ts'</span>,</span><br><span class="line">    requestFunctionFilePath: <span class="string">'src/api/request.ts'</span>,</span><br><span class="line">    dataKey: <span class="string">''</span>,</span><br><span class="line">    projects: [</span><br><span class="line">      &#123;</span><br><span class="line">        token: process.env.YTT_TOKEN <span class="keyword">as</span> string,</span><br><span class="line">        getRequestFunctionName: (interfaceInfo: ExtendedInterface, <span class="attr">changeCase</span>: ChangeCase): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> interfaceInfo.path.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[\\+\\/\\&#123;\\&#125;]"</span>,<span class="string">"g"</span>), <span class="string">''</span>) + interfaceInfo.method</span><br><span class="line">        &#125;,</span><br><span class="line">        preproccessInterface: <span class="function"><span class="params">interfaceInfo</span> =&gt;</span> &#123;</span><br><span class="line">          interfaceInfo.res_body = interfaceInfo.res_body.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'"(String|int|long|Interger)"'</span>, <span class="string">'g'</span>), (s, s1) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1 === <span class="string">'String'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'"string"'</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1 === <span class="string">'int'</span> || s1 === <span class="string">'long'</span> || s1 === <span class="string">'Interger'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">'"integer"'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">if</span> (interfaceInfo.req_body_other !== <span class="literal">undefined</span>)</span><br><span class="line">            interfaceInfo.req_body_other = interfaceInfo.req_body_other.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'"(String|int|long|Interger)"'</span>, <span class="string">'g'</span>), (s, s1) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (s1 === <span class="string">'String'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'"string"'</span></span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1 === <span class="string">'int'</span> || s1 === <span class="string">'long'</span> || s1 === <span class="string">'Interger'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'"integer"'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          <span class="keyword">return</span> interfaceInfo</span><br><span class="line">        &#125;,</span><br><span class="line">        categories: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">0</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> config</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>boost学习笔记</title>
    <url>/2019/11/20/boost%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学起来有一点费劲…</p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/boostorg/boost --depth=1 --recursive</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> boost</span><br><span class="line">./bootstrap.sh; ./b2 install</span><br></pre></td></tr></table></figure>

<h2 id="时间与日期"><a href="#时间与日期" class="headerlink" title="时间与日期"></a>时间与日期</h2><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><ul>
<li>就一个秒表</li>
</ul>
<h3 id="progress-timer"><a href="#progress-timer" class="headerlink" title="progress_timer"></a>progress_timer</h3><ul>
<li>析构的时候自动输出时间</li>
</ul>
<h3 id="progress-display"><a href="#progress-display" class="headerlink" title="progress_display"></a>progress_display</h3><ul>
<li>在控制台上显示程序执行进度</li>
</ul>
<h3 id="date-time"><a href="#date-time" class="headerlink" title="date_time"></a>date_time</h3><ul>
<li><p>三个基本概念</p>
<ul>
<li>时间点</li>
<li>时间段</li>
<li>时长</li>
</ul>
</li>
<li><p>date_time库的日期基于格里高利历，支持1400-01-01到9999-12-31之间的日期计算</p>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><ul>
<li>Resource Acquisition is Initialization</li>
</ul>
<h3 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h3><ul>
<li>只能在一个作用域里使用的指针</li>
<li>不能拷贝，不能转让</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul>
<li>相比scoped_ptr，支持移动赋值。</li>
</ul>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul>
<li>内部维护了引用计数，当计数为0时，释放资源</li>
<li>别名构造<ul>
<li>共享引用计数，指向不同的对象</li>
<li>可用来避免使用成员变量时，对象已被释放？</li>
</ul>
</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul>
<li>用来破除循环引用</li>
<li>weak不增加引用计数，在使用时才转换为shared_ptr</li>
</ul>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>自定义字面值</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Boost程序库完全开发指南 罗剑锋</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++14</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp中如何优雅终止多线程程序</title>
    <url>/2019/03/31/cpp%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%BB%88%E6%AD%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>原以为学了很多东西，停止一个多线程程序很容易，信号什么的一顿上，仔细思考发现并不简单。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>现在多线程应用非常常见，功能强大的同时也有很多新问题，为了便于描述，虚构一个具体场景。</li>
<li>假设有这样一个程序：<ul>
<li>一个main thread，三个worker thread。</li>
<li>main thread负责初始化配置，创建其他线程，并join等待。</li>
<li>worker thread中各自有自己的运行逻辑，以轮询的方式长期运行。</li>
</ul>
</li>
</ul>
<h2 id="终止信号"><a href="#终止信号" class="headerlink" title="终止信号"></a>终止信号</h2><ul>
<li>在main thread中，程序初始化时，注册signal handler，即可捕捉到SIGTERM。</li>
<li>但需要明确一点，信号处理函数中，只能调用可重入函数，自身修改其他状态时也要格外小心。</li>
</ul>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><ul>
<li>在signal handler中，flush进程所有状态，最后调用exit退出。</li>
<li>优点<ul>
<li>基本没什么优点，除了想法简单。</li>
</ul>
</li>
<li>缺点<ul>
<li>需要记住所有线程的工作逻辑，知道如何flush。</li>
<li>flush是否可重入？是否有race condition。这一点上无法预测，很多逻辑是调用的第三方库。</li>
</ul>
</li>
</ul>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><ul>
<li>signal handler调用pthread_cancel。</li>
<li>优点<ul>
<li>将exit过程交给目标线程处理。</li>
</ul>
</li>
<li>缺点<ul>
<li>引入了pthread库（这可能也不算缺点，但总的来说依赖越单一、越少，也意味着越简洁安全）</li>
<li>目标线程仍然只能使用pthread_cleanup_push来预置handler。</li>
<li>cancelpoint的设定较为复杂，它大量考虑了程序状态，但真正重要的是业务逻辑状态是否处于可以cancel的位置。</li>
</ul>
</li>
</ul>
<h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><ul>
<li>signal handler修改各个线程可见的状态量，比如一个全局数组。</li>
<li>优点<ul>
<li>exit过程由目标线程处理。</li>
<li>语义更强大，数组中的变量可以表示更多状态，不仅仅是cancel。</li>
<li>cancelpoint交给了线程自己处理，在可以退出的位置，判断状态量。</li>
</ul>
</li>
<li>缺点<ul>
<li>全局变量就是有害的（迫真。</li>
<li>可扩展性虽然有，但编码难度很高。如果要增加一种状态，比如暂停线程，那么所有工作线程的代码都需要改动，或者就得容忍，不是所有线程都支持所有状态。不支持所有状态是正常的，但全局数组的设计，让程序员难以控制这个缺陷，留下了容易犯错的可能性。</li>
</ul>
</li>
</ul>
<h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><ul>
<li>std::thread以某个对象的方法为主体，那么，让该对象提供run方法的同时，也提供一个cancel方法。内部两个函数的交互则任由线程自己实现，可以是对象私有变量，也可以是thread_local。run方法在固定的点去检查状态。</li>
<li>优点<ul>
<li>stop由目标线程处理。</li>
<li>支持多种状态，比如stop，restart等。</li>
<li>支持不同线程不同实现，某些线程可能不支持stop，这无所谓，直接从类的接口上就能看出。也可以用一个父类，强制子类都实现这些方法。这取决于业务逻辑和代码组织的需求。</li>
</ul>
</li>
<li>缺点<ul>
<li>main thread需要保留其他线程的对象。</li>
<li>状态变更函数都得是可重入函数（只写不读，或者直接取消多次进入即可，感觉问题也不大）。</li>
</ul>
</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>起初想了很多关于Exception的问题，在信号处理函数中写代码需要非常谨慎，怕引入并发错误。</li>
<li>最后的几个实现写起来，发现要么是我处理不掉的问题，要么就简单到不会出exception。</li>
<li>RAII可能还是更多用在资源安全上，线程状态维护是另一个问题了。</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Pthreads-Cancel-Coint"><a href="#Pthreads-Cancel-Coint" class="headerlink" title="Pthreads Cancel Coint"></a>Pthreads Cancel Coint</h3><p>pthreads标准指定了几个取消点，其中包括：</p>
<ul>
<li>通过pthread_testcancel调用以编程方式建立线程取消点。</li>
<li>线程等待pthread_cond_wait或pthread_cond_timewait()中的特定条件。</li>
<li>被sigwait(2)阻塞的函数。</li>
<li>一些标准的库调用。通常，这些调用包括线程可基于阻塞的函数。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>dell-iDrac及racadm实战</title>
    <url>/2019/05/09/dell-iDrac%E5%8F%8Aracadm%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>硬件确实牛逼，但我也要说，版本不同我真的很难受，连不上网我真的很难受。</p>
<a id="more"></a>

<h2 id="路由器VPN-L2tp"><a href="#路由器VPN-L2tp" class="headerlink" title="路由器VPN-L2tp"></a>路由器VPN-L2tp</h2><ul>
<li>路由器上设置VPN，用于连接内网，用一种叫做L2tp的协议。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set vpn l2tp remote-access ipsec-settings authentication mode pre-shared-secret</span><br><span class="line">set vpn l2tp remote-access ipsec-settings authentication pre-shared-secret &lt;secret&gt;</span><br><span class="line"></span><br><span class="line">set vpn l2tp remote-access authentication mode local</span><br><span class="line">set vpn l2tp remote-access authentication local-users username &lt;username&gt; password &lt;secret&gt;</span><br><span class="line"></span><br><span class="line">set vpn l2tp remote-access client-ip-pool start 10.10.100.10</span><br><span class="line">set vpn l2tp remote-access client-ip-pool stop 10.10.100.20</span><br><span class="line">set vpn l2tp remote-access dns-servers server-1 8.8.8.8</span><br><span class="line"></span><br><span class="line">set vpn ipsec ipsec-interfaces interface eth0</span><br><span class="line"></span><br><span class="line">commit; save</span><br></pre></td></tr></table></figure>

<h2 id="LCD屏设置iDRAC"><a href="#LCD屏设置iDRAC" class="headerlink" title="LCD屏设置iDRAC"></a>LCD屏设置iDRAC</h2><ul>
<li>通常给iDrac设置一个static ip就好了。</li>
<li>有些机型的正面，有一个lcd屏和三个按键，通过这个就可以直接setup了。</li>
</ul>
<h2 id="默认密码和保护密码"><a href="#默认密码和保护密码" class="headerlink" title="默认密码和保护密码"></a>默认密码和保护密码</h2><ul>
<li>iDrac的默认密码为calvin，用户为root。</li>
<li>第九代开始为保护密码，在机器的标签上，每一台都不一样，标签是抽出来的卡片。</li>
</ul>
<h2 id="RacAdm工具"><a href="#RacAdm工具" class="headerlink" title="RacAdm工具"></a>RacAdm工具</h2><ul>
<li>iDrac有一个web ui，通过https访问，也就是443端口。</li>
<li>我所用到的操作都可以在web上进行，目前还没有遇到不行的。</li>
<li>web上可以连接虚拟控制台，通过java jnlp连接。</li>
<li>22端口也有ssh服务，连接上去之后，就可以使用本地的racadm工具。</li>
<li>实际上也可以在linux系统上装racadm工具，省略掉ssh，但由于我是mac OS，所以我选择ssh上去之后本地运行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改网卡pxe配置</span></span><br><span class="line"></span><br><span class="line">racadm set nic.NICConfig.1.LegacyBootProto NONE</span><br><span class="line">racadm jobqueue create NIC.Integrated.1-1-1</span><br><span class="line">racadm set nic.NICConfig.3.LegacyBootProto PXE</span><br><span class="line">racadm jobqueue create NIC.Integrated.1-3-1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置单次pxe启动</span></span><br><span class="line"></span><br><span class="line">racadm config -g cfgServerInfo -o cfgServerBootOnce 1</span><br><span class="line">racadm config -g cfgServerInfo -o cfgServerFirstBootDevice PXE</span><br><span class="line">racadm serveraction powercycle</span><br></pre></td></tr></table></figure>

<ul>
<li>在iDrac中，对主板以外的硬件设置，如网卡、硬盘，都需要提交job，加入到jobqueue中，等待执行。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Dell</tag>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>efk-prometheus-grafana-springboot2</title>
    <url>/2018/09/02/efk-prometheus-grafana-springboot2/</url>
    <content><![CDATA[<p>用docker搭建日志监控系统efk，性能监控系统prometheus+grafana，同时将springboot2项目的信息发送到两个监控系统。<br>为了简便，文中未给出具体代码，详情请参见<a href="http://github.com/veiasai/efk-prometheus-grafana-springboot2" target="_blank" rel="noopener">github/veiasai/efk-pro-gra-boot</a>。</p>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol>
<li><p>efk是elasticsearch、fluentd、kibana的简写</p>
</li>
<li><p>elasticsearch 是一个分布式的 RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
</li>
<li><p>fluentd 是一个数据收集中心，便于格式化日志，集中处理。</p>
</li>
<li><p>kibana 用于可视化 elastcisearch 的数据。</p>
</li>
<li><p>prometheus 开源监控系统，主要特性有：时序数据库、拉取模式、查询语句灵活。</p>
</li>
<li><p>grafana 图形化工具，常用来可视化prometheus的数据，也可以用来看elasticsearch的数据。</p>
</li>
</ol>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><ol>
<li><p>使用5.6版本时，默认需求2g内存，由于所用机器只有2g，故无法满足，修改jvm.options挂载到config目录，发生错误，尚未解决。</p>
</li>
<li><p>使用2.0版本，启动成功。</p>
</li>
<li><p>重新尝试5.6版本，将挂载本机目录改为挂载卷，同时将jvm参数文件挂载进去，启动成功，git文件也已更新。</p>
</li>
</ol>
<h2 id="fluentd"><a href="#fluentd" class="headerlink" title="fluentd"></a>fluentd</h2><ol>
<li><p>使用镜像时需要自己再加工一下，安装 elasticsearch plugin。</p>
</li>
<li><p>通过挂载可以备份fluentd的log。</p>
</li>
</ol>
<h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><ol>
<li>直接使用docker启动没有什么问题，只是elastcisearch使用2.0版本的话，kibana也不能用最新版，使用4.0即可。（上述版本号都是docker hub提供的镜像所附带的tag，不确定是否与产品本身版本号对应）</li>
</ol>
<h2 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h2><ol>
<li><p>挂载主机目录出现权限不足，使用privileged参数也未能解决，改为挂载卷。</p>
</li>
<li><p>为了能监控和prometheus运行在同一机器上的程序，传递dockerhost参数到容器内。</p>
</li>
</ol>
<h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><ol>
<li><p>同样使用挂载卷解决权限问题。</p>
</li>
<li><p>启动后默认用户密码为admin/admin，添加prometheus为datasource，然后import dashboard。</p>
</li>
<li><p>我使用了别人编写的<a href="https://grafana.com/dashboards/4701" target="_blank" rel="noopener">jvm监控模板</a>，id为4701，在自己的grafana import dashboard处，直接填写id即可导入。</p>
</li>
<li><p>更多其他模板也可参考<a href="https://grafana.com/dashboards" target="_blank" rel="noopener">官网</a>。</p>
</li>
</ol>
<h2 id="spring-boot-2"><a href="#spring-boot-2" class="headerlink" title="spring boot 2"></a>spring boot 2</h2><ul>
<li>prometheus  <ol>
<li>引入依赖（参见git）</li>
<li>expose相关endpoint。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.exposure.include = *</span><br><span class="line">management.metrics.export.prometheus.enabled = true</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>logback<ol>
<li>引入依赖</li>
<li>resource目录下创建logback.xml</li>
<li>为了避免单元测试，单机运行等情况时，也发送日志，可以将日志配置文件重名为别名，然后在prod对应的profile中指定<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">logging.config=classpath:my-logback.xml</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://cloud.tencent.com/developer/ask/26534" target="_blank" rel="noopener">容器内访问主机</a></p>
</li>
<li><p><a href="https://blog.csdn.net/mawming/article/details/78344939" target="_blank" rel="noopener">efk介绍博文</a></p>
</li>
<li><p><a href="https://blog.csdn.net/yzlll/article/details/80313595" target="_blank" rel="noopener">Docker中EFK环境的搭建及使用</a></p>
</li>
<li><p><a href="https://github.com/prometheus/client_java/issues/299" target="_blank" rel="noopener">spring boot 2 prometheus client error</a></p>
</li>
<li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-metrics-export-prometheus" target="_blank" rel="noopener">spring boot 2 prometheus reference</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>Log</tag>
        <tag>Monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>fundamentals-of-option</title>
    <url>/2020/06/20/fundamentals-of-option/</url>
    <content><![CDATA[<h2 id="Mechanics-of-Options-Markets"><a href="#Mechanics-of-Options-Markets" class="headerlink" title="Mechanics of Options Markets"></a>Mechanics of Options Markets</h2><h3 id="European-and-American-Option"><a href="#European-and-American-Option" class="headerlink" title="European and American Option"></a>European and American Option</h3><ul>
<li>A European option may be exercised only at the expiration date of the option, i.e. at a single pre-defined point in time.</li>
<li>An American option on the other hand may be exercised at any time before the expiration date.</li>
</ul>
<h3 id="Types-of-Option"><a href="#Types-of-Option" class="headerlink" title="Types of Option"></a>Types of Option</h3><ul>
<li>An option gives the holder of the option the right to do something. But it’s not forced.</li>
<li>Call: the right to buy something(underlying 标的, including stock/future/foreign currency)</li>
<li>Put: the right to sell.</li>
<li>Premium: the cost to buy an option.</li>
<li>expiration date, maturity date. Time limit to execution. The execution of an option is ‘exercise an option’.</li>
<li>exercise/strike price. The holder could buy/sell something at exercise/strike price.</li>
<li>It’s obvious that At expiration date:<ul>
<li>underlying price &gt; strike price, call option profits.</li>
<li>underlying price &lt; strike price, put option profits.</li>
</ul>
</li>
<li>Under an opposite situation, the holder doesn’t exercise the option. So the loss is Premium rather than the difference between the two prices.</li>
<li>Position: the number of options that a guy maintains.<ul>
<li>Long Position: increase the position</li>
<li>Short Position: decrease the position</li>
<li>Also represent (buy/purchase)-(sell/write) a option.</li>
</ul>
</li>
</ul>
<h3 id="Margin-Requirements"><a href="#Margin-Requirements" class="headerlink" title="Margin Requirements"></a>Margin Requirements</h3><p>The price of option is usually low, but the price of underlying may be high and fluctuate significantly. To ensure the investor could burden the fluctuation, investor must prepare extra money in his account, which is called margin. And the margin requirement is related to the position. More options you maintain, more margin you should have.</p>
<p>Equity style</p>
<ul>
<li>taker: no margin requirement</li>
<li>writer: about (underlying price * 10%)</li>
</ul>
<h3 id="Price"><a href="#Price" class="headerlink" title="Price"></a>Price</h3><ul>
<li>in the money = 价内 = 实值 = call strike price &lt; underlying price = put strike price &gt; underlying price = profit</li>
<li>at the money = 价中 = 平值 = strike price == underlying price</li>
<li>out of the money = 价外 = 虚值 = call strike price &gt; underlying price = put strike price &lt;&gt; underlying price = loss</li>
</ul>
<h3 id="Pricing"><a href="#Pricing" class="headerlink" title="Pricing"></a>Pricing</h3><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><table>
<thead>
<tr>
<th>syntax</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>$S_0$</td>
<td>Current stock price</td>
</tr>
<tr>
<td>$K$</td>
<td>Strike price of option</td>
</tr>
<tr>
<td>$T$</td>
<td>Time to expiration of option</td>
</tr>
<tr>
<td>$S_T$</td>
<td>Stock price on the expiration date</td>
</tr>
<tr>
<td>$\sigma$</td>
<td>Volatility of the stock price</td>
</tr>
<tr>
<td>$r$</td>
<td>Continuously compounded risk-free rate of interest for an investment maturing in time T</td>
</tr>
<tr>
<td>$C$</td>
<td>Value of American call option to buy one share</td>
</tr>
<tr>
<td>$P$</td>
<td>Value of American put option to sell one share</td>
</tr>
<tr>
<td>$c$</td>
<td>Value of European call option to buy one share</td>
</tr>
<tr>
<td>$p$</td>
<td>Value of European put option to sell one share.</td>
</tr>
</tbody></table>
<p>The effects.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>C</th>
<th>P</th>
<th>c</th>
<th>p</th>
</tr>
</thead>
<tbody><tr>
<td>$S_0$</td>
<td>+</td>
<td>-</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>$K$</td>
<td>-</td>
<td>+</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td>$T$</td>
<td>+</td>
<td>+</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>$\sigma$</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>$r$</td>
<td>+</td>
<td>-</td>
<td>+</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="Continuously-Compounded-Interest"><a href="#Continuously-Compounded-Interest" class="headerlink" title="Continuously Compounded Interest"></a>Continuously Compounded Interest</h4><p>$$\lim_{n \to +\infty} (1 + \frac{r}{n})^n = e^{r}$$</p>
<h4 id="Bounds"><a href="#Bounds" class="headerlink" title="Bounds"></a>Bounds</h4><ul>
<li>$c \leq S_0 \quad and \quad C \leq S_0$<ul>
<li>long a stock and short a option results in risk-free profit.</li>
</ul>
</li>
<li>$c \geq S_0-Ke^{-rT}$ | short a stock and long a option.<ul>
<li>Then hold cash and get interest. if stock price increases, call option will profit. Otherwise, don’t exercise the option and buy a stock in market.</li>
</ul>
</li>
<li>$p \geq max(Ke^{-rT}-S_0, 0)$<ul>
<li>negative put makes no sense.</li>
</ul>
</li>
<li>$S_0-K \leq C-P \leq S_0-Ke^{-rT}$</li>
</ul>
<h4 id="Call-Put-Parity"><a href="#Call-Put-Parity" class="headerlink" title="Call-Put Parity"></a>Call-Put Parity</h4><ul>
<li>Portfolio A: one European call option plus a zero-coupon bond that provides a payoff of K at time T.</li>
<li>Portfolio C : one European put option plus one share of the stock.</li>
<li>At expiry time T, A is equal to C.<ul>
<li>$S_T&gt;K$:<ul>
<li>A: $S_T-K+K=S_T$</li>
<li>C: $0+S_T=S_T$</li>
</ul>
</li>
<li>$S_T&lt;K$:<ul>
<li>A: $0+K=K$</li>
<li>C: $K-S_T+S_T=K$</li>
</ul>
</li>
</ul>
</li>
<li>So the current cost should be equal.</li>
<li>$c+Ke^{-rT}=S_0+p$</li>
</ul>
<h3 id="Trading-Strategies-Involving-Options"><a href="#Trading-Strategies-Involving-Options" class="headerlink" title="Trading Strategies Involving Options"></a>Trading Strategies Involving Options</h3><h4 id="Principal-Protected"><a href="#Principal-Protected" class="headerlink" title="Principal-Protected"></a>Principal-Protected</h4><p>One option + One Underlying.</p>
<h4 id="Spread"><a href="#Spread" class="headerlink" title="Spread"></a>Spread</h4><p>A spread trading strategy involves taking a position in two or more options of the same<br>type.</p>
<h5 id="Bull-Spread"><a href="#Bull-Spread" class="headerlink" title="Bull Spread"></a>Bull Spread</h5><p>buying a European call option on a stock with $K_1$ and selling a European call option with a $K_2$. The original cost is $C_d$. It should be negative because out of money option has lower price.</p>
<ul>
<li>$K_1&lt;K_2$<ul>
<li>$S_0&lt;K_1 =&gt; -C_d$</li>
<li>$K_1&lt;S_0&lt;K_2 =&gt; S_0 - K_1 - C_d$</li>
<li>$S_0&gt;K_2 =&gt; K_2 - K_1 - C_d$</li>
</ul>
</li>
</ul>
<p>Three types of bull spread can be distinguished:</p>
<ol>
<li>Both calls are initially out of the money.</li>
<li>One call is initially in the money; the other call is initially out of the money.</li>
<li>Both calls are initially in the money</li>
</ol>
<h5 id="Bear-Spread"><a href="#Bear-Spread" class="headerlink" title="Bear Spread"></a>Bear Spread</h5><p>buying a European put with $K_2$ and selling a European put with $K_1$. And The original cost is $P_d$.</p>
<ul>
<li>$K_1&lt;K_2$<ul>
<li>$S_0&lt;K_1 =&gt; K_2 - K_1 - P_d$</li>
<li>$K_1&lt;S_0&lt;K_2 =&gt; K_2 - S_0 - P_d$</li>
<li>$S_0&gt;K_2 =&gt; -P_d$</li>
</ul>
</li>
</ul>
<h5 id="Box-Spread"><a href="#Box-Spread" class="headerlink" title="Box Spread"></a>Box Spread</h5><p>a bull call spread with strike prices K1 and K2 and a bear put spread with the same two strike prices.</p>
<ul>
<li>$K_1&lt;K_2$<ul>
<li>$S_0&lt;K_1 =&gt; K_2 - K_1 - P_d - C_d$</li>
<li>$K_1&lt;S_0&lt;K_2 =&gt;  K_2 - K_1 - P_d - C_d$</li>
<li>$S_0&gt;K_2 =&gt;  K_2 - K_1 - P_d - C_d$</li>
</ul>
</li>
</ul>
<h5 id="Butterfly-Spread"><a href="#Butterfly-Spread" class="headerlink" title="Butterfly Spread"></a>Butterfly Spread</h5><p>involves positions in options with three different strike prices.</p>
<h5 id="Calendar-Spreads"><a href="#Calendar-Spreads" class="headerlink" title="Calendar Spreads"></a>Calendar Spreads</h5><p>have the same strike price and different expiration dates.</p>
<h5 id="Diagonal-Spreads"><a href="#Diagonal-Spreads" class="headerlink" title="Diagonal Spreads"></a>Diagonal Spreads</h5><p>both the expiration date and the strike price of the calls are different.</p>
<h4 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h4><h3 id="Binomial-Tree"><a href="#Binomial-Tree" class="headerlink" title="Binomial Tree"></a>Binomial Tree</h3><h4 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h4><p>Follow a straightforward formula(or assumption):</p>
<p>$S_u<em>p+S_d</em>(1-p)=S_0*e^{rT}$</p>
<p>Left is the expected value of stock price.</p>
<p>Right is risk-free profit.</p>
<p>They should be equal, if not, there is an arbitrage chance.</p>
<p>Some equivalent formats:</p>
<ul>
<li>$u<em>S_0<em>p+d</em>S_0</em>(1-p)=S_0*e^{rT}$</li>
<li>$u<em>p+d-d</em>p=e^rT$</li>
<li>$p = \frac{e^{rT}-d}{u-d}$</li>
</ul>
<h4 id="Delta"><a href="#Delta" class="headerlink" title="Delta"></a>Delta</h4><p>The delta ($\Delta$) of a stock option is the ratio of the change in the price of the stock<br>option to the change in the price of the underlying stock.</p>
<h4 id="Determining-u-and-d"><a href="#Determining-u-and-d" class="headerlink" title="Determining u and d"></a>Determining u and d</h4><ul>
<li>$u = e^{\sigma\sqrt{T}}$</li>
<li>$d = \frac{1}{u}$</li>
<li>$\sigma$ is the volatility.</li>
</ul>
<h3 id="Black-Scholes-Merton-Model"><a href="#Black-Scholes-Merton-Model" class="headerlink" title="Black-Scholes-Merton Model"></a>Black-Scholes-Merton Model</h3><h4 id="Assumptions-about-How-stock-price-evolves"><a href="#Assumptions-about-How-stock-price-evolves" class="headerlink" title="Assumptions about How stock price evolves"></a>Assumptions about How stock price evolves</h4><ul>
<li>$\mu$ : Expected Return on Stock</li>
<li>$\sigma$ : Volatility of the stock price</li>
<li>$\frac{\Delta S}{S}\sim\phi(\mu\Delta t, \sigma^2\Delta t)$ (normal distribution)</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Fundamentals_of_Options_and_Futures_Markets（8th_Edition）John Hull</p>
]]></content>
      <categories>
        <category>Finance</category>
      </categories>
      <tags>
        <tag>option</tag>
      </tags>
  </entry>
  <entry>
    <title>helm实战-安装istio、kafka、zookeepr</title>
    <url>/2019/04/18/helm%E5%AE%9E%E6%88%98-%E5%AE%89%E8%A3%85istio%E3%80%81kafka%E3%80%81zookeepr/</url>
    <content><![CDATA[<p>内网环境中安装helm，手动加载charts，当做一个目录布局合理，部署文件清晰的仓库使用。</p>
<a id="more"></a>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>helm是一个k8s的包管理工具，据我感觉，是因为一个复杂的应用，定义的资源会有数十条，类型也会有service、role、deployment、statefulset等等很多种，所以需要一个合理的组织形式，也就是charts，helm的仓库则负责分发charts。</li>
<li>通过使用别人编写好的charts，能够很快的部署大型应用，比如istio、kafka。但问题是，helm repo只有部署文件，并不打包镜像，而部署时经常会pull不到镜像，或者即使reachable，速度也不够快。</li>
</ul>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul>
<li>下载binary helm，放到path里。</li>
<li><code>helm init --client-only --skip-refresh</code>，将会只创建目录在客户端，不生成tiller，也不拉取默认repo。</li>
<li><code>helm repo add name repourl</code>，可以添加一个repo，如果有现成的使用的话。</li>
<li>在github/charts，下载helm的stable和incutator charts，并不大，不压缩也只有5MB。</li>
<li>如果总是template一个charts，然后直接使用部署文件，不装tiller也可以。</li>
<li>tiller的安装，找一个版本和client对应的镜像。</li>
<li><code>helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.5.1 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</code></li>
</ul>
<h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><h3 id="Istio-deploy"><a href="#Istio-deploy" class="headerlink" title="Istio-deploy"></a>Istio-deploy</h3><ul>
<li>使用github/istio的charts，比helm自带的要好一些。</li>
<li>git clone之后一定要切换到release版本。</li>
<li>使用<code>helm template install/kubernetes/helm/ &gt; istio.yaml</code>，获得一个很长的部署文件，确保其中所有的镜像都能够下载到。</li>
<li>原因是某些镜像没有预留修改部分在<code>values.yaml</code>。</li>
<li>鉴于istio不怎么需要更新，不用charts组织问题也不是很大，修改网络结构全靠新增一些配置。</li>
</ul>
<h3 id="Istio-gateway"><a href="#Istio-gateway" class="headerlink" title="Istio-gateway"></a>Istio-gateway</h3><ul>
<li>istio声明了很多自定类型资源，我们通过<code>Gateway</code>来配置入口。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-gateway</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">istio:</span> <span class="string">ingressgateway</span> <span class="comment"># use istio default controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">81</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"xxx.xxx.cn"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"yyy.cn"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>port则是和ingressgateway配置有关，用nodeport暴露ingress的一些端口，然后在Gateway中bind使用。</li>
<li>由于没有备案域名，所以使用了非80端口。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">prom-vts</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"xxx.cn"</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">service-gateway</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">prom-prometheus-server.prom.svc.cluster.local</span></span><br><span class="line">        <span class="attr">port:</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>VirtualService用来关联gateway和service。</li>
</ul>
<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>statefulset需要使用到pvc和pv两个资源，也就是说，存储的support额外定义，statefulset只管使用。比较简单的可用的一种provider是nfs。更可靠和广泛使用的是ceph。</p>
<h3 id="NFS-Provider"><a href="#NFS-Provider" class="headerlink" title="NFS Provider"></a>NFS Provider</h3><ul>
<li>通过helm安装nfs-client-provider，修改镜像和填写nfs server。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nfs:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">34d7b49ed9-sva88.cn-shanghai.nas.aliyuncs.com</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/nfs/kubernetes</span></span><br><span class="line">  <span class="attr">mountOptions:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">storageClass:</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Set a provisioner name. If unset, a name will be generated.</span></span><br><span class="line">  <span class="comment"># provisionerName:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Set StorageClass as the default StorageClass</span></span><br><span class="line">  <span class="comment"># Ignored if storageClass.create is false</span></span><br><span class="line">  <span class="attr">defaultClass:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果将storageClass设为defaultClass，则其他pod在使用时，可以不定义storageClassName。</li>
</ul>
<h3 id="Clear-PVC"><a href="#Clear-PVC" class="headerlink" title="Clear PVC"></a>Clear PVC</h3><ul>
<li>通过自动创建PV去匹配PVC的时候，PV的delete policy为delete，也就是PVC被删除，PV就被删除。</li>
<li><code>helm delete chart</code> 或者 <code>kubectl delete -f install.yaml</code>，都不会删除pvc。</li>
<li>清理错误或者不需要的pvc，要手动清理。<code>kubectl delete pvc name</code></li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka-External-Listenr"><a href="#Kafka-External-Listenr" class="headerlink" title="Kafka External Listenr"></a>Kafka External Listenr</h3><ul>
<li>不论用什么方式，访问到kafka，nat也好、域名转换也好，kafka会broadcast所有node的地址，而这个地址取决于配置中的<code>internal-listener external-listener</code>。</li>
<li>helm kafka chart的values.yaml有预留配置，通过开启external广播和nodeport方式暴露外部访问，就可以从集群外部访问kafka了。</li>
</ul>
<h3 id="Kafka-Stroage"><a href="#Kafka-Stroage" class="headerlink" title="Kafka-Stroage"></a>Kafka-Stroage</h3><ul>
<li>如果在chart中开启persistence，并指定storageClass，则可以自动生成pvc和pv，并挂载好外部存储。但感觉这种方式，导致多个kafka节点，都将自己的存储挂载到了同一个provider，对性能并不友好。</li>
<li>因为也没有太多的存储可用，暂时没有改这里。</li>
<li>或许不用class，生成几个local pv，然后配置节点亲和性就好了。</li>
</ul>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ul>
<li>和kafka在同一个namespace的话，就直接用service name访问了。</li>
<li>storage方案和kafka类似。</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>重启pod。<code>kubectl scale deployment chat --replicas=0 -n service</code></li>
<li>service的完整域名为，<code>&lt;service_name&gt;.&lt;namespace&gt;.svc.&lt;domain&gt;</code>，默认<code>domain</code>为<code>cluster.local</code>，headless的service，可以直接通过域名解析到pod ip，而不用先跳到service vip。</li>
<li>同一个namespace下，则可以直接用servicename去访问。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Helm</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-prometheus-operator</title>
    <url>/2019/04/19/k8s-prometheus-operator/</url>
    <content><![CDATA[<p>kubernetes部署prometheus。</p>
<a id="more"></a>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ul>
<li>目前还比较迷惑config-reload是如何实现的，可以动态读取集群中需要监听的job。</li>
</ul>
<h2 id="Prometheus-Server"><a href="#Prometheus-Server" class="headerlink" title="Prometheus Server"></a>Prometheus Server</h2><ul>
<li>没什么要改的。</li>
</ul>
<h2 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h2><ul>
<li>格外注意版本，0.16.0以后，查询函数有很大变化，会导致dashboard查询失败。</li>
</ul>
<h2 id="Alert-Manager"><a href="#Alert-Manager" class="headerlink" title="Alert Manager"></a>Alert Manager</h2><ul>
<li>接收和记录报警信息，同时可以传递给Receiver，比如Email、Wechat。</li>
<li>我的机器不能上网，所以配置企业微信报警失败了。</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li><p><a href="https://stackoverflow.com/questions/48374858/how-to-config-alertmanager-which-installed-by-helm-on-kubernetes" target="_blank" rel="noopener">helm部署prometheus时如何增加alert rule</a></p>
</li>
<li><p><a href="https://github.com/helm/charts/issues/9161" target="_blank" rel="noopener">[stable/prometheus-operator] customresourcedefinitions not cleaned on delete</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Helm</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s从构建到发布</title>
    <url>/2018/12/25/k8s%E4%BB%8E%E6%9E%84%E5%BB%BA%E5%88%B0%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>将曾经的一个Web应用，React+Nginx，Java+Tomcat，Mysql，MongoDB，部署到k8s上，包括CICD、LB、scaling，并且进行监控和测试。</p>
<a id="more"></a>

<h2 id="rke"><a href="#rke" class="headerlink" title="rke"></a>rke</h2><ul>
<li>部署k8s，非常轻便简单，另一篇博文有详细介绍。</li>
</ul>
<h2 id="drone"><a href="#drone" class="headerlink" title="drone"></a>drone</h2><ul>
<li><p>drone是一个基于容器的ci/cd平台。</p>
</li>
<li><p>1.0.0版本push没有反应，感觉有残留bug。</p>
</li>
<li><p>0.8.5版本正常运行，但界面太丑，描述文件也很冗余。</p>
<hr>
</li>
<li><p>像maven这种，有一个本地仓库的依赖管理工具，由于drone是容器方式运行，并不会持久化本地仓库，导致每次maven都需要全量下载依赖包，速度会非常慢，可以通过挂载的方式持久化，将本地仓库挂载到宿主机硬盘上。挂载需要trust该仓库，这需要drone admin账户权限，需要在启动drone的参数中设定。<br>  <code>- DRONE_ADMIN=Yourname</code></p>
</li>
<li><p>docker/plugin就很蠢了，它是docker in docker，问题同上，每次都会重新下载基础镜像，有时候基础镜像很大，ubuntu就接近2G，速度就非常慢，而且还不能通过挂载去持久化这部分，安全和轻便之间有个取舍，希望以后解决办法吧。</p>
</li>
</ul>
<h2 id="React-Nginx"><a href="#React-Nginx" class="headerlink" title="React+Nginx"></a>React+Nginx</h2><ul>
<li>使用node镜像build项目。</li>
<li>使用nginx镜像，将build文件放到nginx默认目录下，修改nginx.conf，完成镜像打包并推送到dockerhub。</li>
</ul>
<h2 id="Java-Tomcat"><a href="#Java-Tomcat" class="headerlink" title="Java+Tomcat"></a>Java+Tomcat</h2><ul>
<li>使用maven镜像build项目。</li>
<li>使用Tomcat镜像，将war文件放到Tomcat webapp下。</li>
</ul>
<h2 id="Mysql、Mongo"><a href="#Mysql、Mongo" class="headerlink" title="Mysql、Mongo"></a>Mysql、Mongo</h2><ul>
<li>使用replica-controller + service就可以启动单实例数据库了。</li>
<li>Spring Data Jpa只能自动建表，不能建库，需要自己先去mysql中建一个数据库。这个我认为也不太好通过修改镜像的方式去直接达成，因为数据库一般也会持久化的，数据部分是挂载的，外部容易覆盖内部，需要小心对待。</li>
</ul>
<h2 id="Prometheus、Grafana"><a href="#Prometheus、Grafana" class="headerlink" title="Prometheus、Grafana"></a>Prometheus、Grafana</h2><ul>
<li>使用别人写好的部署文件，即可部署node-exporter监控。</li>
<li>一个比较好用的grafana k8s监控模板编号为351。</li>
</ul>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><ul>
<li>Ingress-controller的部署有些复杂，官网上有例子（所谓复杂其实也就是镜像源需要处理一下）。</li>
<li>部署后，写新的ingress规则，将域名转发至服务。没有真域名的时候，随意杜撰，然后在client端修改hosts文件即可。</li>
</ul>
<h2 id="AutoScaling"><a href="#AutoScaling" class="headerlink" title="AutoScaling"></a>AutoScaling</h2><ul>
<li>k8s 1.11以后推荐使用metrics-server作为集群中资源信息获取方式，只要将git上的部署文件中镜像替换为阿里云即可，同时还需要增加权限，比较粗暴的就是直接赋给admin权限。<br><code>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --serviceaccount=kube-system:metrics-server</code></li>
<li>有了metrics-server，hpa就可以读取pod资源使用率，从而调度replica数量。</li>
<li>Deployment中可以设置resource的limit，这里的cpu limit是以core数量为标准的，比如1就是指使用1个核。</li>
<li>hpa中的默认资源临界值是80%，这个比例是相对于limit而言的，假如limit为1，也就是说当cpu占用率为0.8core时就会发生调度。</li>
<li>实测发现如果<code>min=1, max=4</code>，scale会直接从1个pod变成4个，看起来是少了某种限制，比如我可能期望scale是逐个增长的。两次scale之间是有冷却的，从1到4之后，即使压力很快减小，也不会马上降为1个pod。</li>
<li>如果要使用其他资源作为指标，需要自定义，这部分我还未尝试。</li>
</ul>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>rancher</tag>
        <tag>kubernetes</tag>
        <tag>drone</tag>
        <tag>helm</tag>
        <tag>prometheus</tag>
        <tag>grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka2.0集群搭建与高压测试</title>
    <url>/2018/10/28/kafka2-0%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%AB%98%E5%8E%8B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>借助实验室的机器资源和项目需求，参与搭建kafka集群和测试特性。</p>
<a id="more"></a>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="机器资源"><a href="#机器资源" class="headerlink" title="机器资源"></a>机器资源</h3><ul>
<li>系统<ol>
<li>CentOS</li>
</ol>
</li>
<li>网络<ol>
<li>有内部DNS服务或者修改hosts文件保证集群机器通过hostname相连。</li>
<li>修改防火墙，暴露相关端口。（2181，9092等）</li>
</ol>
</li>
<li>磁盘<ol>
<li>因为linux的磁盘是通过挂载点加入整个文件系统的，不能想当然认为某个目录下就具有足够大的磁盘空间，需要确认好文件存放目录，保证空间足够。</li>
</ol>
</li>
</ul>
<h3 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h3><ul>
<li>JDK 1.8</li>
<li>Zookeeper 3.4.x</li>
<li>kafka 2.0.0</li>
</ul>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>Zookeeper不同节点的配置文件没有区别，这使得启动较为容易，先copy一份配置到本地，修改后scp到集群机器上。</li>
<li>kafka的配置文件中需要指明id，这里我同样copy一份配置，上传配置，然后通过sed修改broker_id。</li>
<li>在远程写shell脚本调用时，经常需要考虑加\，比如\$，根据语义不同：本机解析和远程解析。</li>
<li>shell的缩进没什么意义，但可读性好，只是cat &gt;&gt; eof …… eof的写法，会把空格制表都算上。</li>
<li>一些命令会有交互过程，差不多就是-y -i -f等就可以去掉交互。</li>
</ul>
<h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><h3 id="kafka常用配置"><a href="#kafka常用配置" class="headerlink" title="kafka常用配置"></a>kafka常用配置</h3><ul>
<li>broker<ul>
<li>内存分配默认只有1g，最好增大至6g，缓冲buffer不宜过大，不然会出现阻塞，程序假死。</li>
</ul>
</li>
<li>topic<ul>
<li>partition才具有master/slave，所以分区不能太少，应该和节点数相当或者稍多。</li>
<li>replicafactor，备份数量，一般为3。</li>
</ul>
</li>
<li>producer<ul>
<li>acks：决定broker返回的时间点，0: 一接收就返回 1: 一个broker持久化返回 2: 所有副本持久化返回</li>
</ul>
</li>
<li>consumer<ul>
<li>consumer具有client-id和group-id，以此来区分它的offset。</li>
</ul>
</li>
</ul>
<h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul>
<li>tsung</li>
<li>jmeter<ul>
<li>优势在是java编写的，开发插件相对容易。（有个pepperbox可以发起kafka请求)</li>
<li><a href="https://github.com/BrightTag/kafkameter" target="_blank" rel="noopener">BrightTag/kafkameter</a></li>
<li><a href="https://github.com/GSLabDev/pepper-box" target="_blank" rel="noopener">GSLabDev/pepper-box</a></li>
</ul>
</li>
</ul>
<h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ul>
<li>prometheus</li>
</ul>
<h3 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h3><ul>
<li>cruise-control<ul>
<li>支持2.0.0版本，但没有图形化</li>
</ul>
</li>
<li>kafka-manager<ul>
<li>有图形化，但没有跟上最新版本，虽然勉强也能用，但可能有未知bug。</li>
</ul>
</li>
</ul>
<h2 id="多数据中心"><a href="#多数据中心" class="headerlink" title="多数据中心"></a>多数据中心</h2><p>多数据中心对于大公司而言也是必然场景，此时就存在多集群的备份，同步等问题，非常麻烦。</p>
<ul>
<li>uReplicator：Uber开发的一个mirrormaker的增强版，用于跨集群拷贝数据。</li>
<li>confluent replicator connector： Confluent开发的一种connector，也用于跨集群拷贝。</li>
</ul>
<h2 id="工作内容"><a href="#工作内容" class="headerlink" title="工作内容"></a>工作内容</h2><ul>
<li>熟悉kakfa概念、设计原理，掌握常用命令。</li>
<li>调整机器参数，测试kafka性能和高可用特性。</li>
<li>兼容模块，引入trace。</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Test</tag>
        <tag>Zookeeper</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>kolla配置进阶和docker存储目录修改</title>
    <url>/2019/05/11/kolla%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6%E5%92%8Cdocker%E5%AD%98%E5%82%A8%E7%9B%AE%E5%BD%95%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>深入了解kolla实现，以及更改docker的一些配置。</p>
<a id="more"></a>

<h2 id="Kolla"><a href="#Kolla" class="headerlink" title="Kolla"></a>Kolla</h2><ul>
<li>Kolla的配置文件都存放在<code>/etc/kolla/</code>，当容器启动时，会读取这里的配置。</li>
<li>Kolla-ansible则提供了类似模板的办法去修改配置文件，并分发到各个node上。</li>
</ul>
<blockquote>
<p>An operator can change the location where custom config files are read from by editing /etc/kolla/globals.yml and adding the following line.<br>The directory to merge custom config files the kolla’s config files<br>node_custom_config: “/etc/kolla/config”<br>Kolla allows the operator to override configuration of services. Kolla will look for a file in /etc/kolla/config/&lt;&lt; service name &gt;&gt;/&lt;&lt; config file &gt;&gt;. This can be done per-project, per-service or per-service-on-specified-host.<br>If the operator wants to configure compute node cpu and ram allocation ratio on host myhost, the operator needs to create file /etc/kolla/config/nova/myhost/nova.conf with content:<br>Kolla allows the operator to override configuration globally for all services. It will look for a file called /etc/kolla/config/global.conf.<br>For example to modify database pool size connection for all services, the operator needs to create /etc/kolla/config/global.conf with content:</p>
</blockquote>
<h3 id="Overcommitting"><a href="#Overcommitting" class="headerlink" title="Overcommitting"></a>Overcommitting</h3><ul>
<li><p>尝试修改Openstack overcommitting参数，实际上默认值已经超卖了资源，cpu 16:1，memory 1.5:1。</p>
</li>
<li><p>nova-scheduler.conf</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">cpu_allocation_ratio &#x3D; 2.0</span><br><span class="line">enabled_filters &#x3D; AggregateInstanceExtraSpecsFilter, RetryFilter, AvailabilityZoneFilter, RamFilter, DiskFilter, ComputeFilter, ComputeCapabilitiesFilter, ImagePropertiesFilter, ServerGroupAntiAffinityFilter, ServerGroupAffinityFilter, CoreFilter</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li><p>kolla的持久化文件，都在docker根目录下的<code>volumes</code>，很容易就能看懂。</p>
</li>
<li><p>虚拟机就是<code>volumes/nova_compute/_data/instances</code>。</p>
</li>
<li><p>因此，docker根目录的磁盘空间要足够，最好的办法是直接mount一块区域给<code>/var/lib/docker</code>。</p>
</li>
<li><p>但我们已经分配好了所有的磁盘，并且都是xfs，调整并不方便。</p>
</li>
<li><p>先停止docker daemon，将根目录迁移，然后创建一个soft link，完成偷梁换柱。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /var/lib/docker /home/lib/docker</span><br><span class="line">link -s /home/lib/docker /var/lib/docker</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://stackoverflow.com/questions/36014554/how-to-change-the-default-location-for-docker-create-volume-command" target="_blank" rel="noopener">how-to-change-the-default-location-for-docker-create-volume-command</a></li>
<li><a href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/10/05/2199534.html" target="_blank" rel="noopener">linux下创建和删除软、硬链接</a></li>
<li><a href="https://docs.openstack.org/kolla-ansible/latest/admin/advanced-configuration.html" target="_blank" rel="noopener">Kolla-ansible advanced config</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>kubecon-2018</title>
    <url>/2018/11/17/kubecon-2018/</url>
    <content><![CDATA[<p>参加2018 kubecon 的收获。</p>
<a id="more"></a>

<h2 id="Helm3"><a href="#Helm3" class="headerlink" title="Helm3"></a>Helm3</h2><ul>
<li>增加了四个主要特性<ul>
<li>embedded Lua engine</li>
<li>Removal of Tiller</li>
<li>chart repository auth</li>
<li>New chart yaml</li>
</ul>
</li>
</ul>
<h2 id="Fluent-bit"><a href="#Fluent-bit" class="headerlink" title="Fluent bit"></a>Fluent bit</h2><ul>
<li>更轻量级的日志收集工具，适合嵌入式系统。</li>
<li>生态还不够完善，插件看起来繁多，但未经过验证。</li>
<li>c语言编写，总的来说，占用资源少，性能强。</li>
</ul>
<h2 id="Nabla"><a href="#Nabla" class="headerlink" title="Nabla"></a>Nabla</h2><ul>
<li>一种isolation更好的容器，似乎已超越vm。</li>
<li>性能也只是略弱于docker，不知道是否测试用例的原因。</li>
</ul>
<h2 id="Hyperledger-fabric"><a href="#Hyperledger-fabric" class="headerlink" title="Hyperledger fabric"></a>Hyperledger fabric</h2><ul>
<li>有人说是区块链3.0。（bitcoin 1.0， ethereum 2.0）</li>
<li>一种企业级的区块链系统实现。</li>
<li>减少资源浪费。</li>
<li>增加Smart Contract的功能。</li>
<li>并非完全公开的系统，成员互相知晓存在，但无法了解隐私。</li>
</ul>
<h2 id="Containerd"><a href="#Containerd" class="headerlink" title="Containerd"></a>Containerd</h2><ul>
<li>containerd is an industry-standard container runtime with an emphasis on simplicity, robustness and portability. </li>
<li>It is available as a daemon for Linux and Windows, which can manage the complete container lifecycle of its host system: image transfer and storage, container execution and supervision, low-level storage and network attachments, etc.</li>
</ul>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubespray 超快乐的offline安装k8s</title>
    <url>/2019/04/17/kubespray-%E8%B6%85%E5%BF%AB%E4%B9%90%E7%9A%84offline%E5%AE%89%E8%A3%85k8s/</url>
    <content><![CDATA[<p>经过实践摸索，一套非常容易实现的快速offline安装k8s的方案。</p>
<a id="more"></a>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>整个过程分为两步，1. 准备安装文件，2. offline部署。为了下载镜像，不可避免要翻墙，但我的方案，能够快速响应不同版本，支持scale，并且不需要什么手动pull，手动tag。成功率极高。<br>我使用的是kubespray v2.9.0，kubernetes 1.13.5。</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><ul>
<li><p>机器配置</p>
<ul>
<li>一个带ss的机器（个人电脑即可，带UI的ss更好用，我用的ssx可以直接开http server）</li>
<li>一台虚拟机，内存&gt;=2g。</li>
</ul>
</li>
<li><p>下载<a href="https://github.com/kubernetes-sigs/kubespray" target="_blank" rel="noopener">kubespray</a>，切换到release分支，创建自己的inventory。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:kubernetes-sigs/kubespray.git`</span><br><span class="line">git checkout release-2.9.0</span><br><span class="line">cd kubespray</span><br><span class="line"><span class="meta">#</span><span class="bash"> Install dependencies from ``requirements.txt``</span></span><br><span class="line">sudo pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy ``inventory/sample`` as ``inventory/mycluster``</span></span><br><span class="line">cp -rfp inventory/sample inventory/mycluster</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建虚拟机。</p>
<ul>
<li>采用<code>CentOS7-minimal</code>或者<code>Ubuntu-18.04</code>均可。（这两个我试过，其他的应该也可以，但没试过）。虚拟机使用Vmware或者任何其他均可。</li>
<li>给虚拟机配置好root用户的ssh密钥连接。<strong>注意：某些发行版的sshd可能关闭了密钥认证和root登录，注意检查一下。</strong></li>
</ul>
</li>
<li><p>配置<code>kubespray/inventory/mycluster/hosts.ini</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">[all]</span></span><br><span class="line"><span class="string">node1</span> <span class="string">ansible_host=192.168.1.10</span> <span class="string">ansible_ssh_user=root</span> <span class="string">ansible_ssh_private_key=xxx.pem</span></span><br><span class="line"></span><br><span class="line"><span class="string">[kube-master]</span></span><br><span class="line"><span class="string">node1</span></span><br><span class="line"></span><br><span class="line"><span class="string">[etcd]</span></span><br><span class="line"><span class="string">node1</span></span><br><span class="line"></span><br><span class="line"><span class="string">[kube-node]</span></span><br><span class="line"><span class="string">node1</span></span><br><span class="line"></span><br><span class="line"><span class="string">[k8s-cluster:children]</span></span><br><span class="line"><span class="string">kube-master</span></span><br><span class="line"><span class="string">kube-node</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将虚拟机的ip填入，连接用的私钥也填入。</li>
</ul>
</li>
<li><p>配置<code>kubespray/inventroy/mycluster/group_vars/all.yml</code></p>
<ul>
<li>找到http proxy，将被部署机器的proxy变为本地的1081端口。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Set these proxy values in order to update package manager and docker daemon to use proxies</span></span><br><span class="line"><span class="attr">http_proxy:</span> <span class="string">"http://127.0.0.1:1081"</span></span><br><span class="line"><span class="attr">https_proxy:</span> <span class="string">"http://127.0.0.1:1081"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启自己电脑上的http proxy server。</p>
<ul>
<li>使用ssx的话，可以直接打开http proxy在1081。</li>
<li>只有ss的话，安装privoxy，将socks转换成http，放在1081端口。</li>
<li>这个转换不是重点，这里就不详述。</li>
</ul>
</li>
<li><p>通过ssh透传让虚拟机使用主机的http proxy，保持该窗口，别关闭。</p>
<ul>
<li><code>ssh -K xxx.pem -r 0.0.0.0:1081:127.0.0.1:1081 root@192.168.1.10</code></li>
</ul>
</li>
<li><p>新开一个terminal，切换到kubespray目录，开始部署，下载必要文件。</p>
<ul>
<li><code>ansible-playbook -i inventory/mycluster/hosts.ini --become --become-user=root cluster.yml --tags container_engine</code></li>
<li><code>ansible-playbook -i inventory/mycluster/hosts.ini --become --become-user=root cluster.yml --tags download</code></li>
</ul>
</li>
</ul>
<hr>
<p>完成虚拟机全功能部署。</p>
<ul>
<li>由于使用的是虚拟机，全新的干净镜像，同时使用了翻墙，而且是单节点部署。理所应当成功率极高。</li>
<li>这里部署没有调整addons，网络插件等，这些会影响到后面的正式部署，如果正式部署想要使用这些功能，请在虚拟机部署这里就全部用上。</li>
</ul>
<hr>
<h2 id="Production"><a href="#Production" class="headerlink" title="Production"></a>Production</h2><ul>
<li><p>打包镜像，在虚拟机中，使用<code>docker save</code>将所有镜像保存为tar文件。</p>
<ul>
<li>需要注意，参数必须是完整镜像名+tag，这样load的时候才能带上这些信息。</li>
<li>我是通过<code>docker images | awk &#39;{print $1,$2}&#39; OFS=&quot;:&quot; &gt; temp</code>，导出所有信息到文件中。</li>
<li><code>docker save $(cat temp) &gt; kube.tar</code>，得到镜像文件，可以使用<code>docker load -i kube.tar</code>进行验证。</li>
</ul>
</li>
<li><p>打包其他文件，全部在<code>/tmp/releases</code>下，将这个目录拷贝保存即可。</p>
</li>
<li><p>准备生产环境机器。</p>
<ul>
<li>配置好root ssh连接（别的用户也可，ansible支持sudo切换root）。</li>
<li>安装docker，由于我使用的阿里云VPC，机器虽然不能上互联网，但是apt、yum源均为阿里内部的源，所以我通过apt直接安装。一般来说，内网环境还是会配置安装包的，如果任何安装工具都没有，就自行下载docker安装包，然后安装呗，这个不难。</li>
<li><code>sudo apt -y install docker.io</code>。</li>
<li>通过scp将镜像文件放到机器上，机器之间仍然可以scp分发，内网速度更快。</li>
<li><code>sudo docker load -i kube.tar</code>。导入所有镜像。</li>
<li>将<code>/tmp/releases</code>目录原样拷贝到机器中，即保证目标机器的<code>/tmp/releases</code>目录下有同样的文件，对我来说有三个文件<code>kubeadm hyperkube cni-plugin</code>。</li>
</ul>
</li>
<li><p>配置kubespray</p>
<ul>
<li>去掉<code>all.yml</code>的proxy配置。</li>
<li>在cluster.yml中，注释掉container-engine和download的部分。</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">k8s-cluster:etcd:calico-rr</span></span><br><span class="line"><span class="attr">any_errors_fatal:</span> <span class="string">"<span class="template-variable">&#123;&#123; any_errors_fatal | default(true) &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">kubespray-defaults&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">kubernetes/preinstall,</span> <span class="attr">tags:</span> <span class="string">preinstall</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="comment"># - &#123; role: "container-engine", tags: "container-engine", when: deploy_container_engine|default(true) &#125;</span></span><br><span class="line">    <span class="comment"># - &#123; role: download, tags: download, when: "not skip_downloads" &#125;</span></span><br><span class="line"><span class="attr">environment:</span> <span class="string">"<span class="template-variable">&#123;&#123;proxy_env&#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调整<code>hosts.ini</code>，指向生产环境机器。</li>
</ul>
</li>
<li><p>开始部署。</p>
<ul>
<li><code>ansible-playbook -i inventory/mycluster/hosts.ini --become --become-user=root cluster.yml</code></li>
</ul>
</li>
<li><p><strong>出错</strong></p>
<ul>
<li>我在部署过程中，出现了一个错误，master节点下的<code>/usr/local/bin</code>找不到<code>kubeadm</code>，我怀疑是master部分脚本没有从releases下拷贝，而这个目录则是取决于<code>{bin_dir}</code>。</li>
<li>为了图快，我手动将<code>/tmp/releases/kubeadm</code>移动到报错的目录，然后成功。</li>
<li>通过检查role，确实是copy部分的脚本位于download下，取消了download之后，这部分就失效了。</li>
<li>建议直接将kubeadm复制到<code>/usr/local/bin</code>。</li>
</ul>
</li>
<li><p><strong>更新</strong></p>
<ul>
<li>在更新版本的kubespray中，copy脚本已经移动了位置了，只要保证<code>/tmp/releases</code>下有文件就行了。</li>
</ul>
</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>通过虚拟机模拟环境，然后迁移，实现内网安装k8s。</li>
<li>一些问题<ul>
<li>由于我使用的机器，能够使用apt，所以可能会有些不一样。如果连apt、yum都不能使用，可能会出现一些错误，这时根据脚本报错自行修正即可。</li>
</ul>
</li>
</ul>
<h2 id="Presentation"><a href="#Presentation" class="headerlink" title="Presentation"></a>Presentation</h2><p><img src="/2019/04/17/kubespray-%E8%B6%85%E5%BF%AB%E4%B9%90%E7%9A%84offline%E5%AE%89%E8%A3%85k8s/done.png" alt="图片加载失败"></p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode中级算法</title>
    <url>/2018/08/28/leetcode%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>不一定按顺序的随心所欲记录。</p>
<a id="more"></a>

<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><ol>
<li><p>最长回文子串</p>
<ul>
<li>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</li>
<li>v[m][n]表示s[m,n]为一个回文串<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">v</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((i&lt;<span class="number">2</span> || v[j+<span class="number">1</span>][j+i<span class="number">-1</span>]) &amp;&amp; s[j] == s[j+i])&#123;</span><br><span class="line">                v[j][j+i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; num)&#123;</span><br><span class="line">                    pos = j, num = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(pos, num+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>矩阵置零</p>
<ul>
<li>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</li>
<li>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个常数空间的解决方案吗？</li>
<li>因为原地算法，所以不能找到0就马上改变其他位置（未判断过的位置），这会影响后面的判断，所以必然要记录一下有哪些行列要置零。</li>
<li>一下子陷入僵局，这样就需要m+n的空间去记录。</li>
<li>注意这里的说法，“额外空间”，为什么不使用已有空间来做记录呢？</li>
<li>按序遍历二维数组，一个数字的所在的行列，总会有已经判断过的值，发现需要清零，这些位置可以直接改为零。</li>
<li>结论：用第一行和第一列作为清零的记录位，而这一行一列用两个bool变量去记录是否需要清零，这样就变成常数额外空间。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">bool</span> frow = <span class="literal">false</span>, fcol = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    frow = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    fcol = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rows;i++)</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;cols;j++)</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (frow)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (fcol)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h2><ol>
<li>岛屿的个数<ul>
<li>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</li>
<li>一开始想着顺序遍历，给’1’的位置赋一个标记，比如’2’，’3’，以此区分不同地区，同时将一个点周围的四个点改为相同的值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法通过的第一次尝试</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mark=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = grid.size();</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dic&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                grid[i][j] += mark;</span><br><span class="line">                mark++;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : dic)&#123;</span><br><span class="line">                <span class="keyword">int</span> i2 = i + c[<span class="number">0</span>], j2 = j + c[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i2 &lt; <span class="number">0</span> || i2 &gt;= row || j2 &lt; <span class="number">0</span> || j2 &gt;= col || grid[i2][j2] == <span class="string">'0'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i2][j2] !== <span class="string">'1'</span>)</span><br><span class="line">                    ans--;</span><br><span class="line">                grid[i2][j2] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mark - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>遇上“工”字形状就会出问题，没办法还是得DFS。</li>
<li>在循环结构时，边界条件、相应+1-1可以借助构造一个包含01、10、0-1、-10二维数组将代码写的更好看，简洁。但是像DFS这样的递归结构，不便于构造辅助数组，会占用较多栈空间。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过，DFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfshelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;= grid.size() || j&lt;<span class="number">0</span> || j&gt;= grid[<span class="number">0</span>].size() || grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">    dfshelper(grid, i, j+<span class="number">1</span>);</span><br><span class="line">    dfshelper(grid, i, j<span class="number">-1</span>);</span><br><span class="line">    dfshelper(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    dfshelper(grid, i<span class="number">-1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mark=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = grid.size();</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                mark++;</span><br><span class="line">                dfshelper(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><ol>
<li><p>合并区间</p>
<ul>
<li><blockquote>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
</blockquote>
</li>
<li>一开始没有想到排序，陷入一种递归的尴尬境地，排序后就可以保证前面定好的区间不会变动。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Interval&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>,n=intervals.size();</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">    res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (res[j].end &lt; intervals[i].start)&#123;</span><br><span class="line">            res.push_back(intervals[i]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (res[j].end &lt;= intervals[i].end)&#123;</span><br><span class="line">            res[j].end = intervals[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>相比起vector.erase，新建一个vector速度更快，也能避免修改原数组。</li>
<li>其实在很多时候（尤其链表、数组），想象成两个组，比较方便，实现起来也容易，“将正确的结果放入到一个新组”。（不一定是复制两份，比如链表，只需要一个新的头指针，然后往后加）</li>
</ul>
</li>
<li><p>前k个高频元素</p>
<ul>
<li>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</li>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li>
<li>c++中有一个pair对象，也是stl map默认的分配模式，因为map不是线性排列，不能应用sort，所以先转换成vector，同时为pair对象写一个compare方法。</li>
<li>用map记录各个元素出现次数。</li>
<li>c++11提供了lambda函数支持。（很酷炫）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)&#123;</span><br><span class="line">        dic[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; vec(dic.begin(), dic.end());</span><br><span class="line">    sort(vec.begin(), vec.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)&#123;<span class="keyword">return</span> a.second &gt; b.second;&#125;);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        r.push_back(vec[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组中的第k个最大元素</p>
<ul>
<li>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</li>
<li>对vector进行sort即可，但由于是引用传参，这样做就不是纯函数了。</li>
<li>与其对vector进行copy，不如用优先队列，也就是堆结构去存储。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : nums)&#123;</span><br><span class="line">        q.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k;k&gt;<span class="number">1</span>;k--)&#123;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>搜索旋转排序数组</p>
<ul>
<li>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</li>
<li>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</li>
<li>你可以假设数组中不存在重复的元素。</li>
<li>你的算法时间复杂度必须是 O(log n) 级别。</li>
<li>首先应该确定用二分搜索，然后二分在于要选择左右段。</li>
<li>没有思路时可以把旋转后的几种情况列出，取中间数观察（然而一开始连旋转都没看懂）。</li>
<li>结论是：中间数的左右总有一段是有序的，不会都无序，找出有序的一段，比较首尾和目标，即可知道是选这一段还是另一段。</li>
<li>二分搜索要正确结束的确不容易，我个人更习惯left&lt;right，然后在mid==left的时候break，循环外再检验一次right值。</li>
<li>后来我觉得这样写还是有点多余，在重新整理了二分查找的方法后，意识到left&lt;=right，然后移动时多移一个位置，更简洁。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (left == mid)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] &gt; nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] &lt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; target)</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li>奇偶链表<ul>
<li>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</li>
<li>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</li>
<li>应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* odd = head;</span><br><span class="line">    ListNode* evenhead = head-&gt;next;</span><br><span class="line">    ListNode* even = evenhead;</span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = evenhead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ol>
<li><p>生成括号</p>
<ul>
<li>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</li>
<li>即要求括号成对，左括号总是先于右括号出现一次。</li>
<li>假如想象成一个一个括号生成，则有如下两个情况：  <ol>
<li>左括号数&lt;n，可以添加左括号</li>
<li>左括号数&gt;右括号数，可以添加右括号</li>
</ol>
</li>
<li>使用字典实现记录左括号数即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; temp1, temp2;</span><br><span class="line">    temp1[<span class="string">"("</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=n*<span class="number">2</span><span class="number">-1</span>;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : temp1)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i.second &lt; n)&#123;</span><br><span class="line">                temp2[i.first+<span class="string">"("</span>] = i.second + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n*<span class="number">2</span> - k - i.second*<span class="number">2</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                temp2[i.first+<span class="string">")"</span>] = i.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp1.swap(temp2);</span><br><span class="line">        temp2.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : temp1)&#123;</span><br><span class="line">        r.push_back(i.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>也可以用递归，这时靠栈空间去记录左括号的数量和字符串。</li>
</ul>
</li>
<li><p>电话号码的字母组合</p>
<ul>
<li>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。</li>
<li>2&gt;abc, 3&gt;def…</li>
<li>因为映射关系是符合字母顺序的（ascii码有序），可以只构造首字母，然后+1，进位，直至不能在增大，即所有结果都出现过。</li>
<li>比如”23”替换为”ad”-&gt;”ae”-&gt;”af”-&gt;”bd”-&gt;”be”-&gt;”bf”-&gt;”cd”-&gt;”ce”-&gt;”cf”-&gt;终止。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; r;</span><br><span class="line">    <span class="keyword">char</span> left[<span class="number">9</span>] = &#123;<span class="string">'a'</span>,<span class="string">'d'</span>,<span class="string">'g'</span>,<span class="string">'j'</span>,<span class="string">'m'</span>,<span class="string">'p'</span>,<span class="string">'t'</span>,<span class="string">'w'</span>,<span class="string">'z'</span>+<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = digits.size();</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">copy</span><span class="params">(digits)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        copy[i] = left[copy[i]-<span class="string">'2'</span>];</span><br><span class="line">    r.push_back(copy);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = len - <span class="number">1</span>;</span><br><span class="line">        copy[p]++;</span><br><span class="line">        <span class="keyword">while</span>(copy[p] == left[digits[p]-<span class="string">'1'</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            copy[p] = left[digits[p]-<span class="string">'2'</span>];</span><br><span class="line">            p--;</span><br><span class="line">            copy[p]++;</span><br><span class="line">        &#125;</span><br><span class="line">        r.push_back(copy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单词搜索</p>
<ul>
<li>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</li>
<li>使用DFS。</li>
<li>防止重复使用，可以在代码中递归部分的前后，加上修改当前判断值和还原当前值的两行，此处因为是char类型，使用了异或操作，其他类型用局部变量存储也可。</li>
<li>要注意边界条件。</li>
<li>获取vector size的方法，也没有想象中那么慢，不用太在意。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row=board.size(), len=word.size();</span><br><span class="line">    <span class="keyword">if</span> (row &lt;= <span class="number">0</span> || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> col=board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>] &amp;&amp; helper(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> &amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos == word.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;= board.size() || j&lt;<span class="number">0</span> || j&gt;=board[<span class="number">0</span>].size() || board[i][j] != word[pos])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    board[i][j] ^= <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = (helper(board, word, i+<span class="number">1</span>, j, pos+<span class="number">1</span>)</span><br><span class="line">                  || helper(board, word, i, j+<span class="number">1</span>, pos+<span class="number">1</span>)</span><br><span class="line">                  || helper(board, word, i, j<span class="number">-1</span>, pos+<span class="number">1</span>)</span><br><span class="line">                  || helper(board, word, i<span class="number">-1</span>, j, pos+<span class="number">1</span>));</span><br><span class="line">    board[i][j] ^= <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>子集</p>
<ul>
<li>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li>
<li>生成法。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    res.push_back(&#123;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp; num : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> size = res.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = res[i];</span><br><span class="line">            temp.push_back(num);</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="排序和搜索-1"><a href="#排序和搜索-1" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><ol>
<li><p>寻找峰值</p>
<ul>
<li>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。你可以假设 nums[-1] = nums[n] = -∞。</li>
<li>你的解法应该是 O(logN) 时间复杂度的。</li>
<li>因为数组两端是负无穷，则峰值一定存在，每次取数组中间的数，和它左右的数比较。假设三个数为a,b,c，如果a（c）大于b，则左（右）区间一定有峰值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid<span class="number">-1</span>])</span><br><span class="line">            r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[mid+<span class="number">1</span>])</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l==r)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nums[r] &gt; nums[l])</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>探索二维矩阵</p>
<ul>
<li>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</li>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
<li>从左下角或者右上角开始就很简单。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.empty() || matrix[<span class="number">0</span>].empty())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">int</span> row=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size()<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(row&lt;matrix.size() &amp;&amp; col&gt;<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">            col--;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target)</span><br><span class="line">            row++;  </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol>
<li><p>x的平方根</p>
<ul>
<li>实现 int sqrt(int x) 函数。</li>
<li>计算并返回 x 的平方根，其中 x 是非负整数。</li>
<li>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</li>
<li>用二分搜索，找到两个相邻数的平方值区间包含目标数x。</li>
<li>(right-left)/2+left的写法可以避免溢出。</li>
<li>x/mid而不是mid**2也是为了避免溢出。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=x;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x/mid&gt;=mid) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Pow(x,n)</p>
<ul>
<li>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</li>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
<li>x**(a+b) = (x**a) * (x**b)</li>
<li>而任何一个整数都可以被分解为2的幂次和<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">            res *= x;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        x *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分数到小数</p>
<ul>
<li>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。</li>
<li>如果小数部分为循环小数，则将循环的部分括在括号内。</li>
<li>INT_MIN / -1 是执行出错，属于未定义错误。</li>
<li>除了溢出，还要考虑正负号，如果将被除数和除数取绝对值，又有abs(INT_MIN)的风险。</li>
<li>直接将被除数和除数都扩展为long long类型比较暴力。</li>
<li>因为要判断是否加负号，加小数点，所以第一次除，单独算在循环体前面。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((numerator &gt;&gt; <span class="number">31</span>) != (denominator &gt;&gt; <span class="number">31</span>))</span><br><span class="line">        r = <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">long</span> t = numerator, d = denominator;</span><br><span class="line">    t = <span class="built_in">abs</span>(t), d = <span class="built_in">abs</span>(d);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[t] = r.size();</span><br><span class="line">    r = to_string(t / d);</span><br><span class="line">    t = (t % d) * <span class="number">10</span>;</span><br><span class="line">    r += t == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">"."</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(t) == <span class="number">1</span>)&#123;</span><br><span class="line">            r.insert(m[t], <span class="string">"("</span>);</span><br><span class="line">            r += <span class="string">")"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[t] = r.size();</span><br><span class="line">        r += to_string(t / d);</span><br><span class="line">        t = (t % d) * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>两数相除</p>
<ul>
<li>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</li>
<li>返回被除数 dividend 除以除数 divisor 得到的商。</li>
<li>从最大的2幂次开始，逐个减掉。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">long</span> dd = <span class="built_in">abs</span>((<span class="keyword">long</span>)dividend), dr = <span class="built_in">abs</span>((<span class="keyword">long</span>) divisor);</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dd &gt;= dr)&#123;</span><br><span class="line">        <span class="keyword">long</span> a = dr, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;&lt;<span class="number">1</span> &lt; dd)&#123;a&lt;&lt;=<span class="number">1</span>;count&lt;&lt;=<span class="number">1</span>;&#125;</span><br><span class="line">        res+= count;</span><br><span class="line">        dd-=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((dividend ^ divisor)&gt;&gt;<span class="number">31</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>阶乘后的零</p>
<ul>
<li>给定一个整数 n，返回 n! 结果尾数中零的数量。</li>
<li>实际上只有2*5才会产生0，由于2一定多于5，统计总共有多少个5就可以。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">        r += (n /= <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li><p>零钱兑换</p>
<ul>
<li>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</li>
<li>现实中的硬币面值组合，是可以组成任意数字的，所以只要从大到小算就可以了。</li>
<li>题目的意思显然还会有凑不出来的情况，也就是说，这里不应关心硬币的面值组合和顺序，而是当作整体。</li>
<li>这样一来，和限定每次能走几步，能否走到某个点上的位置，是一样的问题。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">step</span><span class="params">(amount+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : coins)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; c &lt;= amount)</span><br><span class="line">            step[c] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : coins)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i-c &gt; <span class="number">0</span> &amp;&amp; step[i-c] != INT_MAX)&#123;</span><br><span class="line">                step[i] = min(step[i], step[i-c]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (step[amount] == INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> step[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最长上升子序列</p>
<ul>
<li>给定一个无序的整数数组，找到其中最长上升子序列的长度。</li>
<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
<li>你算法的时间复杂度应该为 O(n2) 。</li>
<li>这题首先考虑用动态规划做，n2比较容易达到，考虑data[i]表示从nums[0]到nums[i]，并且以i结尾的上升子序列的长度。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i])&#123;</span><br><span class="line">                data[i] = max(data[i], data[j] + <span class="number">1</span>);</span><br><span class="line">                re = max(re, data[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>O(nlogn)的一个办法，贪心+二分搜索。维护一个数组low，low[i]表示LIS长度为i时的最小结尾元素。</li>
<li>只需要遍历一遍，如果新元素比LIS结尾还大，就添加到low数组末尾，如果不能直接添加，则更新中间的某个位置。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size(), r=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">low</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (low[mid] &lt; x)</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        low[i] = x;</span><br><span class="line">        <span class="keyword">if</span> (i == r)</span><br><span class="line">            r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode初级算法</title>
    <url>/2018/07/07/leetcode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在leetcode上做了几道题，捡起来遗忘的c++，STL确实厉害，在这里整理一波初级算法章节的解题过程。（过于简单的题没有记录）</p>
<a id="more"></a>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><p>从排序数组中删除重复项</p>
<ul>
<li>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</li>
<li>这题用c做更有数组的感觉。</li>
<li>因为是有序数组，所以重复的元素相邻。</li>
<li>遍历数组，用一个变量记录不重复元素的个数（数组最大索引也可）。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numsSize;i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[index])</span><br><span class="line">            nums[++index] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>买卖股票的最佳时机 II</p>
<ul>
<li>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>稍微有点绕，代码却很简洁，将相邻项差值，有得赚的全加起来就是答案。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pricesSize - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>旋转数组</p>
<ul>
<li>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</li>
<li>方法很多，题目中也要求找出至少三种，这里只记一种看起来很巧的。</li>
<li>以第n-k个元素为界，左边reverse，右边reverse，然后整体reverse。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (!n || (k %= n) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>()+n-k);</span><br><span class="line">    reverse(nums.<span class="built_in">begin</span>()+n-k, nums.<span class="built_in">end</span>());</span><br><span class="line">    reverse(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>存在重复</p>
<ul>
<li>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</li>
<li>转换数据结构，将数组变成集合，比较元素数量是否相同。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">all</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> all.<span class="built_in">size</span>() != nums.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>只出现一次的数字</p>
<ul>
<li>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</li>
<li>遍历一次，异或操作。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : nums)</span><br><span class="line">        n ^= i ;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>两个数组的交集 II</p>
<ul>
<li>给定两个数组，写一个方法来计算它们的交集。</li>
<li>用一个哈希字典，记录数组元素出现的次数，遍历即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; num : nums1)</span><br><span class="line">        dic[num] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; num : nums2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic[num] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(num);</span><br><span class="line">            dic[num] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>num2的大小比较大的时候，用num1建立字典就好。</li>
<li>如果数组有序，则不用字典，直接两个数组遍历比较，根据比较结果移动下标。</li>
</ul>
</li>
<li><p>加一</p>
<ul>
<li>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</li>
<li><blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
</blockquote>
</li>
<li>从小位开始，逐个进位，最高位进位时，需要vector.insert一个值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.empty()) <span class="keyword">return</span> digits;</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=digits.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = digits[i] + add;</span><br><span class="line">        digits[i] = temp % <span class="number">10</span>;</span><br><span class="line">        add = temp / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (!add)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (add)</span><br><span class="line">        digits.insert(digits.begin(), add);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>两数之和</p>
<ul>
<li>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</li>
<li>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</li>
<li>因为输出的是两数的位置，所以不能先排序。</li>
<li>hashmap记录前面出现过的数和位置。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> one = nums[i];</span><br><span class="line">        <span class="keyword">int</span> another = target - one;</span><br><span class="line">        <span class="keyword">if</span> (temp.find(another) != temp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;temp[another], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        temp[one] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有效的数独</p>
<ul>
<li>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</li>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
<li>空间换时间，用三个大数组，分别记录行、列、块是否出现过某个数字。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> block[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="number">9</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j!=<span class="number">9</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">int</span> k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (row[i][temp] || col[j][temp] || block[k][temp])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            row[i][temp] = col[j][temp] = block[k][temp] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>旋转数组</p>
<ul>
<li>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。</li>
<li>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</li>
<li>一个数字旋转需要移动另外三个数，也就是四个数构成循环，移动好就算完成。</li>
<li>n*n矩阵，转换位置时也比较方便。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = matrix.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> blocklen = len<span class="number">-1</span>-i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;len-i<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            <span class="keyword">int</span> ti=i, tj=j;</span><br><span class="line">            <span class="keyword">int</span> ni=len-tj<span class="number">-1</span>, nj=ti;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[ti][tj] = matrix[ni][nj];</span><br><span class="line">                ti = ni;</span><br><span class="line">                tj = nj;</span><br><span class="line">                ni=len-tj<span class="number">-1</span>, nj=ti;</span><br><span class="line">            &#125;</span><br><span class="line">            matrix[ti][tj] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><p>有效的字母异位词</p>
<ul>
<li>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</li>
<li>因为全是字母，所以用27位的数组就可以。</li>
<li>如果是更复杂的“字”，用hashmap应该可以解决。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dic[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : s)</span><br><span class="line">        dic[c-<span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : t)</span><br><span class="line">        dic[c-<span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">27</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (dic[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串转整数(atoi)</p>
<ul>
<li>该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</li>
<li>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</li>
<li>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</li>
<li>若函数不能执行有效的转换，返回 0。</li>
<li>就是各种边界条件比较烦。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = str.size();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i]==<span class="string">' '</span>) i++;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = str[i] == <span class="string">'-'</span> ? !flag: flag;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + str[i] - <span class="string">'0'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> flag ? INT_MAX : INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>报数</p>
<ul>
<li>报数序列是指一个整照其中的整数的顺序进数序列，按行报数，得到下一个数。</li>
<li>1 -&gt; 11 -&gt; 21 -&gt; 1211 -&gt; 111221</li>
<li>题目设定比较有意思，实现不难，按顺序读就行。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> r = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        r=next_s(r)</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">next_s</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">for</span> (pos;pos&lt;len<span class="number">-1</span>;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[pos]==s[pos+<span class="number">1</span>])</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            n.push_back(cnt+<span class="string">'0'</span>);</span><br><span class="line">            n.push_back(s[pos]);</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n.push_back(cnt+<span class="string">'0'</span>);</span><br><span class="line">    n.push_back(s[len<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li>删除链表的倒数第N个节点<ul>
<li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li>
<li>两个节点，一个领先另外一个n，然后一起前进。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode * target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ListNode * tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n)</span><br><span class="line">            target = head;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">            target = target-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    target-&gt;next = target-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode小技巧</title>
    <url>/2018/10/03/leetcode%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>在做专项训练和一些随机题的时候，看别人的代码学到的一些编程小技巧。</p>
<a id="more"></a>

<ol>
<li><p>读取字符串，同时需要分辨其中字母和数字。</p>
<ul>
<li>自己做转换的速度快，用上switch就比if-else更快。</li>
<li>相比stringstream，少了错误处理，犯不上检查failbit，也不用clear了，速度明显提升，代码可读性也很好。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>: &#123;</span><br><span class="line">                tmp_num += s[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            case 'other': &#123;</span><br><span class="line">                <span class="keyword">int</span> t = stoi(tmp_num);</span><br><span class="line">                <span class="comment">// do xxx</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>加减法变换，避免溢出</p>
<ul>
<li>后来想这可能是二分搜索出错最多的地方了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mid_right = left + (right - left) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>一般来说，索引都是正数，而且左右都没溢出，求中间数不应该溢出的。</li>
<li>平方数的判断，乘法变除法，在做乘法检验。</li>
<li>当然比较暴力的办法是换更大的类型。</li>
</ul>
</li>
<li><p>queue与BFS</p>
<ul>
<li>我特别喜欢用stl中的swap方法去做层级的变换。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1, q2;</span><br><span class="line"><span class="keyword">while</span>(!q1.empty())&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q1.empty())&#123;</span><br><span class="line">        <span class="comment">// do xx; q2.push(next);</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">    q1.swap(q2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当然swap还有一些其他的妙用，下次碰上了再写。</li>
<li>但是BFS还有一个办法，我觉得这个更妙了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n=q.size();n&gt;<span class="number">0</span>;n--)&#123;</span><br><span class="line">        <span class="comment">// do xx; q.push(next);</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>保证某个值为小的一个</p>
<ul>
<li>这应用场景很多，像stl容器有swap方法，其他的一些类型也可以交换，然后就能保证两个值的顺序，后面的代码就能做统一处理。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums1.size();</span><br><span class="line"><span class="keyword">int</span> m = nums2.size();</span><br><span class="line"><span class="keyword">if</span>(n &gt; m)   <span class="comment">//保证数组1一定最短</span></span><br><span class="line">    <span class="keyword">return</span> func(nums2,nums1);</span><br></pre></td></tr></table></figure></li>
<li>像上面这种递归调用一次自己也是一种不错的方法，尤其适用于，传入参数是引用时，这时不方便做swap，复制又太耗费时间。</li>
</ul>
</li>
<li><p>数组越界的处理</p>
<ul>
<li>一般来说这种办法适用于有序数组，两端的值用INT_MAX和INT_MIN代替。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">L1 = (c1 == <span class="number">0</span>)?INT_MIN:nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];   <span class="comment">//map to original element</span></span><br><span class="line">R1 = (c1 == <span class="number">2</span>*n)?INT_MAX:nums1[c1/<span class="number">2</span>];</span><br><span class="line">L2 = (c2 == <span class="number">0</span>)?INT_MIN:nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">R2 = (c2 == <span class="number">2</span>*m)?INT_MAX:nums2[c2/<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多值visit表示</p>
<ul>
<li>在做遍历，DFS，BFS等算法时，经常需要mark经过的点，还有一种有意思的叫法是color。</li>
<li>有时候发现不一定只有两种状态，可以设定更多的值表明不同的状态，比如dfs拓扑排序，一个点出发不一定能经过整个图，所以会尝试从任何一个点出发，这个时候要区分成环和访问过，就会做三种状态“未访问”，“访问过”，“本次搜索访问过”，以便及时退出算法。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (visit[n] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">visit[n] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : v[n])&#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[c] == <span class="number">-1</span> || (visit[c] == <span class="number">0</span> &amp;&amp; !dfs(c, v, visit, topo)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">visit[n] = <span class="number">1</span>;</span><br><span class="line">topo.push_back(n);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指针的指针</p>
<ul>
<li>在删除链表中元素的时候，往往要记录两个指针，因为单链表不能往前。而这样做在删除头的时候，又引入了问题。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* temp = head;</span><br><span class="line"><span class="keyword">while</span> (temp &amp;&amp; temp-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next-&gt;val == val)</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li>当然对于这个例子，虚拟头指针也是不错的办法。</li>
<li>但取地址来做，代码更简洁了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode ** temp = &amp;head;</span><br><span class="line"><span class="keyword">while</span>(*temp)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*temp)-&gt;val == val)</span><br><span class="line">        *temp = (*temp)-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp = &amp;(*temp)-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>树结构滑动窗口</p>
<ul>
<li>滑动窗口比较直观的是数组，用树结构，插入和删除的复杂度提升，但是数据有序。</li>
<li>有序之后查找和比较时间较少，而且可以利用二分库函数lower_bound、upper_bound。</li>
<li>有一个需要注意的特性是出现重复元素，删除将会变得复杂，一般还是应用在不会重复，或者重复时算法就会结束。</li>
</ul>
</li>
<li><p>不重复的n数之和</p>
<ul>
<li>做n数之和的套路总是先排序，然后从两端遍历。依次去掉几个数就可以归纳到两数之和。</li>
<li>当要求找出来的解答不重复，还需要一点小技巧。<ul>
<li>用<code>set&lt;vector&lt;int&gt;&gt;</code>，当vector中是基本类型（其实我觉得只要是有==运算的类型都可以），vector也可以进行比较。</li>
<li>循环中增加条件。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; left++; &#125; <span class="keyword">while</span> (nums[left] == nums[left - <span class="number">1</span>] &amp;&amp; left &lt; right);</span><br><span class="line"><span class="keyword">do</span> &#123; right--; &#125; <span class="keyword">while</span> (nums[right] == nums[right + <span class="number">1</span>] &amp;&amp; left &lt; right);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2的幂</p>
<ul>
<li>其实就是二进制表示，有且只有一个1的数。</li>
<li><code>n &amp; (n-1) == 0</code></li>
</ul>
</li>
<li><p>格雷编码</p>
<ul>
<li>相邻数只有一位不同（二进制）。</li>
<li>话不多说，直接奇技淫巧。<ul>
<li>第一种<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gray;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n); i++)</span><br><span class="line">    gray.push_back(i^(i&gt;&gt;<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> gray;</span><br></pre></td></tr></table></figure></li>
<li>第二种<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        v[i] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        v.push_back(v[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>循环体中的条件语句</p>
<ul>
<li>如果只嵌套一层条件语句，可读性还算可以。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="comment">// do xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>像字典序算法，需要循环两次。我觉得这时候可读性就不太好了。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">// do xxx</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do xxx</span></span><br></pre></td></tr></table></figure></li>
<li>这时候一手逆向思维，条件反转，这个太显功力了。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= i &amp;&amp; nums[j] &lt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">reverse(nums, i);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode高级算法</title>
    <url>/2018/09/18/leetcode%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>不一定按顺序的随心所欲记录。</p>
<a id="more"></a>

<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><ol>
<li><p>Product of Array Except Self</p>
<ul>
<li>给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</li>
<li>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</li>
<li>分为两步，计算一个数字左边所有数字乘积，再计算右边所有数字乘积。</li>
<li>正好可以复用前面的结果，按顺序累乘。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">r</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        r[i+<span class="number">1</span>] = r[i] * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        temp *= nums[i];</span><br><span class="line">        r[i<span class="number">-1</span>] *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第一个缺失的正数</p>
<ul>
<li>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</li>
<li>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。</li>
<li>限制了空间，所以从数组本身上找办法，让下标和数字对应，就能找出缺失的数。</li>
<li>但我觉得这修改了原数组，有点不太好。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;n &amp;&amp; nums[i] !=i+<span class="number">1</span> &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[nums[i]<span class="number">-1</span>];</span><br><span class="line">            nums[nums[i]<span class="number">-1</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i+<span class="number">1</span>)</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>四数相加II</p>
<ul>
<li>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</li>
<li>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</li>
<li>四组分为两组，先记录两个数组相加的所有结果和出现次数，然后计算另两个相加是否出现相反数，结果加上次数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; us;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;a : A)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;b : B)&#123;</span><br><span class="line">            us[a+b]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;c : C)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;d : D)&#123;</span><br><span class="line">            <span class="keyword">if</span> (us[-c-d] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                r+= us[-c-d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寻找重复数</p>
<ul>
<li>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</li>
<li>注意读题，对数字是有限制的，都在[1,n]中，所以类似抽屉原理，一定会有重复数。</li>
<li>二分法，取中间数，判断某一个区间内的数的数量，如果超过了区间大小，则一定有重复。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>, r=n;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid= l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= mid)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; mid)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == l)</span><br><span class="line">            count++;</span><br><span class="line">    <span class="keyword">return</span> count &gt; <span class="number">1</span> ? l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Sliding Window Maximum</p>
<ul>
<li>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。返回滑动窗口最大值。</li>
<li>线性时间复杂度。</li>
<li>一上来想，分治，树，堆栈，队列，都解决不了。</li>
<li>关键数据结构是一个，双向队列，或者说，链表。有序链表插入的复杂度显然太高了，而这个巧妙的点在于，对于窗口，先进先出，最后插入的元素，一定比前面的要后出。那么在队列中，比这个插入元素还小的元素，就没有意义了，它一定不会成为最大的了，可以删掉，这样保证最多只会比较一次大于，复杂度就维持在O(n)了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() == i - k) q.pop_front();  <span class="comment">// 头滑出窗口</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) q.pop_back();  <span class="comment">// 删掉小于新元素的值</span></span><br><span class="line">        q.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最小窗口子字符串</p>
<ul>
<li>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</li>
<li>判断某个字符是否存在于T，或者记录它出现次数，这些操作，想到用哈希表。但更极致的是，因为是char类型，所以用vector&lt;&gt;(128)会更快。</li>
<li>有一个问题是，怎样判断我扫描过的字串刚好包含了T所有字母，反过来的临界条件（去掉某个字符则不能包含T）很好判断。判断方法我一时没有想到，于是用临界条件反过来做。那么需要一个初始状态，也就是子串即s，但此时又有一个问题，可能不存在答案，所以我先扫描一遍字典，比较字符数量，确保答案存在。</li>
<li>接下来，从两端开始，不断去掉字符，直至无法再去掉，就找到了最小子串。但仔细一想，这是有问题的，如果两端字符相同，并且只能去掉一个的时候，去掉左边还是右边？没法判断，必须都试一试，然后比较字符串长度。于是一端移动时，另一端又要尝试回退。还要记录找到的最小长度，更新这个长度。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mt;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ms;</span><br><span class="line">    <span class="keyword">int</span> min_l= <span class="number">0</span>, min_r=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        ms[c]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : t)</span><br><span class="line">        mt[c]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : mt)&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.second &gt; ms[item.first])</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=s.size();</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>, r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (l;l&lt;n;l++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ms[s[l]] == mt[s[l]])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ms[s[l]] &gt; mt[s[l]])</span><br><span class="line">            ms[s[l]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (r;r&gt;=<span class="number">0</span>;r--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[s[r]] == mt[s[r]])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ms[s[r]] &gt; mt[s[r]])</span><br><span class="line">                ms[s[r]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r-l &lt; min_r - min_l)&#123;</span><br><span class="line">            min_r = r;</span><br><span class="line">            min_l = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l-- == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ms[s[l]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substr(min_l, min_r-min_l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接下来是优化这段代码。</li>
<li>不需要两个哈希表，一个就足够了，不用相互比较字符，以0为界限就可以了。</li>
<li><strong>判断当前字串是否满足条件的办法：找到一个属于T的字符，cnt++，当cnt==tsize时，就恰好找到。</strong></li>
<li>于是两个pos都从左端开始，分别前进，记录最小长度。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">letterCnt</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, cnt = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) ++letterCnt[c];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--letterCnt[s[i]] &gt;= <span class="number">0</span>) ++cnt;</span><br><span class="line">        <span class="keyword">while</span> (cnt == t.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; i - left + <span class="number">1</span>) &#123;</span><br><span class="line">                minLen = i - left + <span class="number">1</span>;</span><br><span class="line">                res = s.substr(left, minLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++letterCnt[s[left]] &gt; <span class="number">0</span>) --cnt;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>最长连续序列</p>
<ul>
<li>给定一个未排序的整数数组，找出最长连续序列的长度。</li>
<li>要求算法的时间复杂度为 O(n)。</li>
<li>复杂度为O(n)的话，排序不用想了，数据结构几乎也就剩下哈希表了。</li>
<li>在这里一开始漏想到一个点，就是新添加一个数i时，怎么找到i左右的两端。比如说，已经有1、2、4、5，现在加入一个3，那么两端是1，5，显然不能是按序检查哈希表是否存在连续数字。实际上1、2、4、5也各自维护了自己的序列长度，直接加减序列长度，就能到两端位置了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; i : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> l=m[i<span class="number">-1</span>], r=m[i+<span class="number">1</span>];</span><br><span class="line">            m[i] = l + r + <span class="number">1</span>;</span><br><span class="line">            m[i-l] = m[i];</span><br><span class="line">            m[i+r] = m[i];</span><br><span class="line">            res = max(res, m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>螺旋矩阵</p>
<ul>
<li>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</li>
<li>没有追求极致速度，而是将代码写的简洁，虽然也不是很短。</li>
<li>将循环硬编码更快，但要注意的是，不能四次放在一个循环内，因为有可能是没有四次的，比如九宫格，第一圈四次转完只需要中间走一个就结束了。也就是说，四次移动中间可以加一个判断条件，终止循环。（其实就是看边界条件放哪里判断比较简洁方便）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.size() &lt; <span class="number">1</span> || matrix[<span class="number">0</span>].size() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; dic = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> m=matrix.size(), n=matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> sum=m*n, mode=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span> (mode%<span class="number">2</span>)</span><br><span class="line">            temp = n--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp = --m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp;i++)&#123;</span><br><span class="line">            x += dic[mode].first;</span><br><span class="line">            y += dic[mode].second;</span><br><span class="line">            sum--;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">        mode = (mode+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li><p>合并K个元素的有序链表</p>
<ul>
<li>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</li>
<li>使用priority_queue，本质上就是堆排序，复杂度应该在nlogn</li>
<li>堆排序没有利用到有序链表这个条件。</li>
<li>合并两个有序链表很容易，如果采用分治法，则类似归并排序，<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : lists)&#123;</span><br><span class="line">        <span class="keyword">while</span> (p)&#123;</span><br><span class="line">            pq.push(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pq.size() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode * root = <span class="keyword">new</span> ListNode(pq.top());</span><br><span class="line">    pq.pop();</span><br><span class="line">    ListNode * temp = root;</span><br><span class="line">    <span class="keyword">while</span> (!pq.empty())&#123;</span><br><span class="line">        temp-&gt;next = <span class="keyword">new</span> ListNode(pq.top());</span><br><span class="line">        pq.pop();</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>链表排序</p>
<ul>
<li>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</li>
<li>说到nlogn的排序，想到的也就是快排、归并、堆排了。</li>
<li>单向链表快排不太方便，堆排同理。归并的话，龟兔赛跑就可以找到中间节点，然后合并两个有序链表也很容易。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* l = head;</span><br><span class="line">    ListNode* r = head;</span><br><span class="line">    <span class="keyword">while</span>(r-&gt;next &amp;&amp; r-&gt;next-&gt;next)&#123;</span><br><span class="line">        l = l-&gt;next;</span><br><span class="line">        r = r-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mid = l-&gt;next;</span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* first, ListNode* second)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (second == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    ListNode * head;</span><br><span class="line">    ListNode * pos;</span><br><span class="line">    <span class="keyword">if</span> (first-&gt;val &lt; second-&gt;val)&#123;</span><br><span class="line">        head = first;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = second;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pos = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pos-&gt;next = second;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (second == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pos-&gt;next = first;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (first-&gt;val &lt; second-&gt;val)&#123;</span><br><span class="line">            pos-&gt;next = first;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pos-&gt;next = second;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = pos-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>复制带随机指针的链表</p>
<ul>
<li>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</li>
<li>要求返回这个链表的深度拷贝。</li>
<li>用map记录已经碰到过的指针和它的拷贝，然后按序遍历链表就行了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; m;</span><br><span class="line">    RandomListNode* nhead = head;</span><br><span class="line">    RandomListNode* np = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">    m[head] = np;</span><br><span class="line">    <span class="keyword">while</span>(nhead)&#123;</span><br><span class="line">        RandomListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* random = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (nhead-&gt;next &amp;&amp; m[nhead-&gt;next] == <span class="number">0</span>)&#123;</span><br><span class="line">            next = <span class="keyword">new</span> RandomListNode(nhead-&gt;next-&gt;label);</span><br><span class="line">            m[nhead-&gt;next] = next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            next = m[nhead-&gt;next];</span><br><span class="line">        <span class="keyword">if</span> (nhead-&gt;random &amp;&amp; m[nhead-&gt;random] == <span class="number">0</span>)&#123;</span><br><span class="line">            random = <span class="keyword">new</span> RandomListNode(nhead-&gt;random-&gt;label);</span><br><span class="line">            m[nhead-&gt;random] = random;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            random = m[nhead-&gt;random];</span><br><span class="line">        nhead = nhead-&gt;next;</span><br><span class="line">        np-&gt;next = next;</span><br><span class="line">        np-&gt;random = random;</span><br><span class="line">        np = np-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="树和图"><a href="#树和图" class="headerlink" title="树和图"></a>树和图</h2><ol>
<li><p>被围绕的区域</p>
<ul>
<li>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</li>
<li>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</li>
<li>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</li>
<li>考虑用DFS，然后需要记录中间状态，为了节约空间，直接修改原数组，将条件相关的字母改为其他标识，最后再遍历修改成最终结果。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.size() &lt; <span class="number">1</span> || board[<span class="number">0</span>].size() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = board.size(), y = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">        helper(board, i, <span class="number">0</span>);</span><br><span class="line">        helper(board, i, y<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;y;i++)&#123;</span><br><span class="line">        helper(board, <span class="number">0</span>, i);</span><br><span class="line">        helper(board, x<span class="number">-1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'1'</span>)</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board.size() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board[<span class="number">0</span>].size() &amp;&amp; board[x][y] == <span class="string">'O'</span>)&#123;</span><br><span class="line">        board[x][y] = <span class="string">'1'</span>;</span><br><span class="line">        helper(board, x + <span class="number">1</span>, y);</span><br><span class="line">        helper(board, x, y + <span class="number">1</span>);</span><br><span class="line">        helper(board, x - <span class="number">1</span>, y);</span><br><span class="line">        helper(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单词接龙</p>
<ul>
<li>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
<li>非常经典的一个题，以前也做过，这里运用到了很多小技巧。’a’到’z’的递增，swap方法体现广搜层级，vector转换set提高查询效率，循环体前后修改值（做一个递归办法）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordDic</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (wordDic.count(endWord) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    wordDic.erase(beginWord);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; qt;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    q.push(beginWord);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> word = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (word == endWord)</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : word)&#123;</span><br><span class="line">                <span class="keyword">char</span> temp = c;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> t=<span class="string">'a'</span>;t&lt;=<span class="string">'z'</span>;t++)&#123;</span><br><span class="line">                    c = t;</span><br><span class="line">                    <span class="keyword">if</span> (wordDic.count(word) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        wordDic.erase(word);</span><br><span class="line">                        qt.push(word);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (!qt.empty())</span><br><span class="line">            q.swap(qt);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>计算右侧小于当前元素的个数</p>
<ul>
<li>给定一个整型数组 nums，按要求返回一个新的 counts 数组。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于nums[i] 的元素的数量。</li>
<li>从右边开始，一个个加入新队列排序，按照所在位置得出结果。</li>
<li>这题看别人的代码学到了两个二分搜索的函数lower_bound(begin, end, num), upper_bound(begin, end, num)。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    vector&lt;int&gt; res(n,0),tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it=lower_bound(tmp.begin(),tmp.end(),nums[i]);</span><br><span class="line">        res[i]=it-tmp.begin();</span><br><span class="line">        tmp.insert(it,nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉树的最近公共祖先</p>
<ul>
<li>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</li>
<li>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</li>
<li>递归，太久没写递归程序，脑子瓦特了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>课程表</p>
<ul>
<li>现在你总共有 n 门课需要选，记为 0 到 n-1。</li>
<li>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</li>
<li>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</li>
<li>将课看作点，先修关系看作边，形成一个有向图。问题等价于这个有向图是否有环，求环可以使用dfs，记录正在visit的点。</li>
<li>实际上这个dfs稍微改改就是在做拓扑排序。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visit</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * v = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; [numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; p : prerequisites)</span><br><span class="line">        v[p.first].push_back(p.second);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i, v, visit))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    visit[n] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : v[n])&#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[c] == <span class="number">-1</span> || (visit[c] == <span class="number">0</span> &amp;&amp; !dfs(c, v, visit)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>课程表2</p>
<ul>
<li>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</li>
<li>记录下拓扑排序就可以了。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visit</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topo;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * v = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; [numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; p : prerequisites)</span><br><span class="line">        v[p.first].push_back(p.second);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfs(i, v, visit, topo))</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> topo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; * v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; visit, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;topo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visit[n] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    visit[n] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : v[n])&#123;</span><br><span class="line">        <span class="keyword">if</span> (visit[c] == <span class="number">-1</span> || (visit[c] == <span class="number">0</span> &amp;&amp; !dfs(c, v, visit, topo)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[n] = <span class="number">1</span>;</span><br><span class="line">    topo.push_back(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉树中的最大路径和</p>
<ul>
<li>给定一个非空二叉树，返回其最大路径和。</li>
<li>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</li>
<li>后序遍历递归，通过引用传参记录最大值，返回的则是经过一点的单线最大值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = INT_MIN;</span><br><span class="line">    helper(root, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span> &amp; m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = max(helper(node-&gt;left, m), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> rt = max(helper(node-&gt;right, m), <span class="number">0</span>);</span><br><span class="line">    m = max(m, lt + rt + node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> max(lt, rt) + node-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ol>
<li><p>正则表达式匹配</p>
<ul>
<li>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</li>
<li>‘.’ 匹配任意单个字符。</li>
<li>‘*’ 匹配零个或多个前面的元素。</li>
<li>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</li>
<li>简单直接的回溯，时间复杂度直接爆炸。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp; s, <span class="built_in">string</span> &amp; p, <span class="keyword">int</span> spos, <span class="keyword">int</span> ppos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (spos &lt; s.size() &amp;&amp; ppos &lt; p.size() &amp;&amp; (s[spos] == p[ppos] || p[ppos] == <span class="string">'.'</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (ppos+<span class="number">1</span> &lt; p.size() &amp;&amp; p[ppos+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">return</span> (helper(s, p, spos+<span class="number">1</span>, ppos + <span class="number">2</span>) || helper(s, p, spos, ppos+<span class="number">2</span>) ||helper(s, p, spos+<span class="number">1</span>, ppos));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(s, p, spos+<span class="number">1</span>, ppos+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ppos+<span class="number">1</span> &lt; p.size() &amp;&amp; p[ppos+<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(s, p, spos, ppos+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spos == s.size() &amp;&amp; ppos == p.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>回溯的问题在于，没有很好利用前面匹配的信息，而是不断试错，可以用二维数组记录一下尝试过的pos值，剪枝。</li>
<li>自底向上的动态规划。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Remove Invalid Parentheses</p>
<ul>
<li>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</li>
<li>说明: 输入可能包含了除 ( 和 ) 以外的字符。</li>
<li>BFS尝试所有结果，速度较慢。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">string</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (m[t] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isValid(t))&#123;</span><br><span class="line">                m[t] = <span class="number">1</span>;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                m[t] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t.size();j++)&#123;</span><br><span class="line">                    q.push(t.substr(<span class="number">0</span>, j) + t.substr(j + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="string">'('</span>) ++cnt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == <span class="string">')'</span> &amp;&amp; --cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>高票算法。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">removeInvalidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    dfs(s,<span class="string">')'</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">char</span> ch,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,cnt =<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span> || s[i] == <span class="string">'('</span>)s[i] == ch ? cnt++:cnt--;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=last;j&lt;=i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] ==ch &amp;&amp;(j == last || s[j<span class="number">-1</span>] != ch))</span><br><span class="line">                  dfs(s.substr(<span class="number">0</span>,j)+s.substr(j+<span class="number">1</span>),ch,j);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ; <span class="comment">//这里的return是第一个for里面的</span></span><br><span class="line">    &#125;</span><br><span class="line">    reverse(s.begin(),s.end());</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">')'</span>)<span class="keyword">return</span> dfs(s,<span class="string">'('</span>,<span class="number">0</span>);</span><br><span class="line">    res.push_back(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单词拆分</p>
<ul>
<li>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</li>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
<li>这里本来想着用二维组来记录，但是实际上一维组就够了，c[i]代表从0到i的子串是否可分。</li>
<li>c[i] = if(c[j] &amp;&amp; str(i,j) exist)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">c</span><span class="params">(s.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c[j] &amp;&amp; find(wordDict.begin(), wordDict.end(), s.substr(j,i-j)) != wordDict.end())&#123;</span><br><span class="line">                c[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="排序和搜索"><a href="#排序和搜索" class="headerlink" title="排序和搜索"></a>排序和搜索</h2><ol>
<li>两个排序数组的中位数<ul>
<li>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</li>
<li>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</li>
<li>你可以假设 nums1 和 nums2 不同时为空。</li>
<li>这题思路是很清晰的，但是令人烦恼的是如何优雅处理边界条件，还有代码可读性。</li>
<li>下面的代码是抄了<a href="https://www.cnblogs.com/voidsky/p/5373982.html" target="_blank" rel="noopener">别人的</a>。</li>
<li>比起我自己写的要好很多，一个是虚拟数组长度，另一个是越界的处理，因为最终取值会通过min和max，所以越界的用INT_MIN和INT_MAX代替，这样也反应，有时候不能直接记数组的位置，记值和虚拟数组位置对于奇偶性、越界等问题都解决的很漂亮。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = nums1.size();</span><br><span class="line"><span class="keyword">int</span> m = nums2.size();</span><br><span class="line"><span class="keyword">if</span>(n &gt; m)   <span class="comment">//保证数组1一定最短</span></span><br><span class="line">    <span class="keyword">return</span> findMedianSortedArrays(nums2,nums1);</span><br><span class="line"><span class="keyword">int</span> L1,L2,R1,R2,c1,c2,lo = <span class="number">0</span>, hi = <span class="number">2</span>*n;  <span class="comment">//我们目前是虚拟加了'#'所以数组1是2*n+1长度</span></span><br><span class="line"><span class="keyword">while</span>(lo &lt;= hi)   <span class="comment">//二分</span></span><br><span class="line">&#123;</span><br><span class="line">    c1 = (lo+hi)/<span class="number">2</span>;  <span class="comment">//c1是二分的结果</span></span><br><span class="line">    c2 = m+n- c1;</span><br><span class="line">    L1 = (c1 == <span class="number">0</span>)?INT_MIN:nums1[(c1<span class="number">-1</span>)/<span class="number">2</span>];   <span class="comment">//map to original element</span></span><br><span class="line">    R1 = (c1 == <span class="number">2</span>*n)?INT_MAX:nums1[c1/<span class="number">2</span>];</span><br><span class="line">    L2 = (c2 == <span class="number">0</span>)?INT_MIN:nums2[(c2<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">    R2 = (c2 == <span class="number">2</span>*m)?INT_MAX:nums2[c2/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(L1 &gt; R2)</span><br><span class="line">        hi = c1<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L2 &gt; R1)</span><br><span class="line">        lo = c1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (max(L1,L2)+ min(R1,R2))/<span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol>
<li>最大数<ul>
<li>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</li>
<li>重点是找到那个排序规则，起初我以为，先把数组都变成字符串，然后按序比较，如果都相同则长度较短的放前面，后来发现有问题。比如3和34，显然343 &gt; 334，所以这个规则不成立。</li>
<li>蠢的不行，为什么没想到用结果去比，直接比ab和ba两种拼接谁更大就好了。这其实也说明一个问题，就是贪心在这里是可行的，局部最优和整体最优是等价的。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; num : nums)</span><br><span class="line">        vs.push_back(to_string(num));</span><br><span class="line">    sort(vs.begin(), vs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)&#123;<span class="keyword">return</span> (a+b) &gt; (b+a);&#125;);</span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; s : vs)</span><br><span class="line">        r += s;</span><br><span class="line">    <span class="keyword">return</span> (r.size() &lt; <span class="number">1</span> || r[<span class="number">0</span>] == <span class="string">'0'</span>) ? <span class="string">"0"</span> : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>接雨水<ul>
<li>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li>
<li>比较自然的想法，从左到右遍历时，先找到一个位置a，然后如果出现了不小于a高度的位置b，很显然，a、b位置之间的雨水就已经决定了，后面可以从b开始往右找。</li>
<li>但上述有一个问题，就是如果往右一直找不到更高的，那么算法就没法结束，而且也不代表就不能积水，比如4、2、3这样的排列。此时a一定是最高的那个位置，换成从右往左走就一定能找到。</li>
<li>最后代码就变成从左往右遍历，当没找到更高的，算法无法结束时，从右往左遍历。</li>
<li>也可以先遍历一次找到最高的位置，然后从两端往中间走。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=height.size();</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[j] &gt;= height[i])&#123;</span><br><span class="line">                    temp += height[i] * (j - i - <span class="number">1</span>); </span><br><span class="line">                    i = j<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    temp -= min(height[j], height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += max(temp, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m=n<span class="number">-1</span>;m&gt;=i;m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height[m] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=m<span class="number">-1</span>;k&gt;=i;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (height[k] &gt;= height[m])&#123;</span><br><span class="line">                    temp += height[m] * (m - k - <span class="number">1</span>); </span><br><span class="line">                    m = k+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    temp -= min(height[m], height[k]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += max(temp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li><p>乘积最大子序列</p>
<ul>
<li>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</li>
<li>一维的数据结构就足够，但比较坑的是，存在负数，导致前面小的值，再次乘一个负数，可能变成最大值，所以不能只记一个最大值，还要记住最小负数。</li>
<li>因为只用看上一位的结果，所以可以优化成两个整型变量。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> posMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> negMax = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempPosMax = posMax;</span><br><span class="line">        posMax = max(nums[i],max(nums[i] * tempPosMax, nums[i] * negMax));</span><br><span class="line">        negMax = min(nums[i],min(nums[i] * negMax, nums[i] * tempPosMax));</span><br><span class="line">        r = max(r, posMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>完全平方数</p>
<ul>
<li>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</li>
<li>虽然这题放在动态规划里，但不得不说，数学是真的强，这个爆炸快捷的四平方定理。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>) n /= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a * a &lt;= n; ++a) &#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">sqrt</span>(n - a * a);</span><br><span class="line">        <span class="keyword">if</span> (a * a + b * b == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> !!a + !!b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>linux capability， SGID， /dev/mem杂谈</title>
    <url>/2019/09/28/linux-capability-SGID-dev-mem%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>在linux的世界里，权限是一件复杂又重要的事情。这次从<code>dmidecode</code>命令的执行引出对权限的控制。</p>
<a id="more"></a>

<h2 id="Dmidecode"><a href="#Dmidecode" class="headerlink" title="Dmidecode"></a>Dmidecode</h2><ul>
<li>在许多linux发行版中都有的一个软件，用来查看硬件信息。</li>
<li>DMI（Desktop Management Interface，DMI）就是帮助收集电脑系统信息的管理系统，DMI信息的收集必须在严格遵照SMBIOS规范的前提下进行。SMBIOS（System Management BIOS）是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范。SMBIOS和DMI是由行业指导机构Desktop Management Task Force(DMTF)起草的开放性的技术标准，其中DMI设计适用于任何的平台和操作系统。</li>
<li>首先会从<code>/sys/firmware/dmi/tables/smbios_entry_point</code>，<code>/sys/firmware/dmi/tables/DMI</code>读取相应信息，如果没有这两个文件，则从<code>/dev/mem</code>读取。</li>
</ul>
<h2 id="dev-mem"><a href="#dev-mem" class="headerlink" title="/dev/mem"></a>/dev/mem</h2><ul>
<li>该文件可以映射整个处理器的地址空间。除了内存，还有外设的IO空间，以及其他总线映射过来的mem（如PCI）。通常用<code>mmap</code>操作这个文件。</li>
<li>所以可借此实现用户态驱动程序。</li>
<li>对此文件进行操作需要<code>cap_sys_rawio</code>权限（实际操作中这个cap不够，应该是误传）。</li>
</ul>
<h2 id="SUID，SGID"><a href="#SUID，SGID" class="headerlink" title="SUID，SGID"></a>SUID，SGID</h2><ul>
<li>linux下的特殊权限位。</li>
<li>当可执行文件被设置了这两个权限位，文件被执行的时候，会相应拥有owner、owner group的权限。</li>
<li>参见《UNIX环境高级编程》阅读笔记。</li>
</ul>
<h2 id="capability"><a href="#capability" class="headerlink" title="capability"></a>capability</h2><ul>
<li>linux将root用户的权限，切分成更小的组成。</li>
<li>cap可以赋给某个进程或某个可执行文件。</li>
<li>cap有三个位图，inheritable(I)，permitted(P)和effective(E)，对应进程描述符task_struct(include/linux/sched.h)里面的cap_effective， cap_inheritable，cap_permitted，所以我们可以查看/proc/PID/status来查看进程的能力。<ul>
<li>cap_effective:当一个进程要进行某个特权操作时，操作系统会检查cap_effective的对应位是否有效，而不再是检查进程的有效UID是否为0。</li>
<li>cap_permitted:表示进程能够使用的能力，在cap_permitted中可以包含cap_effective中没有的能力，这些能力是被进程自己临时放弃的，也可以说cap_effective是cap_permitted的一个子集。</li>
<li>cap_inheritable: 表示能够被当前进程执行的程序继承的能力。</li>
</ul>
</li>
</ul>
<h2 id="让普通用户也能执行dmidecode命令"><a href="#让普通用户也能执行dmidecode命令" class="headerlink" title="让普通用户也能执行dmidecode命令"></a>让普通用户也能执行dmidecode命令</h2><ul>
<li>显然，有至少三个办法。<ul>
<li>改变<code>/sys/firmware/dmi/tables/*</code>的可读权限。<ul>
<li><code>sudo chmod 444 /sys/firmware/dmi/tables/*</code></li>
</ul>
</li>
<li>给dmidecode设置<code>SUID</code>。<ul>
<li><code>sudo chmod u+s /usr/sbin/dmidecode</code></li>
</ul>
</li>
<li>给dmidecode增加capability。<ul>
<li><code>sudo setcap cap_dac_override=eip /usr/sbin/dmidecode</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/fanweisheng/p/11108673.html" target="_blank" rel="noopener">LINUX设置SUID，SGID，Stick bit</a></li>
<li><a href="https://unix.stackexchange.com/questions/249734/reconstructing-dmidecode-binary-dump-from-sys-firmware-dmi-tables" target="_blank" rel="noopener">Reconstructing dmidecode binary dump from /sys/firmware/dmi/tables</a></li>
<li><a href="https://www.cnblogs.com/zoulongbin/p/10523533.html" target="_blank" rel="noopener">Linux 系统文件3位特殊权限位说明</a></li>
<li><a href="https://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html" target="_blank" rel="noopener">Linux的capability深入分析</a></li>
<li><a href="https://blog.csdn.net/skyflying2012/article/details/47611399" target="_blank" rel="noopener">/dev/mem可没那么简单</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>minikube/helm/istio初体验</title>
    <url>/2018/08/21/minikube-helm-istio/</url>
    <content><![CDATA[<p>记录了使用minikube建立一个k8s集群，安装helm，istio等过程。</p>
<a id="more"></a>

<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p><a href="https://kubernetes.io" target="_blank" rel="noopener">kubernetes</a>，一个开源的容器集群管理系统，它提供资源调度，部署运行，服务发现，扩容缩容等功能，它并不依赖于docker，是一种通用的容器化应用管理方案。抽象概念和插件机制，k8s功能十分丰富、灵活。k8s由几个核心服务组成，包括apiserver，manager，scheduler，proxy，kublet，分布式存储etcd等。  </p>
<p><a href="https://helm.sh" target="_blank" rel="noopener">Helm</a>，k8s的包管理工具，帮助发现、共享和使用k8s构建的应用，kubctl是对于单个资源的操作，没有真正将一些资源作为整体去编排，helm提供了这方面的解决方案。  </p>
<p><a href="https://istio.io" target="_blank" rel="noopener">Istio</a>，Service Mesh的一个具体实现，北京时间2018.08.01零点发布1.0版本，宣布生产环境可用。Service Mesh被誉为下一代微服务架构。</p>
<h2 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h2><ol>
<li><p>minikube是在本机上启动一个虚拟机，虚拟机内再运行docker守护进程，运行k8s相关服务镜像，在本机上启动一个全局的代理（比如Proxifier），便可以直接让虚拟机的请求被转发，从而拉取到谷歌仓库的镜像。（最省事也最有效的办法，因为基础镜像虽然可以很容易地在别的仓库找到，但后面使用helm、istio等各种额外服务时，找镜像相当劳累）</p>
</li>
<li><p>使用修改了minikube代码，更改默认镜像配置的minikube版本，这个方案能够将基础服务启动起来。同样，存在版本可能落后，扩展服务还是不易等问题。（<a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">云栖社区提供的基于阿里镜像库的minikube安装</a>)</p>
</li>
<li><p>仅使用终端代理，可以让minikube运行，然后集群会显示基础镜像拉取失败，这时候minikube ssh到虚拟机，使用docker pull在阿里仓库的镜像，打上tag（tag和需要的镜像名相同），从而让docker使用本地镜像替代重新下载。（个人觉得tag太长，版本号也不容易确定，不是个好办法）</p>
</li>
</ol>
<h2 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h2><ol>
<li><p>helm安装没有什么坑，主要还是很多可用的chart库都需要代理，而国内几乎没有可用的chart仓库。</p>
</li>
<li><p>helm提供了安装istio的chart，并且可以集中配置istio。</p>
</li>
</ol>
<h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><ol>
<li><p>1.0新版在安装上也没什么问题，只是在minikube上部署istio，需要给minikube分配较大的内存（4g以上，推荐8g）以及cpu核数（推荐4个），同时，增加配置参数。（<a href="https://istio.io/docs/setup/kubernetes/platform-setup/minikube/" target="_blank" rel="noopener">Minikube Istio Setup</a>）</p>
</li>
<li><p>安装</p>
<ul>
<li><p>通过helm安装则可以通过命令参数–set来修改配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">helm install install/kubernetes/helm/istio  --name istio --namespace istio-system --<span class="built_in">set</span> gateways.istio-ingressgateway.type=NodePort --<span class="built_in">set</span> gateways.istio-egressgateway.type=NodePort</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接修改istio-demo.yaml，gateway服务的port方式改为nodeport。  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl apply -f install/kubernetes/istio-demo.yaml</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>demo已经内置了prometheus、grafana、jaeger等服务，可通过端口转发的方式访问。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl port-forward -n istio-system $(kubectl get pod -n istio-system -l app=jaeger -o jsonpath=<span class="string">'&#123;.items[0].metadata.name&#125;'</span>) 16686:16686 &amp;  </span><br><span class="line"></span><br><span class="line">kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath=<span class="string">'&#123;.items[0].metadata.name&#125;'</span>) 9090:9090 &amp;  </span><br><span class="line"></span><br><span class="line">kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath=<span class="string">'&#123;.items[0].metadata.name&#125;'</span>) 3000:3000 &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行官方例子bookinfo方便看见监控的变化。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl label namespace default istio-injection=enabled  </span><br><span class="line"></span><br><span class="line">kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml  </span><br><span class="line"></span><br><span class="line">kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>CloudNative</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>helm</tag>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title>nmcli、hostnamectl等网络配置实战</title>
    <url>/2019/05/11/nmcli%E3%80%81hostnamectl%E7%AD%89%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>还在用ifconfig？简直是菜到爆。ip、nmcli了解一下。</p>
<a id="more"></a>

<h2 id="Ip"><a href="#Ip" class="headerlink" title="Ip"></a>Ip</h2><ul>
<li>ip命令是万能的，能查看addr，能查看veth，还有namespace，各种网络设备都可以，我大概只用到这么一些。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>

<h2 id="nmcli"><a href="#nmcli" class="headerlink" title="nmcli"></a>nmcli</h2><ul>
<li>软件怎样利用多张网卡做负载均衡？做主从备用？一切尽在bond。</li>
<li>目前还不清楚怎么实现的。</li>
<li>使用nmcli配置bond，bond还有一个妙用是统一不同机器的网卡名称，这样可以看起来都是同样的网卡。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli con add type bond ifname em3 ip4 192.168.2.133/24 gw4 192.168.2.1 ipv4.dns 202.120.2.101</span><br><span class="line">nmcli con add type bond-slave ifname eno1 master em3</span><br><span class="line">nmcli con up bond-slave-eno1</span><br><span class="line"></span><br><span class="line">nmcli con add type bond ifname em1 ip4 10.1.0.134/16</span><br><span class="line">nmcli con add type bond-slave ifname enp59s0f0 master em1</span><br><span class="line">nmcli con up bond-slave-enp59s0f0</span><br></pre></td></tr></table></figure>

<h2 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h2><ul>
<li>直接修改<code>/etc/hostname</code>，发现ansible读取facts时，没有读取到，原因未明。</li>
<li>改用命令设置。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname Linuxprobe</span><br></pre></td></tr></table></figure>

<h2 id="ifcfg"><a href="#ifcfg" class="headerlink" title="ifcfg"></a>ifcfg</h2><ul>
<li>关于网卡配置，没有连路由器的网段，不用填dns和gateway，不然会导致上不了网且ssh的速度也变慢。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;192.168.2.100</span><br><span class="line">PREFIX&#x3D;24</span><br><span class="line">GATEWAY&#x3D;192.168.2.1</span><br><span class="line">DNS1&#x3D;202.120.2.101</span><br></pre></td></tr></table></figure>

<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ul>
<li>配置一个tcp转发，访问horizon。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream stream_backend &#123;</span><br><span class="line">         server 10.1.0.254:80;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen                8080;</span><br><span class="line">        proxy_pass            stream_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://phoenixnap.com/kb/how-to-set-or-change-a-hostname-in-centos-7" target="_blank" rel="noopener">How To Set Or Change A Hostname In CentOS 7</a></li>
<li><a href="https://blog.csdn.net/ha_weii/article/details/80377268" target="_blank" rel="noopener">Linux基于rhel的高级网络部署 配置bond网络</a></li>
<li><a href="https://blog.51cto.com/13438667/2090710" target="_blank" rel="noopener">nmcli命令使用以及网卡绑定bond</a></li>
<li><a href="https://blog.csdn.net/linuxnews/article/details/51112022" target="_blank" rel="noopener">CentOS 7 中 hostnamectl 的使用</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>openstack单机多网卡</title>
    <url>/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/</url>
    <content><![CDATA[<p>很久以前，搭建好openstack的时候，惊奇地发现，<br>一个虚拟机可以绑定很多个interface，或者说port。</p>
<p><img src="/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/C9104E0D-4083-451E-B470-0F9A97189123.png" alt="图片加载失败"></p>
<p>奇怪的事情是，如果在创建虚拟机时，绑定多个接口，初始化出来的虚拟机，将会无法连接。<br>也就是说，多个接口并没有成功初始化。</p>
<p><img src="/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/WX20200326-172148@2x.png" alt="图片加载失败"></p>
<p>绑定多个interface，在虚拟机看来就是插入了多张网卡。<br>观察机器的启动日志，发现初始化时只会启动一张网卡，也就是顺序最靠前的网卡，<br>但是哪张最靠前，是随机的。所以，通常是因为两张卡中只有一张是连接到外部网络的，<br>如果第一张初始化的就是内部网络的，就没法连接到机器上了。</p>
<p>这一点应该可以通过修改镜像里的初始化操作来让他多个卡都初始化，<br>这里先不谈如何全自动，讨论一下如何手动操作。</p>
<p>首先，按正常的操作，选取一个网络加入，创建虚拟机。<br>这时能够正常ssh到机器上。</p>
<p>以ubuntu为例。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/network/interfaces</span></span><br><span class="line"><span class="comment"># This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="comment"># and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source interfaces</span></span><br><span class="line"><span class="comment"># Please check /etc/network/interfaces.d before changing this file</span></span><br><span class="line"><span class="comment"># as interfaces may have been defined in /etc/network/interfaces.d</span></span><br><span class="line"><span class="comment"># See LP: #1262951</span></span><br><span class="line"><span class="built_in">source</span> /etc/network/interfaces.d/*.cfg</span><br></pre></td></tr></table></figure>

<p>而<code>interfaces.d</code>里只有一个文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interfaces.d/50-cloud-init.cfg</span></span><br><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens3</span><br><span class="line">iface ens3 inet dhcp</span><br></pre></td></tr></table></figure>

<p>这里定义了网卡的配置，通常来说，<br>一个接口要生效，需要配置自身的IP地址，DNS Server，接入的子网掩码。<br>像这个文件里只写了一行，dhcp，因为dhcp协议会通过广播去请求这些数据，<br>dhcp server会告诉我们应该用什么ip、dns。</p>
<p>接下来，给机器绑定更多的接口。</p>
<p><img src="/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/WX20200326-173043@2x.png" alt="图片加载失败"></p>
<p>然后在连接到机器上，用<code>ip addr</code>命令查看。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo ip addr</span><br><span class="line"></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether fa:16:3e:33:0f:58 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.54/16 brd 10.0.255.255 scope global ens3</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f816:3eff:fe33:f58/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: ens7: &lt;BROADCAST,MULTICAST&gt; mtu 1450 qdisc pfifo_fast state DOWN group default qlen 1000</span><br><span class="line">    link/ether fa:16:3e:ca:fb:f5 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>可以看到，多了一个ens7。<br>使用<code>ifup ens7</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ifup ens7</span><br><span class="line"></span><br><span class="line">Unknown interface ens7</span><br></pre></td></tr></table></figure>

<p>现在还无法启动这个interface，因为还没有配置。<br>转到<code>/etc/network/interfaces</code>，添加<code>ens7</code>的配置。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/network/interfaces.d/50-cloud-init.cfg</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens3</span><br><span class="line">iface ens3 inet dhcp</span><br><span class="line"></span><br><span class="line">auto ens7</span><br><span class="line">iface ens7 inet dhcp</span><br></pre></td></tr></table></figure>

<p>然后，<code>sudo ifup ens7</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Internet Systems Consortium DHCP Client 4.3.3</span><br><span class="line">Copyright 2004-2015 Internet Systems Consortium.</span><br><span class="line">All rights reserved.</span><br><span class="line">For info, please visit https://www.isc.org/software/dhcp/</span><br><span class="line"></span><br><span class="line">Listening on LPF/ens7/fa:16:3e:ca:fb:f5</span><br><span class="line">Sending on   LPF/ens7/fa:16:3e:ca:fb:f5</span><br><span class="line">Sending on   Socket/fallback</span><br><span class="line">DHCPDISCOVER on ens7 to 255.255.255.255 port 67 interval 3 (xid=0x8924d41)</span><br><span class="line">DHCPREQUEST of 10.1.0.8 on ens7 to 255.255.255.255 port 67 (xid=0x414d9208)</span><br><span class="line">DHCPOFFER of 10.1.0.8 from 10.1.0.2</span><br><span class="line">DHCPACK of 10.1.0.8 from 10.1.0.2</span><br><span class="line">bound to 10.1.0.8 -- renewal <span class="keyword">in</span> 34076 seconds.</span><br></pre></td></tr></table></figure>

<p>配置完毕，现在就拥有了两个网卡。</p>
<p>如果和一个网络建立多个interfaces，就相当于有多根网线插入到一个交换机上。<br>然后将其中一个网卡交给dpdk管理，监听另一个网卡，就可以实现一个机器测试dpdk功能了。</p>
<p>需要注意的是，关闭掉interface的security功能，避免dpdk编程时，一些包被openstack丢弃。</p>
<p><img src="/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/WX20200326-173854@2x.png" alt="图片加载失败"></p>
<p><img src="/2020/03/26/openstack%E5%8D%95%E6%9C%BA%E5%A4%9A%E7%BD%91%E5%8D%A1/1585215611440.jpg" alt="图片加载失败"></p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>pxe+tftp+dhcp无人值守安装Centos7</title>
    <url>/2019/04/27/pxe-tftp-dhcp%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AE%89%E8%A3%85Centos7/</url>
    <content><![CDATA[<p>尝试自动装机，同时重点了解pxe过程。</p>
<a id="more"></a>

<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h3><ul>
<li>Preboot Execute Environment, supported by Intel.</li>
<li>Booting in this mode, client gets it’s own ip and tftp server ip by DHCP.</li>
<li>Fetch <code>pxelinux.0</code> from tftp server and then follow it.</li>
<li><code>pxelinux.cfg</code> contains serveral menus recording booting process.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default menu.c32</span><br><span class="line">#prompt 0</span><br><span class="line">timout 30</span><br><span class="line">MENU TITLE LinuxTech PXE Menu</span><br><span class="line">LABEL centos7_64</span><br><span class="line">MENU LABEL CentOS 7_x64</span><br><span class="line">KERNEL vmlinuz</span><br><span class="line">APPEND initrd&#x3D;initrd.img ks&#x3D;http:&#x2F;&#x2F;xx.xx.xx.xx&#x2F;ks.cfg</span><br></pre></td></tr></table></figure>

<ul>
<li>Here we only have one item that means installing operating system by kickstart.</li>
</ul>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><ul>
<li>It’s easy to start a DHCP server, but here we need to configure a <code>next-server</code> which locate the tftps server.</li>
<li><code>yum -y install dhcp</code></li>
<li><code>/etc/dhcp/dhcpd.conf</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DHCP Server Configuration file.</span><br><span class="line"></span><br><span class="line">ddns-update-style interim;</span><br><span class="line">ignore client-updates;</span><br><span class="line">authoritative;</span><br><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">allow unknown-clients;</span><br><span class="line"></span><br><span class="line"># internal subnet for my DHCP Server</span><br><span class="line">subnet 172.16.35.0 netmask 255.255.255.0 &#123;</span><br><span class="line">range 172.16.35.100 172.16.35.200;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line"># IP of PXE Server</span><br><span class="line">next-server 172.168.35.10;</span><br><span class="line">filename &quot;pxelinux.0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tftp-Server"><a href="#Tftp-Server" class="headerlink" title="Tftp Server"></a>Tftp Server</h3><ul>
<li>Trivial File Transfer Protocol, Port 69.</li>
<li>We transfer <code>pxelinux.cfg</code> and <code>networkboot/*</code> through <code>tftp</code>.</li>
</ul>
<h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum groupinstall "X Window System"</span><br><span class="line">yum groupinstall "GNOME Desktop"</span><br><span class="line">startx</span><br></pre></td></tr></table></figure>

<h3 id="Kick-Start"><a href="#Kick-Start" class="headerlink" title="Kick Start"></a>Kick Start</h3><ul>
<li>Make a <code>ks.cfg</code> by desktop ui.</li>
<li>Config<ul>
<li>Root password</li>
<li>Network</li>
<li>Disk Parition</li>
</ul>
</li>
</ul>
<h3 id="FTP-and-HTTP"><a href="#FTP-and-HTTP" class="headerlink" title="FTP and HTTP"></a>FTP and HTTP</h3><ul>
<li>Using FTP or HTTP to supply <code>.iso</code> to clients.</li>
<li>FTP<ul>
<li>root directory: <code>/var/ftp/</code></li>
<li>I found <code>/var/ftp/pub</code> had a special authority, read-only file is hidden in that direcotry.</li>
<li>We can use other path. <code>/var/ftp/centos</code></li>
</ul>
</li>
<li>HTTP<ul>
<li>root directory: <code>/var/www/html/</code></li>
<li><code>mount Centos7.iso /var/www/html/centos</code></li>
</ul>
</li>
</ul>
<h3 id="Firewall"><a href="#Firewall" class="headerlink" title="Firewall"></a>Firewall</h3><ul>
<li>Enable ports<ul>
<li>69</li>
<li>4011</li>
</ul>
</li>
<li>Enabel services<ul>
<li>dhcp</li>
<li>ftp</li>
<li>http</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-service=ftp --permanent</span><br><span class="line">firewall-cmd --add-service=dhcp --permanent</span><br><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">firewall-cmd --add-port=69/tcp --permanent</span><br><span class="line">firewall-cmd --add-port=69/udp --permanent</span><br><span class="line">firewall-cmd --add-port=4011/udp --permanent</span><br></pre></td></tr></table></figure>

<h3 id="Start-Service"><a href="#Start-Service" class="headerlink" title="Start Service"></a>Start Service</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start xinetd</span><br><span class="line">systemctl start dhcpd</span><br><span class="line">systemctl start vsftpd</span><br><span class="line">systemctl start httpd</span><br><span class="line">systemctl start tftp</span><br></pre></td></tr></table></figure>

<h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><ul>
<li>Memory<ul>
<li>I recommend that the client(not installer) has more than 2GB memory.</li>
<li>When using VMware to simulate, 1GB memory traps in trouble.</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://blog.csdn.net/u012319493/article/details/82822954" target="_blank" rel="noopener">趣谈网络协议—DHCP与PXE：IP是怎么来的，又是怎么没的？</a></li>
<li><a href>Kickstart.cfg</a></li>
<li><a href="https://blog.csdn.net/cx55887/article/details/82858100" target="_blank" rel="noopener">基于pxe+dhcp+ks实现自动安装系统</a></li>
<li><a href="https://www.cnblogs.com/mchina/p/centos-pxe-kickstart-auto-install-os.html" target="_blank" rel="noopener">CentOS 6.4下PXE+Kickstart无人值守安装操作系统</a></li>
<li><a href="https://www.linuxtechi.com/configure-pxe-installation-server-centos-7/" target="_blank" rel="noopener">Configure PXE (Network Boot) installation Server on CentOS 7.x</a></li>
<li><a href="https://www.zhangfangzhou.cn/bad-superblock-on-devloop0.html" target="_blank" rel="noopener">curl (23) Failed writing body in pxe</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>rke部署kubernetes</title>
    <url>/2018/11/22/rke%E9%83%A8%E7%BD%B2kubernetes/</url>
    <content><![CDATA[<p>用rancher-rke部署kubernetes集群。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="准备机器"><a href="#准备机器" class="headerlink" title="准备机器"></a>准备机器</h2><p>我用的是四台CentOS，内网互联。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Server Version: 17.03.2-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: xfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: false</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 4ab9917febca54791c5f071a9d1f404867857fcc</span><br><span class="line">runc version: 54296cf40ad8143b62dbcaa1d90e520a2136ddfe</span><br><span class="line">init version: 949e6fa</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 3.10.0-514.26.2.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 32</span><br><span class="line">Total Memory: 125.6 GiB</span><br><span class="line">Name: s07.c1</span><br><span class="line">ID: UADY:ZUNA:J55Q:JOXR:CHIG:C3KT:RBM3:KQGU:VXN7:FBSA:KVYE:LNI5</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): false</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure>

<h3 id="配置目标机器"><a href="#配置目标机器" class="headerlink" title="配置目标机器"></a>配置目标机器</h3><ul>
<li>通过ansible user模块，创建新用户，并加入docker user group。</li>
<li>给用户目录下.ssh加入authorized_keys。</li>
<li>使用rancher给的docker安装脚本，安装17.03版本的docker（这里自己装或者yum装都可以，脚本其实也是通过yum安装）</li>
</ul>
<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><ul>
<li>在一台部署机下载rke binary，通过rke config创建一个cluster.yml。</li>
<li>此时遇到的问题是ssh连接失败，有以下几个原因：<ul>
<li>key不对，这部分重新检查就行。</li>
<li>centos不能用root用户，因为我创建了新用户，所以也不是这个问题。</li>
<li>sshd的版本要在7.4以上，此时我发现有两台目标机器ssh为6.3，所以需要升级ssh。</li>
</ul>
</li>
</ul>
<h3 id="sshd升级"><a href="#sshd升级" class="headerlink" title="sshd升级"></a>sshd升级</h3><ul>
<li><p>为了避免操作失败，导致机器失联，所以先安装telnet，启动telnet服务。</p>
</li>
<li><p>安装telnet可以通过ansible yum，具体包名为telnet-server和xinetd。</p>
</li>
<li><p>下载ssh的tarball</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-zlib --with-md5-passwords --with-tcp-wrappers</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里有一个问题，先将/etc/ssh mv到其他名字，然后install，才能变成全新版本。而且也有可能需要通过rpm删除之前的版本。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -e openssh --nodeps</span><br><span class="line">rpm -e openssh-clients --nodeps</span><br><span class="line">rpm -e openssh-server --nodeps</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着，有可能之前没有用systemctl管理，所以这时候需要将</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -p contrib/redhat/sshd.init /etc/init.d/sshd</span><br><span class="line">chmod +x /etc/init.d/sshd</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件，允许root登录，不改的话只是不能用密码登录，默认是允许密钥登录。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Centos6 openssh-7.6p1]# sed -i '/^#PermitRootLogin/s/#PermitRootLogin yes/PermitRootLogin yes/' /etc/ssh/sshd_config</span><br><span class="line">[root@Centos6 openssh-7.6p1]# cat /etc/ssh/sshd_config|grep RootLogin</span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后重启sshd。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h3><ul>
<li><p>修改了部署文件，重新开始的时候，可以先删除一下tmp，虽然并不是总需要。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/kubernetes/.tmp/</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候还可以重启一下docker。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在health check卡住，暂未解决。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FATA[0115] [controlPlane] Failed to bring up Control Plane: Failed to verify healthcheck: Service [kube-apiserver] is not healthy on host [192.168.2.16]. Response code: [401], response body: &#123;"kind":"Status","apiVersion":"v1","metadata":&#123;&#125;,"status":"Failure","message":"Unauthorized","reason":"Unauthorized","code":401&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rke remove。清除掉之前的key和残留，重新开始。 <a href="https://github.com/rancher/rke/issues/847" target="_blank" rel="noopener">issue#847</a></p>
</li>
</ul>
<h3 id="成功部署"><a href="#成功部署" class="headerlink" title="成功部署"></a>成功部署</h3><ul>
<li>总的来说，胆大心细，看一点点博客介绍，然后关注issue。</li>
</ul>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>rancher</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>the-design-and-evolution-of-cpp</title>
    <url>/2020/06/13/the-design-and-evolution-of-cpp/</url>
    <content><![CDATA[<h2 id="C-with-class"><a href="#C-with-class" class="headerlink" title="C with class"></a>C with class</h2><p>Class is a type</p>
<ul>
<li>Compile-time access control</li>
<li>static type checking</li>
<li>function definition under class, make a class more like an interface specification.</li>
<li>new/delete</li>
</ul>
<h2 id="C-Language-Design-Rules"><a href="#C-Language-Design-Rules" class="headerlink" title="C++ Language Design Rules"></a>C++ Language Design Rules</h2><p>Aims</p>
<ul>
<li>C++ makes programming more enjoyable for serious programmers</li>
<li>C++ is a general-purpose programming language that<ul>
<li>is a better C</li>
<li>supports data abstraction</li>
<li>supports object-oriented programming</li>
</ul>
</li>
</ul>
<p>General Rules</p>
<ul>
<li>C++’s evolution must be driven by real problems</li>
<li>Don’t get involved in a sterile quest for perfection</li>
<li>C++ must be useful now</li>
<li>Every feature must have a reasonably obvious implementation</li>
<li>Always provide a transition path</li>
<li>C++ is a language, not a complete system</li>
<li>Provide comprehensive support for each supported style</li>
<li>Don’t try to force people</li>
</ul>
<p>Design Support Rules</p>
<ul>
<li>Support sound design notions</li>
<li>Provider facilities for program organization</li>
<li>Say what you mean</li>
<li>All features must be affordable</li>
<li>It is more important to allow a useful feature than to prevent every misuse</li>
<li>Support composition of software from separately developed parts</li>
</ul>
<p>Language-Technical Rules</p>
<ul>
<li>No implicit violations of the static type system</li>
<li>Provide as good support for user-defined types as for built-in types</li>
<li>Locality is good</li>
<li>Avoid order dependencies</li>
<li>If in doubt, pick the variant of a feature that is easiest to teach</li>
<li>Syntax matters(often in perverse ways)</li>
<li>Preprocessor usage should be eliminated</li>
</ul>
<p>Low-Level Programming Support Rules</p>
<ul>
<li>Use traditional(dumb) linkers</li>
<li>No gratuitous incompatibilities with C</li>
<li>Leave no room for a lower-level language below C++(except assembler)</li>
<li>What you don’t use, you don’t pay for(zero-overhead rule)</li>
<li>If in doubt, provide means for manual control</li>
</ul>
<h2 id="Standardization"><a href="#Standardization" class="headerlink" title="Standardization"></a>Standardization</h2><p>对于一个被广泛使用的语言，一个统一标准是必须的，简单来说，标准定义了什么是general的，什么是implementation-dependent。</p>
<p>标准委员会的组成非常复杂，有各种职业者，各个公司代表。</p>
<p>委员会的很多工作，不为大多数人所知，而且非常无聊。感觉与程序员的修养相悖，那些花了很多时间探究和定义的写法问题，恰恰是程序员不关心的，我们更多地关注最佳实践，而不是令人目眩的奇怪语法。</p>
<p>Examples</p>
<ul>
<li>Name look up - Namespace - Redefinition</li>
<li>Lifetime of temporaries - EOS</li>
<li>Keyword argument</li>
<li>Restricted pointer</li>
<li>Character sets</li>
</ul>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><h3 id="Design-Tradeoffs"><a href="#Design-Tradeoffs" class="headerlink" title="Design Tradeoffs"></a>Design Tradeoffs</h3><ul>
<li>Emphasize run-time efficiency?</li>
<li>Minimize recompilation after a change?</li>
<li>Maximize portability across platforms?</li>
<li>Enable users to extend the basic library?</li>
<li>Allow user without source code available?</li>
<li>Blend in with existing notations and styles?</li>
<li>Be usable from code not written in C++?</li>
<li>Be usable by novices?</li>
</ul>
<h2 id="Major-Extensions"><a href="#Major-Extensions" class="headerlink" title="Major Extensions"></a>Major Extensions</h2><h3 id="Run-Time-Type-information"><a href="#Run-Time-Type-information" class="headerlink" title="Run-Time Type information"></a>Run-Time Type information</h3><ul>
<li>dynamic_cast<ul>
<li>It has a static check: the two objects must have derivation relation.</li>
<li>It doesn’t require the target type is exactly what the obj is. The target type can be a parent class.</li>
</ul>
</li>
<li>typeid()<ul>
<li>You should try to avoid typeid() in a switch statement. In most cases, virtual function is more scalable.</li>
</ul>
</li>
</ul>
<h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><h3 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h3><h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h3>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>vue入门</title>
    <url>/2020/04/02/vue%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>很久以前，很认真地学习了html、css、es6，上手了颇为超前的MVVM框架React，<br>那时候很喜欢React中纯组件化地概念，尤其是React Router的设计，并且，Redux所推崇的<br>函数式也是吹牛逼的资本。</p>
<p>最近又重回前端，写了两个小网站，试了试Vue和全新的Typescript，以及api管理工具rap和yapi。稍作整理。</p>
<h2 id="vue启动"><a href="#vue启动" class="headerlink" title="vue启动"></a>vue启动</h2><p>现在已经很少有人，从零搭建项目了，也就是自己配置webpack，安装一些开发插件。<br>这些配置主要涵盖以下几点：</p>
<ol>
<li>开发时的lint，语言特性支持。</li>
<li>编译流程，尤其是使用到js新特性，都会用babel翻译一遍，然后像less、sass等样式配置，<br>也需要对应的loader进行翻译。</li>
<li>开发时用的本地server，可以在本地运行一个web server，供开发者查看网页效果。</li>
<li>热加载插件，每次修改代码，就马上重新编译，刷新页面。有时候甚至只是局部刷新，并不重新加载页面。</li>
<li>打包发布，这里还得包括用到的图标、图片，一些文本。通常会配置多个版本，不同之处在于是否压缩，是否携带debug信息。</li>
</ol>
<p>使用vue cli可以很轻松地构建一个具备这些功能的开发环境。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i -g @vue/cli</span><br><span class="line"></span><br><span class="line">vue create your-app-name</span><br></pre></td></tr></table></figure>

<p>选择手动控制可以细粒度地选择一些特性，<br>我一般会打开typescript、eslint。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├── .browserslistrc</span><br><span class="line">├── .editorconfig</span><br><span class="line">├── .eslintrc.js</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">├── src</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── api</span><br><span class="line">│   │   ├── index.ts</span><br><span class="line">│   │   └── request.ts</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── main.ts</span><br><span class="line">│   ├── router</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   ├── shims-tsx.d.ts</span><br><span class="line">│   ├── shims-vue.d.ts</span><br><span class="line">│   ├── store</span><br><span class="line">│   │   └── index.ts</span><br><span class="line">│   └── views</span><br><span class="line">│       └── Home.vue</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── yarn.lock</span><br><span class="line">└── ytt.config.ts</span><br></pre></td></tr></table></figure>

<p>几个配置文件都相当短，vue的插件封装了许多功能，<br>有点类似java里的springboot-compiler-plugin。</p>
<h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><p>Vue给用户看到的也就是一个树状结构的组件视图，一般叫做虚拟DOM树。<br>从代码来看，index.html里放了一个带id的标签，然后js里，<br>vue的mount函数，使用了这个id。整个由vue构建的视图就插入到了这个标签中。</p>
<p>初始化vue的时候，router和全局状态管理vuex就被传递了进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a-layout</span> <span class="attr">id</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-layout-header</span> <span class="attr">style</span>=<span class="string">"padding: 0;"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 20px; color: #ffffff"</span>&gt;</span>HCloud Web<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a-layout-header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a-layout-content</span> <span class="attr">:style</span>=<span class="string">"&#123; margin: '24px 16px', padding: '24px', background: '#fff', minHeight: '600px' &#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">a-layout-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因此，App.vue就相当于是Root。<br>这里就可以按照html的写法，组织标签了。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>不同的是，vue的template里可以使用各种自定义组件。<br>如上文中的<code>&lt;a-xxx&gt;</code>标签，都是引用自antd的组件。不过实际上引入antd用的是Vue.use()，<br>按官方说法，这是引入的plugin，会调用目标的intall方法，相当于一个hook。全局组件的注册使用<code>Vue.component( id, [definition] )</code>。</p>
<p>我们自己写的组件，一般不会注册到全局，那样比较混乱。只有基础、常用的组件会注册到全局，<br>而这些组件都会有各种库提供。</p>
<p>引入自己写的组件可以用import语句，直接引入那个vue文件。然后放到components属性下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> CustomComponent <span class="keyword">from</span> <span class="string">'@/src/components/custom.vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue class</span></span><br><span class="line"><span class="comment">// other options should be placed in component function</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    AceEditor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件属性绑定"><a href="#组件属性绑定" class="headerlink" title="组件属性绑定"></a>组件属性绑定</h3><p>正如在代码中看到的，每个标签都或多或少有一些属性值。<br>属性的传入直接在标签上填写即可，代表的是一个常量。<br>如果要传递变量，就需要使用vue提供的特殊方法。<br>常用的有v-bind、v-once、v-on。具体含义参考手册。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;blog-post v-bind:title=<span class="string">"post.title"</span>&gt;&lt;<span class="regexp">/blog-post&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于组件自身，props可以直接访问，就如同它自己的属性一样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AceEditorProps = Vue.extend(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="built_in">String</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AceEditor</span> <span class="keyword">extends</span> <span class="title">AceEditorProps</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> message (): string &#123;</span><br><span class="line">    <span class="comment">// this.name will be typed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局中心存储"><a href="#全局中心存储" class="headerlink" title="全局中心存储"></a>全局中心存储</h2><p>在我看来，只有props需求的组件，复用性很好，即插即用。<br>但真正做一个网页，或者说一个项目的时候。很多页面是单例模式：<br>组件或许可以复用，但在这个项目里，它绝对只会出现一次，数据也只有一份。<br>比如说，购物车，网页主页，个人中心。</p>
<p>这些页面显然也是由组件堆叠起来的，但它们整体是不可复用的，也不需要复用。<br>当你想要制作两个购物车页面，那就得有两份不同的购物车数据，两份路由，<br>这是不可复用的根源，同时也没有必要做这种事情。</p>
<p>因此，这些数据是唯一的情景下，很适合将数据抽离出来，存放到全局存储中。<br>某种程度上，这也是无奈之举，谈不上多好的设计，是一个非常自然的想法：<br>数据是唯一的，那就必然要交给一个唯一的对象去管理。<br>如果类似组件的属性那样管理，这个数据传递起来会非常麻烦，<br>子组件都必须通过props层层传递，而修改的入口也没有限定。<br>正因为有种种不便之处，才开发出一个中心存储，再通过一些奇技淫巧，<br>使得所有组件都能访问到这个中心存储。</p>
<p>Vue的中心存储叫做Vuex。<br>提供Store、Mutation、Action、Module四个接口。</p>
<p>Store非常好理解，就是刚才说的中心存储。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.state.p</span><br></pre></td></tr></table></figure>

<p>像这样访问属性的方式，就可以访问store的数据。<br>如果想把这些数据使用到组件中，那么需要再套一层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    p() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class</span></span><br><span class="line"><span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据vuex的要求，修改属性一定要通过mutation，不能直接给state赋值。<br>从原理上说，修改属性这个操作，是必须要被监控到的，因为它可能触发DOM的改变。<br>通过mutation来修改属性，就有了一个明显的切面去监控数据变化。<br>但是实际上实现这个监控，手法有很多，也是有可能实现成，直接赋值，也被监控到的。<br>不过，使用mutation还有一个好处是，数据的改变方式是固定的，甚至可以加上类型限定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// component method</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure>

<p>Mutation都是同步方法，如果想要实现异步接口，就得用Action。<br>Promise就不展开讲了。<br>经过我尝试，async也是可以用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// async, this is not a good example</span></span><br><span class="line"><span class="comment">// because setTimeout is not 'promisefy'</span></span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Module就是提供树状层次，让状态不必全部集中到一个入口上，而是分散在不同模块中。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Vue的路由和React差异很大。React自Router 4.0之后，Router就和普通组件一模一样，<br>直接嵌入到页面中即可。</p>
<p>Vue的路由采取的是slot的方式。先填一些占位符，再在Router初始化时，统一定义每个占位符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Info <span class="keyword">from</span> <span class="string">'@/views/FunctionInfo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/views/Home.vue'</span></span><br><span class="line"><span class="keyword">import</span> Editor <span class="keyword">from</span> <span class="string">'@/views/Editor.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/function/:id'</span>,</span><br><span class="line">    component: Info</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/newfunction'</span>,</span><br><span class="line">    component: Editor</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>嵌套路由就是在子组件里面也放上<code>&lt;router-view&gt;</code>，在routes定义中使用<code>children</code>。<br>详情看手册把，不赘述了。</p>
<p>路由的改变也提供了一个封装的link组件。<br>但实际上就是通过<code>this.$router</code>所携带的各种方法操作路由。<br>详情见手册。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>wepy踩坑记录</title>
    <url>/2018/07/07/wepy%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近上手wepy框架，开发微信小程序，遇到了不少问题，略做记录。</p>
<a id="more"></a>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="BindInput与async冲突"><a href="#BindInput与async冲突" class="headerlink" title="BindInput与async冲突"></a>BindInput与async冲突</h2><p>微信小程序的bindinput：键盘输入时触发，event.detail = {value, cursor, keyCode}，keyCode 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容。<br>当回调函数被async修饰，返回的会是promise，这导致输入框内容被替换。<br>只好先调用一个普通的函数，然后再调用async函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// template</span></span><br><span class="line">&lt;input bindinput=<span class="string">"searchInput"</span> name=<span class="string">"input"</span> placeholder=<span class="string">"输入搜索信息"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods input的内容会被改变</span></span><br><span class="line">methods = &#123;</span><br><span class="line">      <span class="keyword">async</span> searchInput(e) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = e.detail.value;</span><br><span class="line">        <span class="comment">// some code using await</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fix</span></span><br><span class="line">methods = &#123;</span><br><span class="line">        searchInput(e) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = e.detail.value;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="keyword">this</span>.f();</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义方法直接定义在类中，不能放在methods下</span></span><br><span class="line"><span class="keyword">async</span> f()</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// ……</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="脏数据检查与异步方法"><a href="#脏数据检查与异步方法" class="headerlink" title="脏数据检查与异步方法"></a>脏数据检查与异步方法</h2><p>方法调用结束时，会进行检查，异步方法要用$apply方法主动触发脏数据检查。（仔细看了文档后发现有提到，但做的时候是先踩坑后找到的apply方法）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">succes: <span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.xx = xx;</span><br><span class="line">    <span class="keyword">this</span>.$apply();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="standard使用async、await"><a href="#standard使用async、await" class="headerlink" title="standard使用async、await"></a>standard使用async、await</h2><p>wepy init时使用standard版本，则包含了promise和async await的配置，用了用却发现崩的很厉害，原来没有开启api promise化，需要在app.wpy的constructor加入this.use(‘promisify’);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.use(<span class="string">'requestfix'</span>)</span><br><span class="line">      <span class="keyword">this</span>.use(<span class="string">'promisify'</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>wepy</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》笔记</title>
    <url>/2019/02/25/%E3%80%8AEffective-C-%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>CPP进阶学习。</p>
<a id="more"></a>

<h2 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h2><p>实际上这本书每一条守则后都有小总结，不需要再额外重复了，所以这里仅仅记录我个人一些理解和看法。</p>
<h3 id="Accustoming-Yourself-to-C"><a href="#Accustoming-Yourself-to-C" class="headerlink" title="Accustoming Yourself to C++"></a>Accustoming Yourself to C++</h3><ul>
<li>放弃使用宏，编译报错不明显，没有命名空间，运算顺序容易变化。</li>
<li>non-local static objects的初始化顺序不固定，相互引用会出问题，改为一个全局函数，返回一个local static object。</li>
</ul>
<h3 id="Constructors-Destructors-and-Assignment-Operators"><a href="#Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="Constructors, Destructors, and Assignment Operators"></a>Constructors, Destructors, and Assignment Operators</h3><ul>
<li>C++为每个类都会编译 Default Constructor, Copy Constructor, Destructor, Assignment Operator.</li>
<li>在大多时候是为了方便，但也有很多时候，默认的函数不满足需求。<ul>
<li>如果类会被继承，那么析构函数应该为虚函数，不然就用final限制继承。</li>
</ul>
</li>
</ul>
<h3 id="Resource-Management"><a href="#Resource-Management" class="headerlink" title="Resource Management"></a>Resource Management</h3><ul>
<li>智能指针。</li>
<li>RAII的思想，能够更好地编写资源安全（容忍异常）的代码，实现上并不特别，只是代码会清晰可读，而且安全性好。</li>
</ul>
<h3 id="Designs-and-Declarations"><a href="#Designs-and-Declarations" class="headerlink" title="Designs and Declarations"></a>Designs and Declarations</h3><ul>
<li>explicit主要是用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换。单个参数默认开启隐式转换，多个参数默认不开启隐式转换。</li>
<li>一个类就是一种类型，而编排类型是一件非常巧妙的事情。</li>
<li>传递参数尽量考虑const &amp;，但不要返回引用。</li>
<li>成员变量尽量为私有。</li>
<li>和类相关的方法：成员方法、友元、以及参数为该类的普通函数，这些设计，对类资源的可见性不同。实际上，尽量使用普通函数可以减少类成员的访问入口。</li>
<li>设计的接口应该容易被正确使用，尽量让留给<code>client</code>去<code>cover</code>的<code>error</code>变少，但这是性能和易用性的<code>trade-off</code>。</li>
</ul>
<h3 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h3><ul>
<li>和c不同，c++中延迟一个变量的声明，意义会不一样。c中的变量都会在编译期就安排在栈上。在c++中，如果这个变量是对象，那么会隐式地伴随构造、析构。所以应该尽可能延迟声明变量，避免不必要的开销。</li>
<li>Now we strive to write exception-safe code.</li>
</ul>
<h2 id="Effective-Modern-c"><a href="#Effective-Modern-c" class="headerlink" title="Effective Modern c++"></a>Effective Modern c++</h2><h3 id="Deducing-Types"><a href="#Deducing-Types" class="headerlink" title="Deducing Types"></a>Deducing Types</h3>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Advance</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《Exceptional C++》笔记</title>
    <url>/2019/03/28/%E3%80%8AExceptional-C-%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>CPP进阶学习。</p>
<a id="more"></a>

<h2 id="Item-5"><a href="#Item-5" class="headerlink" title="Item 5"></a>Item 5</h2><ul>
<li>编写一个复制和赋值函数，当需要拷贝的内容有多个（数组、对象），问题变得复杂，拷贝操作无法变成atomic，而且也面临着exception，对象的成员变量，类型也是某个对象的时候，会递归调用其他拷贝函数，也就是说，当操作的不是built-in type，就有可能抛出异常。此时拷贝操作完成了部分，处于非常尴尬的位置。</li>
<li>shadow-copy可以让拷贝变成看似原子的，再加上try-catch，避免内存泄漏（智能指针的话就可以更简单）。</li>
</ul>
<h2 id="Item-6"><a href="#Item-6" class="headerlink" title="Item 6"></a>Item 6</h2><ul>
<li>CPP中，临时对象无处不在，函数参数、函数返回值、类型转换，都会有临时对象的创建与销毁，很多时候是不必要的开销。</li>
<li>类型转换还经常是explicit的，比如一个类有很多构造函数，这个类还实现了自己的一些operator，比如equal，然后使用equal的时候就伴随着explicit conversion。</li>
</ul>
<h2 id="Item-8"><a href="#Item-8" class="headerlink" title="Item 8"></a>Item 8</h2><h2 id="Item-10"><a href="#Item-10" class="headerlink" title="Item 10"></a>Item 10</h2><ul>
<li>有没有想过为什么，stl里的queue、stack，查看元素和删除元素，是两个函数。也就是，为什么pop方法返回void？</li>
<li>当pop带返回的时候，这个操作不是原子性的，或者说容易throw exception，而又没有给上层try-catch足够的空间去恢复。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(s.pop())</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2;</span><br><span class="line">s2 = s.pop();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Advance</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《JAVA SE 9 核心技术》笔记</title>
    <url>/2019/12/26/%E3%80%8AJAVA-SE-9-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>重新入门一下Java，这次，离开了Spring，我必不可能还是废物。</p>
<a id="more"></a>

<h2 id="基本编程结构"><a href="#基本编程结构" class="headerlink" title="基本编程结构"></a>基本编程结构</h2><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ul>
<li>除去几个基本类型，所有的值都是对象，所有的变量都是引用。</li>
<li>this指针。</li>
<li>默认初始化：0， false， null。</li>
<li>final变量，不会再修改的变量，但注意它只是引用，更改目标的属性是可以的。</li>
<li>静态初始化块，通常用来初始化static数组。</li>
<li><code>import static java.lang.Math.*</code>，可以不需类名地使用Math静态方法。</li>
<li>嵌套类，声明在类内部，并且带static修饰，只是多了访问限制。</li>
<li>内部类，没有static，每个内部类对象都有外部类对象的引用，由此可访问外部的类成员。</li>
</ul>
<h2 id="接口和lambda表达式"><a href="#接口和lambda表达式" class="headerlink" title="接口和lambda表达式"></a>接口和lambda表达式</h2><ul>
<li><p>接口的所有方法默认为public，也可以提供默认实现。</p>
</li>
<li><p>Java强制类型转换，为了避免运行时错误，可先用instanceof检测类型。</p>
</li>
<li><p>继承接口，extends。</p>
</li>
<li><p>一个类可以implements多个接口。</p>
</li>
<li><p>定义在接口中的变量，都是public static final，即常量。接口无法定义实例变量，原因是它不描述状态。</p>
</li>
<li><p>默认方法使得添加接口方法能和以前的实现兼容，旧的类不需要强制实现新的方法。</p>
</li>
<li><p>当从多个接口继承默认方法时，可能会发生冲突，此时需要程序员显式地在子类中重新实现该方法。此时可通过super将实现委托给父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Identified.<span class="keyword">super</span>.getId(); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从java9开始，接口可以有私有方法，通常用来辅助实现default方法。</p>
</li>
<li><p>Runnable、Comparator等接口，都只有一个抽象方法。这样的接口被称为函数式接口。Lambda可以简化对函数式接口的使用，一个临时匿名接口实现。</p>
</li>
</ul>
<h2 id="继承与反射"><a href="#继承与反射" class="headerlink" title="继承与反射"></a>继承与反射</h2><ul>
<li><p>Java使用<code>extends</code>派生一个新类，不支持多继承。</p>
<ul>
<li>Python有专门的算法处理菱形继承、交叉继承。</li>
<li>Cpp支持多继承，使用虚继承处理冗余，调用方法时则需要显式指明。</li>
<li>Dart支持Mix-in，多继承时，只允许有一个可实例化的父类，其他的都是抽象父类，只有方法。有点像同时继承了类和接口，而接口又有默认实现。</li>
</ul>
</li>
<li><p>子类只能使用父类的public、protected部分，虽然连带private一起继承会多很多有用方法，但破坏了封装性，让父类开发不能随心所欲地修改private部分了。</p>
</li>
<li><p>子类必须调用父类的构造函数来初始化，如果没有显式写出，则会使用不带参数的默认构造。</p>
</li>
<li><p>子类对象可以被赋值给父类变量，Java的动态方法查找会让子类覆盖方法正常运行。</p>
</li>
<li><p>final方法不可被覆盖，final类不可被继承。</p>
</li>
<li><p>抽象类，不能实例构造，比接口多了实例变量和构造函数。</p>
</li>
<li><p>匿名类，将子类实现直接贴出。双重大括号语法可用来初始化匿名类对象。</p>
</li>
<li><p>从类和接口继承了相同的方法时，Java优先使用类方法，不给出编译错误。</p>
</li>
<li><p>super关键字用来访问父类的方法和变量。</p>
</li>
<li><p>所有的类都继承自Object，所以它们都有如下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> # 默认打印类名和hashcode</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> # 相等的对象必须有相同的hashCode</span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">notifyAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类型</p>
<ul>
<li>每个枚举常量都是一个匿名子类，可以有构造函数、方法和域。</li>
<li>枚举常量初始化在静态成员之前，因此不能在构造函数里引用静态成员，可以在static块中初始化。</li>
<li>switch枚举。</li>
</ul>
</li>
<li><p>运行时类型信息和资源：Class对象有一些方法帮助获取类型、方法信息。</p>
</li>
</ul>
<h2 id="异常、断言和日志处理"><a href="#异常、断言和日志处理" class="headerlink" title="异常、断言和日志处理"></a>异常、断言和日志处理</h2><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><ul>
<li>Java的泛型编程是发布后新加入的特性，为了兼容曾经的代码，使用了一个名为类型擦除的技术。<ul>
<li>在编译阶段，泛型的类型信息都会被擦除，只有泛型声明的信息保留。因此，getClass得不到运行时T的类型信息。</li>
<li>在擦除之后，所有的类型都是Object或者Arraylist&lt;Object&gt;。除非声明时有类型限定，则用限定的类型替换Object。</li>
</ul>
</li>
<li>类型擦除和多态的冲突<ul>
<li>选定一个类型声明一个确定的类，比如C&lt;String&gt;，然后继承这个类后重写泛型方法，将参数改为String，此时希望子类能够在调用时应用多态特性，调用重写的子类方法，但是，String会被擦除，变成Object去处理，JVM无法按照String签名去查找方法。为了解决这个问题，JVM引入了桥方法。即产生一个参数为Object的方法，转换类型后再调用我们重写的方法，这样可以保证JVM在动态查找时，能够找到对应的方法，同时又是按照类型调用相应的方法，实现了多态。</li>
</ul>
</li>
<li>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2>]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java并发编程之美》笔记</title>
    <url>/2019/10/08/%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>让我来康康Java并发编程的套路。（然后在cpp里自己造轮子，wdnmd）</p>
<a id="more"></a>

<h2 id="第1章-并发编程现成基础"><a href="#第1章-并发编程现成基础" class="headerlink" title="第1章 并发编程现成基础"></a>第1章 并发编程现成基础</h2><ul>
<li><p>在Java中有三种创建线程的方式</p>
<ul>
<li>Runnable</li>
<li>继承Thread类<ul>
<li>java不能多继承，所以这个方法会导致不能继承其他类</li>
</ul>
</li>
<li>FutureTask<ul>
<li>方便获取返回值。</li>
<li>有点像js的await。</li>
</ul>
</li>
</ul>
</li>
<li><p>紧接着是一堆线程常用操作。</p>
<ul>
<li>wait, sleep, notify, join, yield</li>
<li>java里的线程中断简直迷惑行为<ul>
<li><code>interrupted()</code>里用了<code>currentThread()</code>，始终是对主线程起作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>守护线程与用户线程</p>
<ul>
<li>JVM不等待守护线程退出，gc就属于守护线程</li>
<li>用户可通过<code>setDaemon(true)</code>将线程设置为守护线程</li>
<li>tomcat中的服务线程也都默认是守护线程</li>
</ul>
</li>
<li><p>ThreadLocal</p>
<ul>
<li>线程私有变量</li>
<li>具体是每个线程维护一个私有的map，访问时先找到map，再找变量</li>
<li>不支持继承</li>
</ul>
</li>
<li><p>InheritableThreadLocal</p>
<ul>
<li>可被继承</li>
<li>像Web server可能需要继承用户的token</li>
</ul>
</li>
</ul>
<h2 id="第2章-并发编程其他基础知识"><a href="#第2章-并发编程其他基础知识" class="headerlink" title="第2章 并发编程其他基础知识"></a>第2章 并发编程其他基础知识</h2><ul>
<li><p>线程安全，指多个线程同时读写一个共享资源，并且没有任何同步措施时，导致出现脏数据或者其他不可预见的结果的问题。</p>
</li>
<li><p>内存可见性问题，书中的意思是L1 cache不同步，但根据我在体系结构和编译原理中所学，我以为问题是寄存器不同步。</p>
<ul>
<li>计算机在操作变量时，总是在寄存器里操作的，这样速度也最快。</li>
<li>编译器有时会做一些优化，使得对某一个变量的操作总是在寄存器中进行。如果该变量是一个局部变量，这就是一个非常完美的优化。但有时，编译器根据上下文，也可能将某个变量一直存在寄存器中，直到函数结束再写回主存。</li>
<li>在多核cpu中，寄存器是肯定不共享的。L1 cache这一层，应当有cache一致性算法提供保证。（这是我的理解，这些都可能随着计算机发展而变化，具体情况具体分析）</li>
</ul>
</li>
<li><p>原子性操作</p>
<ul>
<li>syncronized，java关键字，被修饰的代码块，执行时需要先获取独占锁。</li>
</ul>
</li>
<li><p>Unsafe类，java中玩转指针</p>
<ul>
<li>操纵对象属性</li>
<li>操纵数组元素</li>
<li>线程挂起与恢复、CAS（硬件级别的原子性保证）</li>
</ul>
</li>
<li><p>ABA问题</p>
</li>
<li><p>代码重排序问题</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">thread-1</span><br><span class="line">&#123;</span><br><span class="line">  num = 2</span><br><span class="line">  ready = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">thread-2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ready:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对num和ready的赋值会被编译器识别为，无依赖性，有可能会重排汇编指令执行顺序。</li>
<li>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
</li>
<li>屏障的作用<ul>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</li>
</ul>
</li>
<li>volatile修饰的变量。<ul>
<li>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。</li>
<li>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。</li>
</ul>
</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>悲观锁，整个操作过程都使用排他锁。</li>
<li>乐观锁，通常在本地（对线程来说就是单独的栈，对分布式来说是不同的进程）修改，最后update的时候获取锁。</li>
<li>公平锁，拿锁遵循先到先得。可以避免某个线程饥饿。</li>
<li>共享锁，通常用于实现读写锁，读锁是共享的。写锁则是独占的。不过在《Linux多线程服务端编程:使用muduo C++网络库》中，作者提到，实践中从来不用读写锁。真正解决问题还是靠减小critical block。</li>
<li>可重入锁，指的是同一线程重复获取同一个锁。synchronized的锁是实例级别的，可重入实现，使得可以在synchronized方法中，调用自己的另一个sync方法。</li>
<li>自旋锁，获取锁失败时，不suspend，也就是不放弃cpu时间，认为很快可以获得锁。内核代码大量使用自旋锁，因为计算机正常工作时，处于内核态的时间应该不多，而且context switch开销很大。</li>
</ul>
</li>
</ul>
<h2 id="第3章-Java并发包中ThreadLocalRandom类原理剖析"><a href="#第3章-Java并发包中ThreadLocalRandom类原理剖析" class="headerlink" title="第3章 Java并发包中ThreadLocalRandom类原理剖析"></a>第3章 Java并发包中ThreadLocalRandom类原理剖析</h2><ul>
<li><h2 id="第4章-Java并发包中原子操作类原理剖析"><a href="#第4章-Java并发包中原子操作类原理剖析" class="headerlink" title="第4章 Java并发包中原子操作类原理剖析"></a>第4章 Java并发包中原子操作类原理剖析</h2></li>
<li><p>AtomicLong、LongAdder、LongAccumulator。</p>
</li>
<li><p>用到Unsafe，JUC。</p>
</li>
<li><p>主要是看代码，不赘述了。</p>
</li>
</ul>
<h2 id="第5章-Java并发包中的并发List源码剖析"><a href="#第5章-Java并发包中的并发List源码剖析" class="headerlink" title="第5章 Java并发包中的并发List源码剖析"></a>第5章 Java并发包中的并发List源码剖析</h2><ul>
<li><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2></li>
<li><p><a href="https://www.cnblogs.com/luxiaoxun/p/8744826.html" target="_blank" rel="noopener">ThreadLocal原理分析与使用场景</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/ef8de88b1343" target="_blank" rel="noopener">并发关键字volatile（重排序和内存屏障）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX环境高级编程》阅读笔记</title>
    <url>/2019/01/31/%E3%80%8AUNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>听说是Linux编程必读书之一，另外，戚老师真厉害（本书译者之一）。</p>
<a id="more"></a>

<h2 id="第一章-Unix基础知识"><a href="#第一章-Unix基础知识" class="headerlink" title="第一章 Unix基础知识"></a>第一章 Unix基础知识</h2><ul>
<li>一些基础知识，感觉就像，不懂的，看了也不懂，懂了的，不需要这一节基础。</li>
</ul>
<h2 id="第二章-Unix标准及实现"><a href="#第二章-Unix标准及实现" class="headerlink" title="第二章 Unix标准及实现"></a>第二章 Unix标准及实现</h2><ul>
<li>各种限制，各种定义，看完全忘了。</li>
<li>更多地是介绍一下一些主要区别和关键参数，使用的话，找个参考手册可能更准确更方便一点。</li>
</ul>
<h2 id="第三章-文件I-O"><a href="#第三章-文件I-O" class="headerlink" title="第三章 文件I/O"></a>第三章 文件I/O</h2><p>介绍UNIX系统中常用的文件I/O函数，不同于c/cpp的标准库，这里的函数几乎全是系统调用。准确来说，标准库也会被编译为系统调用，但那是跨平台的，实现不相关的。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>文件描述符是非常有意思的概念，关于fd，一开始是CSE课上从Hierachy角度讲的。这个概念也和Security相关，它隐藏了底层文件系统的细节，并且将权限入口控制住。</li>
<li>现在来看，CSE讲的未必到点子上，我认为是为了兼容多种文件系统，才必须有fd这一层，其他功能也很好，但不一定要加一层才能实现。</li>
<li>有了统一方法，进程间共享、通信，也是很自然的事情了。但这里仍然不理解，为什么网络以及其他一些设备也是fd。</li>
</ul>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><ul>
<li>原子操作的概念是很直观的，all or nothing。</li>
<li>很奇怪的是，断电是一个真实状况，是什么机制，让断电也无法破坏呢？</li>
<li>我目前的想法：确定一个commit point可以让操作变成原子的，但并不是真的nothing，有一些操作还是执行了，有时候需要recovery，清理掉无效操作。</li>
<li>CSE上介绍了实现commit point的两种办法，log和shadow copy。</li>
<li>书上没有介绍断电的情况，只是描述了系统调度会中断执行，不能被中断的函数就认为是原子操作（超过一个函数的操作一定是非原子的）。</li>
</ul>
<h2 id="第四章-文件和目录"><a href="#第四章-文件和目录" class="headerlink" title="第四章 文件和目录"></a>第四章 文件和目录</h2><p>文件信息在UNIX中用一个结构体stat表示，一般包括mode、inode number、uid、gid、nlink（number of links）、size、amc三个时间、block size、block num。<br>目录也是文件的一种。</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul>
<li>文件权限有rwx三种，读、写、执行（实际上还有一些特殊标志位）。</li>
<li>rwx和用户类型绑定，user（owner）、group、others。</li>
<li>st_mode有一个特殊标志，“当执行此文件时，进程的有效用户ID设置为文件所有者的用户ID”，类似的，也有设置组ID位。这两位可以用来编写特殊程序给所有用户使用，比如<code>passswd</code>，修改口令需要修改<code>/etc/passwd</code>，而普通用户是没有这个文件的相关权限的。</li>
<li>目录的读权限用来获取目录下内容（文件列表），但打开文件只需要执行权限，创建文件只需要写和执行权限。</li>
<li>acess函数可用于检测实际用户ID和实际组ID对文件的权限。</li>
</ul>
<h3 id="新文件和目录所有权"><a href="#新文件和目录所有权" class="headerlink" title="新文件和目录所有权"></a>新文件和目录所有权</h3><ul>
<li>新文件的用户ID为进程有效用户ID。</li>
<li>新文件的组ID<ul>
<li>可以为进程有效组ID</li>
<li>可以为所在目录的组ID</li>
</ul>
</li>
</ul>
<h3 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h3><ul>
<li>文件的一个特殊权限位<code>S_ISVTX</code>。</li>
<li>在可执行程序文件上设置该位，可以让程序正文部分保留一个副本在交换区，便于被快速读取。现在的UNIX系统大多配备了虚拟存储系统和快速文件系统，不再需要这种技术了。</li>
<li>在目录上设置该位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录的文件：<ul>
<li>拥有此文件（owner）</li>
<li>拥有此目录</li>
<li>超级用户</li>
</ul>
</li>
<li>目录<code>/tmp</code>和<code>/var/tmp</code>很适合设置粘着位，所有用户都可以往这个目录里创建文件（具有目录写、执行权限），但不应该拥有删除他人文件的权限（<strong>删除文件只需要对目录有写和执行权限</strong>）。</li>
</ul>
<h3 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h3><ul>
<li>我才知道文件大小不一定代表使用了这么多磁盘，因为“空洞”不占空间，但读取的时候就全是<code>&#39;\0&#39;</code>。</li>
<li>像如果写入的index大于文件的size，也能写入成功，中间就会出现空洞。</li>
<li>这应该和文件系统实现相关，不能保证都是这个效果。</li>
</ul>
<h3 id="文件所有者"><a href="#文件所有者" class="headerlink" title="文件所有者"></a>文件所有者</h3><ul>
<li>更改文件所有者是有潜在风险的事情，用户可以依此避开磁盘空间限额。</li>
<li>一些系统强制只有root用户可以修改文件用户ID。</li>
<li>POSIX.1允许用_POSIX_CHOWN_RESTRICTED常量来定义chown是否需要被限制。</li>
</ul>
<h2 id="第五章-标准I-O库"><a href="#第五章-标准I-O库" class="headerlink" title="第五章 标准I/O库"></a>第五章 标准I/O库</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><ul>
<li>标准I/O都带有缓冲区，在大多数情况下都可以减少内核函数调用，提高性能。</li>
<li>缓冲有全缓冲（缓冲区满了再输出）、行缓冲（遇到换行符或者满了输出）、不带缓冲。</li>
<li>一般来说，当标准输入输出，指向终端设备，是行缓冲的，指向普通文件，则是全缓冲的。标准错误则不带缓冲。</li>
</ul>
<h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><ul>
<li><code>fread</code>和<code>fwrite</code>，效果类似于直接copy一段内存。</li>
<li>这是有潜在问题的，结构体的大小和内存分布，可能随编译器和运行环境变化，导致程序不可移植（即序列化和反序列化方法不一致）。</li>
</ul>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul>
<li>C里的<code>printf</code>很强大，其函数族可以接收file pointer，fd，char *。</li>
<li>格式化的参数就比较多了，整数、字符串、小数、改变进制等。</li>
<li>格式化输入有<code>scanf</code>。</li>
</ul>
<h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><ul>
<li><code>tmpnam</code>可以生成一个唯一的路径名。</li>
<li><code>tmpfile</code>则创建一个wb+的二进制临时文件，在程序结束时就会删除。实现该函数，可以通过<code>tmpnam</code>生成路径名，创建文件，紧接着<code>unlink</code>新文件。</li>
</ul>
<h2 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h2><ul>
<li>口令文件<code>/etc/passwd</code>。为了隐藏登陆密码，采用MD5或SHA-1算法加密，并保存在阴影口令文件。阴影口令文件不能被随意读取。</li>
<li>组文件。</li>
<li>还有其他数据文件，都有类似的get、set、end函数。</li>
<li>utmp和wtmp，登陆账号记录。</li>
<li>系统标识uname。</li>
<li>协调世界时UTC。</li>
</ul>
<h2 id="第七章-进程环境"><a href="#第七章-进程环境" class="headerlink" title="第七章 进程环境"></a>第七章 进程环境</h2><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul>
<li>共有八种方式终止<br>正常终止<ul>
<li>从<code>main</code>返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code>或<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回<br>异常终止</li>
<li>调用<code>abort</code></li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ul>
</li>
<li>终止状态会被内核保存，直到被父进程获取，然后释放进程状态。但进程状态也存在未定义的情况。</li>
<li><code>exit</code>终止会做一些处理工作，可用<code>atexit</code>函数登记终止处理程序。<ul>
<li>终止处理程序每登记一次就会被调用一次，并且先进后出。</li>
</ul>
</li>
</ul>
<h3 id="参数和环境表"><a href="#参数和环境表" class="headerlink" title="参数和环境表"></a>参数和环境表</h3><ul>
<li>程序启动只能通过exec函数族。</li>
<li>程序会获得参数和环境表，这在<code>exec</code>函数参数中也有体现。</li>
<li>参数通过<code>argc</code>和<code>argv</code>的结构传递（有局限性，因为是字符数组，所以不能传递特殊字符）。</li>
<li>环境表是一个全局变量<code>extern char ** environ</code>，环境字符串形如<code>HOME=/home/sar\0</code></li>
<li>一般不会直接访问<code>environ</code>，而是用<code>getenv</code>和<code>putenv</code>去获取和设置一个环境变量。除非要遍历所有环境变量，才用<code>environ</code>。</li>
<li>内核不会解释参数和环境表，即与内核程序无关。</li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul>
<li>这里没有讲的太清楚，据我所知，要实现共享库，需要编译器和操作系统共同努力，虚拟内存也使得这件事更容易。</li>
<li>通过一些特殊的表结构，在函数第一次调用，或者程序启动时，动态地设置函数指针的指向。</li>
</ul>
<h3 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h3><ul>
<li><code>malloc</code>、<code>calloc</code>、<code>realloc</code>三个函数用来分配内存。</li>
<li>实质上是通过<code>sbrk</code>增加堆大小来实现分配内存，具体的分配算法和回收算法与实现相关。</li>
<li>绝大多数实现，都不会减小堆内存，只会将内存回收，等待下次调用，但不返还给内核。</li>
</ul>
<h3 id="setjmp和longjmp"><a href="#setjmp和longjmp" class="headerlink" title="setjmp和longjmp"></a>setjmp和longjmp</h3><ul>
<li><code>goto</code>语句不能跨越函数（从栈帧来看这很显然，函数的局部变量存放在栈和寄存器中，<code>goto</code>等于<code>jmp</code>语句，直接<code>jmp</code>到某个函数种是没有意义的，栈不匹配）。</li>
<li>要实现跨函数转移，很显然需要保存一下栈和寄存器的状态，<code>setjmp</code>保存状态（<code>setjmp</code>并不保存寄存器状态，它不能保证自动变量和寄存器变量的值不变，可以将需要被保存的变量声明为<code>volatile</code>，强制栈上分配）。</li>
<li><code>longjmp</code>则跳到之前保存的某个状态，重新执行。如果重新执行，不改变任何参数，那程序还是会执行到同样的<code>longjmp</code>从而循环。这里发生变化的是<code>setjmp</code>的返回值，<code>longjmp</code>跳转回来可以重新设置<code>setjmp</code>的返回值。</li>
</ul>
<h3 id="getrlimit和setrlimit"><a href="#getrlimit和setrlimit" class="headerlink" title="getrlimit和setrlimit"></a>getrlimit和setrlimit</h3><ul>
<li>用来查询和修改进程资源限制。<ul>
<li>任何一个进程都可将软限制值更改为小于或等于其硬限制值。</li>
<li>任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。</li>
<li>只有超级用户进程可以提高硬限制值。</li>
</ul>
</li>
<li>常量<code>RLIM_INFINITY</code>指定了一个无限量的限制。</li>
<li>资源限制会被子进程继承，shell的ulimit必然是一个内置命令。</li>
</ul>
<h2 id="第八章-进程控制"><a href="#第八章-进程控制" class="headerlink" title="第八章 进程控制"></a>第八章 进程控制</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><ul>
<li>用来创建子进程，对父进程返回子进程<code>pid</code>，对子进程返回0。</li>
<li>子进程具有完全相同的栈，但采取COW策略（写时复制），具体是将虚拟内存页置为只读，在发生写操作时产生中断，由内核复制一份。</li>
<li>子进程继承的属性：<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标志和设置组ID标志</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>信号屏蔽和处理动作</li>
<li>对任一打开文件描述符的执行时关闭(<code>close-on-exec</code>)标志</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映像</li>
<li>资源限制</li>
</ul>
</li>
<li>区别如下：<ul>
<li><code>tms_utime、tms_stime、tms_cutime、tms_ustime</code>设置为0</li>
<li>不继承文件锁</li>
<li>未处理闹钟被清除</li>
<li>未处理信号集设置为空集</li>
</ul>
</li>
</ul>
<h3 id="wait和watipid"><a href="#wait和watipid" class="headerlink" title="wait和watipid"></a>wait和watipid</h3><ul>
<li>当一个进程终止，内核向其父进程发送<code>SIGCHLD</code>信号。</li>
<li><code>wait</code>用于获取状态发生变化的子进程的状态。</li>
<li><code>waitpid</code>可以等待某个<code>pid</code>或<code>pgid</code>的进程，可以通过设置参数变成不阻塞的调用，可以发现子进程经过作业控制，停止后又继续的状态。</li>
<li>返回值用宏检查。</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><ul>
<li><code>exec</code>用一个新程序替换当前进程的正文段、数据段、堆段和栈段。</li>
<li>exec调用可以传入参数和环境，这不由内核解释，仅仅是额外功能。</li>
<li>新进程继承属性：<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字</li>
<li>文件锁</li>
<li>进程信号屏蔽（不继承处理动作）</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值（调度优先级）</li>
<li><code>tms_utime、tms_stime、tms_cutime、tms_ustime</code></li>
</ul>
</li>
</ul>
<h3 id="更改用户ID和组ID"><a href="#更改用户ID和组ID" class="headerlink" title="更改用户ID和组ID"></a>更改用户ID和组ID</h3><ul>
<li>具体规则太长了懒得抄。</li>
<li>总的来说，只有超级用户能修改”实际用户ID”。</li>
<li>普通用户修改”有效用户ID”需要检查”设置用户ID”。</li>
<li>exec时，”设置用户ID”从”有效用户ID”复制，也就是说，特权传递会变弱。</li>
<li>假如父进程的”有效用户ID”和”设置用户ID”有特权，父进程可以改变”有效用户ID”，创建子进程，子进程的三个ID都将是没有特权的。而父进程可以通过<code>setuid</code>恢复特权用户ID，因为”设置用户ID”是有特权的。</li>
</ul>
<h3 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h3><ul>
<li>起始行为<code>#! pathname [optional-argument]</code>。</li>
<li>内核负责<code>exec pathname</code>。</li>
</ul>
<h3 id="进程会计、用户标识、进程调度、进程时间"><a href="#进程会计、用户标识、进程调度、进程时间" class="headerlink" title="进程会计、用户标识、进程调度、进程时间"></a>进程会计、用户标识、进程调度、进程时间</h3><ul>
<li>内核会统计进程的一些运行数据，并存放在一个结构中。</li>
<li>用户ID可以对应多个登录名，即在口令文件中有多个登录项，可以对应不同的启动<code>shell</code>，<code>getlogin</code>获取用户登录时用的名字，然后可以用<code>getpwnam</code>去查找对应项。</li>
<li><code>nice</code>值用于进程调度优先级。</li>
<li><code>times</code>本身返回墙上时钟时间，但这是一个绝对值，必须两次调用<code>times</code>相减才能得到进程运行中墙上时钟时间变化。参数是结构体<code>tms</code>，包含自身和已终止子进程的用户CPU时间和系统CPU时间。</li>
</ul>
<h2 id="第九章-进程关系"><a href="#第九章-进程关系" class="headerlink" title="第九章 进程关系"></a>第九章 进程关系</h2><h3 id="终端登录"><a href="#终端登录" class="headerlink" title="终端登录"></a>终端登录</h3><ul>
<li><code>init--fork--&gt;init--exec--&gt;getty--exec--&gt;login</code>。</li>
<li>传统的<code>login</code>，得到用户名后，调用<code>getpass</code>获取口令，使用<code>crpyt</code>加密，和阴影口令比较，多次无效口令则<code>exit</code>。现代UNIX系统可以支持其他身份验证过程(PAM，Pluggable Authentication Modules)。</li>
</ul>
<h3 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h3><ul>
<li><code>init--/etc/rc--&gt;inetd--fork--&gt;inetd--exec--&gt;telnetd</code></li>
<li>telnetd打开一个伪终端设备（19章介绍），调用fork，一个进程负责网络通信，一个进程调用login。两个进程通过伪终端连接。</li>
</ul>
<h3 id="进程组、会话、控制终端"><a href="#进程组、会话、控制终端" class="headerlink" title="进程组、会话、控制终端"></a>进程组、会话、控制终端</h3><ul>
<li>组长进程的进程组ID等于其进程ID，但进程组的生命周期和组长进程无关，取决于进程组中最后一个终止进程。</li>
<li>会话包括多个进程组，一个会话往往和一个终端相连。</li>
<li>会话有一个前台进程组，其他则全为后台进程组（终端会绑定一个前台ID）。</li>
</ul>
<h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><ul>
<li>属于POSIX.1要求的部分。</li>
<li>类似于前台进程、后台进程等概念和操作，就叫作业控制。</li>
<li>细节挺多，然后作业也不是很大，这里不写了。</li>
</ul>
<h2 id="第十章-信号"><a href="#第十章-信号" class="headerlink" title="第十章 信号"></a>第十章 信号</h2><h3 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h3><ul>
<li>POSIX.1对可靠信号例程进行了标准化。</li>
<li>信号都被编号为正整数，没有本质区别，仅仅是标准定义了不同含义。</li>
<li>信号和interrupt还不太一样，IDT是硬件层面的，信号是由内核组织的，虽然某些中断信号（键盘、硬件异常）是由硬件触发，其中还是经过内核处理的。</li>
<li>用户态不需要关注IDT，也无法了解IDT。</li>
<li>信号处理<ul>
<li>忽略（SIGKILL和SIGSTOP不可忽略，强制终止）。</li>
<li>捕捉，进入到用户自定义的handler中。</li>
<li>默认动作。</li>
</ul>
</li>
</ul>
<h3 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h3><ul>
<li>早期的UNIX中，如果进程在执行一个<strong>低速</strong>系统调用而阻塞期间，捕捉到一个信号，则该系统调用就被中断不再继续执行，返回出错，errno为EINTR。</li>
<li>大多数现代操作系统，被中断的系统调用会自动重启。</li>
</ul>
<h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><ul>
<li>在信号处理程序中，严格来讲，只能使用可重入函数，否则就有可能造成不可预料的行为。</li>
</ul>
<h3 id="SIGCLD-kill-raise-alarm-pause"><a href="#SIGCLD-kill-raise-alarm-pause" class="headerlink" title="SIGCLD kill raise alarm pause"></a>SIGCLD kill raise alarm pause</h3><ul>
<li>kill和raise用于发送信号，当然这有权限限制。</li>
<li>alarm用来设置时钟。</li>
<li>pause让进程挂起，直到捕捉到一个信号。</li>
<li>alarm和pause一起使用可以实现sleep，但这里有race condition。</li>
<li>如果在pause调用过程中，收到了alarm信号，那么进程将被永远阻塞。</li>
<li>Sigsuspend可以使得操作原子化，避免该行为。</li>
<li>一个巧妙的longjmp也可以避免race condition，但该写法可能终止之前的函数，也就是进入alrm的函数会因为longjmp而回不去。（另外两个问题是没有保存之前的信号处理函数和时间）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> jmp_buf env_alrm;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sig_alrm(<span class="keyword">int</span> signo)&#123; longjmp(env_alrm, <span class="number">1</span>)&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">sleep2(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_alrm) == SIG_ERR)</span><br><span class="line">        <span class="keyword">return</span> seconds;</span><br><span class="line">    <span class="keyword">if</span> (setjmp(env_alrm) == <span class="number">0</span>) &#123;</span><br><span class="line">        alarm(seconds);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(alarm(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><ul>
<li>待续。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><ul>
<li>从操作系统层面来看，thread是OS能够调度的最小单位。但Context和Thread的辨析是有些奇怪的，取决于怎么定义，或者说，怎么distinguish一个thread。当一个thread切换了自己的Context，那么算不算换了一个thread？</li>
<li>但不管怎么说，thread具有自己的Context，只要注册在内核中，就可以被内核调度。</li>
<li>从编程技术来看，muti-thread model，让异步编程变得简单，在有低速系统调用时，也能够提高cpu利用率。</li>
</ul>
<h3 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h3><ul>
<li>考虑移植性，不使用built-in类型，而是封装一个类型，并为此编写Oprator。</li>
<li>关于线程的创建、终止、同步等内容，已经无法再精简了，建议直接看书。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>《现代编译原理——C语言描述》阅读笔记</title>
    <url>/2018/10/12/%E3%80%8A%E7%8E%B0%E4%BB%A3%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>忍痛选修编译原理，大名鼎鼎的虎书。</p>
<a id="more"></a>

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img src="/2018/10/12/%E3%80%8A%E7%8E%B0%E4%BB%A3%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1-1.png" alt="图片加载失败"></p>
<h2 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h2><h3 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h3><ul>
<li>正则表达式可以简明扼要的描述单词（Symbol），一般而言，常用的几种语法有：+*.|[]{}。</li>
<li>在词法分析这里，正则只是用来匹配一个字符串，不强调它提取子串的功能，实际上正则引擎还支持更多的功能和操作，比如定位符，分组捕获，反向引用。</li>
</ul>
<h3 id="Finite-Automaton"><a href="#Finite-Automaton" class="headerlink" title="Finite Automaton"></a>Finite Automaton</h3><ul>
<li>一个正则表达式很容易转换为非确定有限自动机（NFA）。</li>
<li>编程实现NFA不太方便，直觉上就像DFS、回溯算法等，转换成DFA会更方便程序执行。</li>
<li>NFA转换DFA就是将可能走到的所有结果合并成一个状态，然后将所有可能出口作为新状态的出口。（按图来说的话，就是e线条连接的点当作一个点看待。）</li>
</ul>
<h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><h3 id="Context-Free-Grammars"><a href="#Context-Free-Grammars" class="headerlink" title="Context-Free Grammars"></a>Context-Free Grammars</h3><ul>
<li>上下文无关文法，用以描述一个无限的状态。</li>
<li>这里的无限指的是递归，而且是两个表达式相互包含的递归，比如sum = expr + expr, expr = sum | digits, 这种形式的正则表达式不合法，它无法被转换为DFA。</li>
<li>上下文无关文法更强大，能够表示这种递归概念，至于如何解析并未包括。</li>
</ul>
<h3 id="Predicting-Parsing-LL-LR"><a href="#Predicting-Parsing-LL-LR" class="headerlink" title="Predicting Parsing \ LL \ LR"></a>Predicting Parsing \ LL \ LR</h3><ul>
<li>上下文无关文法所描述的状态是有二义性的，也就是满足定义的语法树不唯一，这可能会产生错误，也可能不会。</li>
<li>分析器需要选择下一步状态，预测分析就是猜测可能是什么，如果错了就回退，这个很暴力也很直接，就是速度太慢。</li>
<li>LL(k)分析可以提前查看后面k个单词，再确认当前是什么状态。但对于if then else if then这种句子，k不够大的时候，LL也无法正确猜出。也就是说，LL只是多获取了固定信息，一旦预测所需信息超出这个范围，就无能为力。</li>
<li>LR(k)分析会用栈存储遇到的单词，如果还不能判断状态就继续往下读取，直到可以确定。同样，在这时，对于if then，它也会有两种选择，即shift-reduce conflict。这种时候可以限定优先级或者直接指定应该采取的选择，最终达到正确需求就行。（yacc默认是shift）</li>
</ul>
<h2 id="Abstract-Syntax"><a href="#Abstract-Syntax" class="headerlink" title="Abstract Syntax"></a>Abstract Syntax</h2><ul>
<li>使用yacc生成抽象树。</li>
<li>这一章的数据结构和函数均为A开头。</li>
</ul>
<h2 id="Semantic-Analysis"><a href="#Semantic-Analysis" class="headerlink" title="Semantic Analysis"></a>Semantic Analysis</h2><ul>
<li>语义分析，实际上这一章只是检测一些语义错误，比如类型检查，recursive dec。</li>
<li>在后面会一边检查，一边将A-tree转换为IR-tree。</li>
<li>类型检查基本就是扫描树，按照语法要求就好。</li>
</ul>
<h2 id="Activity-Record"><a href="#Activity-Record" class="headerlink" title="Activity Record"></a>Activity Record</h2><h3 id="嵌套函数（闭包）"><a href="#嵌套函数（闭包）" class="headerlink" title="嵌套函数（闭包）"></a>嵌套函数（闭包）</h3><ul>
<li>书中给出三种方法：static link, display, lambda lifting。</li>
<li>static link: 简单说就是做到一件事情，每次调用函数g的时候，找到g的上一级函数f（也就是函数g是在函数f内声明的），将f的frame pointer传递给g作为static link。</li>
<li>找到g的上一级，这个事情在编译时可以分析得到。知道了函数f后，通过已有的static link一定能找到f，找不到一定是定义错误。</li>
<li>有了这个static link，就可以访问外层的数据，不过一般是按顺序的，也就是会产生同名覆盖，最近优先。</li>
</ul>
<h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><ul>
<li>传参限制：有一些参数总是放在寄存器里的，由于callee的使用需求，可能需要将部分参数转移到栈上。</li>
</ul>
<h2 id="Translation-to-Intermediate-Code"><a href="#Translation-to-Intermediate-Code" class="headerlink" title="Translation to Intermediate Code"></a>Translation to Intermediate Code</h2><ul>
<li>Translate、Frame、Temp三个主要部分。</li>
<li>IR-tree中就只有三种类型，Ex，Nx，Cx。<ul>
<li>Ex代表“表达式”</li>
<li>Nx代表“无结果语句”</li>
<li>Cx代表“条件语句”</li>
</ul>
</li>
</ul>
<h3 id="Cx"><a href="#Cx" class="headerlink" title="Cx"></a>Cx</h3><ul>
<li>Cx总是会有两个goto方向，有时候就会产生goto next line这种情形，有些多余。</li>
</ul>
<h2 id="Basic-Blocks-and-Traces"><a href="#Basic-Blocks-and-Traces" class="headerlink" title="Basic Blocks and Traces"></a>Basic Blocks and Traces</h2><ul>
<li>现在，我们得到了IR-tree，但是它不便于分析，因为其中有ESEQ、CJUMP、CALL等语句，这会导致语句是有顺序的，不同的顺序结果不一样，从而限制了做优化的顺序。</li>
<li>我们可以通过三个步骤将IR-tree转换为等价的、无上述mismatch的形式。<ul>
<li>rewrite the tree into a list of canonical trees without SEQ or ESEQ nodes.</li>
<li>group the list into a set of basci blocks(no jump or labels).</li>
<li>order the blocks into a set of traces in which every CJUMP is immediately followed by its false label.</li>
</ul>
</li>
</ul>
<h3 id="canon"><a href="#canon" class="headerlink" title="canon"></a>canon</h3><h4 id="ESEQ"><a href="#ESEQ" class="headerlink" title="ESEQ"></a>ESEQ</h4><ul>
<li><p>简单说就是把ESEQ往上提，考虑ESEQ(s, e)，移动s和e表达式的时候，只要s在e前面执行，并且最后返回值是e，ESEQ的语义就保留了。</p>
</li>
<li><p>但问题是，移动之后，s和e之间就有了其他的表达式，这些表达式的计算如果和s有关系，那么也会被s的副作用影响，而这是不对的。</p>
</li>
<li><p>我们并不总是能在编译阶段判断两个表达式之间是否有影响，这意思是说，像CONST的语句，肯定无影响，但MEM就无法判断是否是同一个数据，</p>
</li>
<li><p>所以，对于无影响的，我们就能比较简单的交换顺序，有影响的，我们可以通过多做一次MOVE来消除影响。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BINOP(op, e1, ESEQ(s, e2))=&gt;ESEQ(MOVE(TEMP t, e1), ESEQ(s, BINOP(op, TEMP t, e2)));</span><br></pre></td></tr></table></figure>

<p>也就是说，用中间变量保存可能受影响的变量。（我觉得这像负优化）</p>
</li>
<li><p>大致思想如上，具体算法有些复杂，不谈。</p>
</li>
</ul>
<h4 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h4><ul>
<li><p>a = f1(b) + f2(c)。</p>
</li>
<li><p>像这样的式子，树结构逻辑上也没问题，但机器实现就出问题，因为函数的返回值都是用同一个寄存器（rax）来存的，连续运算两个，有一个就丢失了，然后再op就没法做。</p>
</li>
<li><p>办法和之前一样，用一个临时变量保存一下。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CALL(fun, args) =&gt; ESEQ(MOVE(TEMP t, CALL(fun, args)),TEMP t)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="linearize"><a href="#linearize" class="headerlink" title="linearize"></a>linearize</h4><ul>
<li>总之，一顿操作之后，这个seq语句就全部是顶层，不会位于其他类型节点。</li>
<li>再通过SEQ(SEQ(a,b),c) == SEQ(a,SEQ(b,c))，将seq转换为线性的一个列表。</li>
</ul>
<h3 id="basic-block"><a href="#basic-block" class="headerlink" title="basic block"></a>basic block</h3><ul>
<li>入口为label，结束为jump的块。</li>
<li>从头至尾扫描语句序列，发现label就开始一个块（并结束上一个块，加上jump到这个label），发现jump就结束一个块。</li>
</ul>
<h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><ul>
<li>我现在才悟到，轨迹其实不是一条，它会有多条，也会有多个结果。因为很显然，有些块会有多个其他块跳过来，就像函数在不同地方被调用。（当然这里做tiger的时候，其实是面向函数体编程，也就是prog，所以这个例子不太恰当）</li>
<li>最直接的办法就是，任意选一个未被任何轨迹包括的块作为新轨迹开始，然后沿着它的跳转到下一个块，不断的做，直到形成环结束。</li>
<li>其实块变成汇编的时候，顺序是无所谓的，因为每个块都有label，重要的是，我们希望jump尽量少，同时，像循环这种，也尽量写成，预测跳转是循环体，能提高条件预测成功率。</li>
<li>对块分析trace，有助于更好的排列块和做优化。</li>
</ul>
<h2 id="Instruction-Selection"><a href="#Instruction-Selection" class="headerlink" title="Instruction Selection"></a>Instruction Selection</h2><ul>
<li>每一条指令并不一定对应一个节点，它更像是对应树的一小块结构。选择指令的结果也是多样的，就像积木，不同的内部结构，搭出同样的外形。最终的结果是，指令覆盖了整个树，并且不重叠。</li>
<li>覆盖有两个概念，最优（optimum）覆盖和最佳（optimal）覆盖。<ul>
<li>optimal是不存在可以相邻简化的部分。</li>
<li>optimum是代价之和为最小。</li>
</ul>
</li>
<li>optimum一定也是optimal。</li>
</ul>
<h3 id="Maximal-Munch"><a href="#Maximal-Munch" class="headerlink" title="Maximal Munch"></a>Maximal Munch</h3><ul>
<li>the alogrithm for optimal tiling.</li>
<li>从根节点开始，寻找合适的最大瓦片。</li>
<li>对子树进行相同算法。</li>
<li>本质上就是贪心算法，局部最优，全局不一定。</li>
<li>顺势就会想到，最优可以用动态规划，自底向上。</li>
</ul>
<h3 id="Abstract-Assembly-Language-Instructions"><a href="#Abstract-Assembly-Language-Instructions" class="headerlink" title="Abstract Assembly-Language Instructions"></a>Abstract Assembly-Language Instructions</h3><ul>
<li>在指令选择之前，不太好决定寄存器分配，tiger在指令选择后做寄存器分配。所以我们用了一个抽象指令结构，它们不指定寄存器。</li>
<li>有AS_op，AS_move，AS_jump。</li>
</ul>
<h2 id="Liveness-Analysis"><a href="#Liveness-Analysis" class="headerlink" title="Liveness Analysis"></a>Liveness Analysis</h2><ul>
<li>TODO</li>
</ul>
<h2 id="Register-Allocate"><a href="#Register-Allocate" class="headerlink" title="Register Allocate"></a>Register Allocate</h2><ul>
<li>寄存器分配，这一章没有太多在实现上花功夫的点，作者给出了全部伪代码。而算法本身，还是有些晦涩难懂的（主要是合并与溢出）。</li>
</ul>
<h3 id="图着色"><a href="#图着色" class="headerlink" title="图着色"></a>图着色</h3><ul>
<li>通过将变量的冲突关系表示为图中的边，寄存器分配等价于图着色问题，这是一个np完全问题，我们采用启发式的近似算法。但是，似乎最大的把握是即使不能着色还可以将变量放到内存里（即溢出），当然这个就给优化留了不少空间。</li>
</ul>
<h4 id="启发式算法-K-颜色数量"><a href="#启发式算法-K-颜色数量" class="headerlink" title="启发式算法(K=颜色数量)"></a>启发式算法(K=颜色数量)</h4><ul>
<li>图中度数小于K的点，可以被去掉，并且入栈记录，不影响图可着色。</li>
<li>剩下度数大于K的点，假设它可以被去掉，也入栈记录。</li>
<li>然后栈弹出，任意分配颜色。</li>
<li>很明显，如果没有第二步，即所有点度数都小于K，那么一定能着色。</li>
<li>有了第二步，出栈时就有可能无法分配颜色，这时候就是一个溢出，需要将变量放到内存以减小它的活跃范围。</li>
</ul>
<h4 id="合并节点"><a href="#合并节点" class="headerlink" title="合并节点"></a>合并节点</h4><ul>
<li>合并实际上算一种优化，没有合并也能够分配成功。</li>
<li>合并的原因是两个变量有move关系，也就是在某一刻会出现a=b，并且之后b变量不再使用。那么a、b可以用同一个寄存器并省掉一次move。</li>
<li>但是很遗憾的是，不能将没有冲突（没有冲突就说明a、b不会同时活跃，第二点就成立）的move两端就全部合并，盲目合并可能使得图不可着色，我们采取保守的合并策略，简单说就是，确保这次合并不会影响图着色。</li>
<li>怎样保证呢？只要合并后的点是可被简化的，那么它肯定不影响。</li>
<li>Briggs: a、b合并后的节点ab的高度数(&gt;K)邻节点数量&lt;=K。</li>
<li>George: a的每一个邻居t，t与b已有冲突，或者t是低度数节点。</li>
</ul>
<h4 id="实现策略"><a href="#实现策略" class="headerlink" title="实现策略"></a>实现策略</h4><ul>
<li>合并引入了复杂度，有这样一个问题，先合并还是先简化？<ul>
<li>先简化，那么显然，不要直接将move相关的点给简化掉了，那样就少了一次合并机会。</li>
<li>先合并，很显然，合并失败的可能性会很大，在极端情况下甚至等同于先简化后合并。</li>
</ul>
</li>
<li>书上采用了先简化的策略，并且规定不能简化传送相关的点，但是有些传送相关的点也不能被合并，所以引入了冻结(freeze)，就是将一个点变为传送无关(放弃尝试合并，变为可简化的)。</li>
<li>当简化、合并、冻结都无法进行，那么图中就全是传送无关的高度数节点，此时采用溢出，假设它可以着色，强行入栈。</li>
<li>最后出栈分配颜色，如果遇到无法分配的，先记录下来，继续分配，最后重写程序，从活跃分析开始重来一次。</li>
</ul>
<h4 id="预着色节点"><a href="#预着色节点" class="headerlink" title="预着色节点"></a>预着色节点</h4><ul>
<li>图中会有一些节点，代表的就是真实寄存器，比如rax，六个参数寄存器，callee-save寄存器等，这些在codegen时会被显式使用到，所以不可避免地会出现在图中。</li>
<li>它们不应该被合并，也不能被简化，它们具有特定颜色。</li>
<li>它们的活跃范围必须很小，要是真实寄存器的活跃范围都很大，那么还怎么分配寄存器给临时变量呢，它们一定会有很多冲突。</li>
<li>活跃范围主要靠move给一个新的临时变量，过程结束再move回来，这样它在这个过程中就是不活跃的。</li>
<li>实际上，临时变量和真实寄存器一定会被合并，随后的溢出是源于局部变量的分配，当出现call指令，会再用到真实寄存器，call节点上所有量都是活跃的，这时候局部变量和真实寄存器就会冲突，局部变量还会和临时变量冲突，导致必然出现溢出。由于临时变量度数大，所以会先入栈，反而会得不到颜色，导致真实溢出，最后被替换掉。</li>
<li>非callee-save的寄存器活跃范围，需要在call指令的时候，将它们放到call的dst，表示不是跨过程活跃。这样会使得它们与跨过程活跃临时变量冲突，临时变量就会被迫先分配callee-save，如果都不够用，就会溢出。</li>
</ul>
<h3 id="x86-64的特点思考"><a href="#x86-64的特点思考" class="headerlink" title="x86-64的特点思考"></a>x86-64的特点思考</h3><ul>
<li><p>一个非常trick的点，如果一个函数内，既有局部变量，又有call指令，那么它一定会产生溢出。</p>
<ul>
<li>如果局部变量放到非callee-save，那么call的时候会冲突。</li>
<li>如果放到callee-save，放之前callee-save会冲突（也就是必须为自己的caller保存这些寄存器）。</li>
</ul>
</li>
<li><p>很令人感到困惑，十六个寄存器竟然还这么多溢出，但是仔细想想确实是这样。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>《虚拟智慧》阅读笔记</title>
    <url>/2018/10/12/%E3%80%8A%E8%99%9A%E6%8B%9F%E6%99%BA%E6%85%A7%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>比较老的一本书，但内容很全很详细，讲了许多虚拟化基础知识，描述也简单好理解。</p>
<a id="more"></a>

<h2 id="第一章-企业虚拟化的目的及本质"><a href="#第一章-企业虚拟化的目的及本质" class="headerlink" title="第一章 企业虚拟化的目的及本质"></a>第一章 企业虚拟化的目的及本质</h2><ul>
<li>云计算简单定义：“将已量化的许多运算资源，以网络为媒介，通过特定的界面给需要服务的用户”，“将资源打散，找出最小的计量单位，之后将其全部集中起来，并重新分配的过程。”</li>
<li>虚拟化程度：完全虚拟化、硬件辅助虚拟化、部分虚拟化、半虚拟化。</li>
<li>寄居架构：运行在某个固定的操作系统上。</li>
<li>原生架构：包括硬件内核，直接安装在硬件上，接管所有资源。</li>
</ul>
<h2 id="第二章-VMware-vSphere"><a href="#第二章-VMware-vSphere" class="headerlink" title="第二章 VMware vSphere"></a>第二章 VMware vSphere</h2><ul>
<li>VMware仍然是最大的虚拟机厂商，推出了众多的产品。</li>
<li>总的来说，也是头一回知道VMware有这么多fancy的功能。</li>
<li>hot-add，不关机增加cpu、memory。</li>
<li>副本、冗余、切换等多种方式的高可用配置。</li>
<li>硬件资源的使用基本跟上了硬件升级的节奏。资源使用有详细的监控报告。</li>
<li>Host Bus Adapter(HBA)，主机总线适配器。</li>
</ul>
<h2 id="第三章-全面理解vSphere的硬件"><a href="#第三章-全面理解vSphere的硬件" class="headerlink" title="第三章 全面理解vSphere的硬件"></a>第三章 全面理解vSphere的硬件</h2><ul>
<li>Hardware Compathibility List(HCL)，硬件兼容性列表。</li>
<li>Virtualization Technology(VT)。<ul>
<li>IntelVT-x技术：增强处理器的VT虚拟化技术，包括IntelVTFlexPriority、IntelVTFlexMigration（Intel虚拟化灵活迁移技术）、ExtendedPageTables（IntelVT扩展页表）。</li>
<li>IntelVT-d技术：支持直接I/O访问的IntelVT虚拟化技术。</li>
<li>IntelVT-c技术：支持网络连接的Intel虚拟化技术，包括虚拟机设备队列（VMDq）、虚拟机直接互连（VMDc）。</li>
</ul>
</li>
<li>RAID，磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。</li>
<li>Keyboard Video Mouse(KVM)，KVM 交换机通过直接连接键盘、视频和鼠标 (KVM) 端口，让您能够访问和控制计算机。KVM 技术无需目标服务器修改软件。</li>
<li>Preboot Execute Environment(PXE)，预启动执行环境，用于实现无硬盘服务器。</li>
<li>Intelligent Platform Management Interface(IPMI)，智能平台管理接口，可以监控硬件状态，远程管理服务器开关机。</li>
<li>这一章大概就是说，VM有很多特性需要硬件支持，vsphere对硬件就更挑剔了，一般都是服务器级别的硬件去运行。上面提到的很多都是Intel的技术，其他厂商应该多多少少应该也有类似的，我并不清楚，但可以看出，Intel在硬件还是处于领先的。</li>
</ul>
<h2 id="第四章-存储设备"><a href="#第四章-存储设备" class="headerlink" title="第四章 存储设备"></a>第四章 存储设备</h2><ul>
<li>内置硬盘有很多局限性，一般是说可扩展性、兼容性不好，更为糟糕的是单点故障，这对企业级来说是不可接受的。</li>
<li>常用外置存储DAS,NFS,NAS,SAN<ul>
<li>DAS就是直接连接存储设备，Direct Attached Storage，个人电脑一般就是这种结构，局限于只能和一台机器相连。</li>
<li>NAS，Network Attached Storage，以文件为主的共享存储设备，通过网络进行数据交换。</li>
<li>SAN，Storage Area Network，和LAN有点相似，一群存储设备的集合，网卡换成HBA卡，它能访问更低层次的LUN和Volume Group。</li>
<li>NFS是一种网络共享协议，算是实现NAS的一种办法。</li>
</ul>
</li>
<li>iSCSI，SCSI扩展比较昂贵，而iSCSI是一种通过ip网络提交SCSI命令和数据，从而免去了环境搭建。这也和现在网络速度足够快，足够稳定息息相关。</li>
</ul>
<h2 id="第五章-第九章"><a href="#第五章-第九章" class="headerlink" title="第五章-第九章"></a>第五章-第九章</h2><ul>
<li>这几章都是实际应用，没有原理性的东西。</li>
</ul>
<h2 id="第十章-vSphere的网络原理"><a href="#第十章-vSphere的网络原理" class="headerlink" title="第十章 vSphere的网络原理"></a>第十章 vSphere的网络原理</h2><ul>
<li>vSwitch，虚拟交换机。在ESX中，网络划分不再是物理的路由或交换机，而是vSwitch。vSwitch和物理网卡是一对一或者一对多，也就是多个网卡组成一个vSwitch，类似于RAID，能增强性能和容灾。</li>
<li>这章也有大量的实际操作，不涉及虚拟网络的实现。</li>
</ul>
<h2 id="第十一章-vSphere的存储理论及实践"><a href="#第十一章-vSphere的存储理论及实践" class="headerlink" title="第十一章 vSphere的存储理论及实践"></a>第十一章 vSphere的存储理论及实践</h2><ul>
<li>vmhba，虚拟HBA。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://baike.baidu.com/item/Intel%20VT" target="_blank" rel="noopener">IntelVT——百度百科</a></li>
<li><a href="https://baike.baidu.com/item/磁盘阵列/1149823" target="_blank" rel="noopener">RAID——百度百科</a></li>
<li><a href="https://baike.baidu.com/item/KVM/522955" target="_blank" rel="noopener">KVM——百度百科</a></li>
<li><a href="https://baike.baidu.com/item/IPMI/2552078" target="_blank" rel="noopener">IMPI——百度百科</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>一个人难免崇拜流浪</title>
    <url>/2018/07/06/%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%9A%BE%E5%85%8D%E5%B4%87%E6%8B%9C%E6%B5%81%E6%B5%AA/</url>
    <content><![CDATA[<p>闲得无聊做了个博客，目前看来功能还是很少。<br>程序员修炼之道，路漫漫其修远兮。</p>
<a id="more"></a>

<h1 id="几件小事"><a href="#几件小事" class="headerlink" title="几件小事"></a>几件小事</h1><h2 id="又一年期末"><a href="#又一年期末" class="headerlink" title="又一年期末"></a>又一年期末</h2><p>大学生活转眼过去两年，跌跌撞撞，摸爬滚打，好在无灾无祸，一路至此。考试手感略有起色，也能拿个不错分数了，或许对专业课要比公共课更上心一点。<br>越走越远，我终于想不起过去是什么样子了。</p>
<h2 id="又一年高考"><a href="#又一年高考" class="headerlink" title="又一年高考"></a>又一年高考</h2><p>几个月前的寒假里，跑到母校给一些高三学子讲经验，其实没什么经验可谈，却还说了一大堆的话。我羡慕他们的样子，也同情他们的处境，我深知面对问题束手无策的痛苦，但我没法帮助谁，我连自己都解救不了。分享了一些趣闻趣事，说说自己曾经的辉煌与失败，最后成为过客，离开。<br>现在他们毕业了，听说结果不算好，有个学弟还找到我，询问填报志愿的事情。出分时，他的估分和实分有落差，再加上题目简单，整体分数提升，排名就靠后了。<br>他说要去复读了。<br>我眼睛一热，半天说不出话来，最后敲了两个字，“加油”。想起我还浪费时光，想起我一时好运却不知路长。</p>
<blockquote>
<p>枕边没有风浪怎么我们会跌荡摇晃<br>伸手不见月光怎么繁星能闪耀光芒<br>脚印会旧而梦还在走<br>太阳尚远但一定会有<br>《寻》 ——华晨宇</p>
</blockquote>
<h2 id="又一年梦想"><a href="#又一年梦想" class="headerlink" title="又一年梦想"></a>又一年梦想</h2><p>不免要鸡汤一把，但愿这里是新的梦想启程，为成为大师而不懈努力。</p>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>人生备份</title>
    <url>/2020/03/13/%E4%BA%BA%E7%94%9F%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>虽然没有心情每天写日记，但打算大致记录一下轨迹上的风景。</p>
<p>书：</p>
<ul>
<li><p>2016-2019</p>
</li>
<li><p>借我一生 白夜行 千年一叹 一花一世界 等一个人咖啡 我不喜欢这世界，我只喜欢你</p>
</li>
<li><p>那些年我们一起追过的女孩 全职高手 少年歌行 人生最厉害的就是这个BUT</p>
</li>
<li><p>占星术杀人魔法 钟表馆 二钱铜币 龙与少年游 舞！舞！舞！ 人情-世故 知情识趣</p>
</li>
<li><p>万水千山走遍 世界将我包围 雨季不再来</p>
</li>
<li><p>青铜时代 白银时代 黄金时代 杀人鬼 怪胎</p>
</li>
<li><p>超新星纪元 爱情，两好三坏 打喷嚏</p>
</li>
<li><p>代码整洁之道 程序员的职业素养 萤 青春</p>
</li>
<li><p>国境以南太阳以西 世界尽头与冷酷仙境</p>
</li>
<li><p>十八岁给我一个姑娘 动物凶猛 世事如烟 金色梦乡</p>
</li>
<li><p>神探伽利略 春风沉醉的晚上 直捣蜂窝的女孩</p>
</li>
<li><p>欢喜 北京，北京 三十六大 万物生长 活着活着就老了</p>
</li>
<li><p>御手洗洁的舞蹈 亮剑</p>
</li>
<li><p>左心房漩涡 碎琉璃 千手捕蝶 情人眼 活到老真好</p>
</li>
<li><p>精通正则表达式 树莓派用户指南 测试驱动开发</p>
</li>
<li><p>林海雪原 深入浅出React和Redux Kubernetes权威指南</p>
</li>
<li><p>人月神话 软件开发者路线图 Docker经典实例</p>
</li>
<li><p>编程大师访谈录 编程之魂 时间旅行者的妻子</p>
</li>
<li><p>调试九法 Haskell函数式程序设计 御手洗洁的问候</p>
</li>
<li><p>深入剖析Tomcat Spring技术内幕 第一本Docker书</p>
</li>
<li><p>精通Hibernate 人间失格 Neo4j实战</p>
</li>
<li><p>元素模式 虚拟智慧 容器即服务</p>
</li>
<li><p>Apache Kafka实战 x86汇编语言从实模式到保护模式 汇编语言 Python科学计算</p>
</li>
<li><p>你想活出怎样的人生 人生的智慧 原来你非不快乐</p>
</li>
<li><p>穿越计算机的迷雾 让我留在你身边 从你的全世界路过</p>
</li>
<li><p>送你一颗子弹 余生，请多指教</p>
</li>
<li><p>你好，旧时光 暗恋，橘生淮南 最好的我们</p>
</li>
<li><p>芳华 黑客与画家 断舍离</p>
</li>
<li><p>2020</p>
</li>
<li><p>面纱 封神演义 刘慈欣短篇小说集 环界 独眼少女</p>
</li>
<li><p>喜欢你是寂静的：林徽因传 醒来觉得甚是爱你</p>
</li>
<li><p>浪潮之巅 李银河说爱情 聊斋志异 无人生还 狼图腾</p>
</li>
<li><p>design-and-evolution-of-cpp option-volatility-and-pricing</p>
</li>
</ul>
<p>音乐：</p>
<ul>
<li><a href="http://url.cn/5Zuka3O" target="_blank" rel="noopener">2019歌单</a></li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>从什么时候成了沪漂</title>
    <url>/2019/08/06/%E4%BB%8E%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%88%90%E4%BA%86%E6%B2%AA%E6%BC%82/</url>
    <content><![CDATA[<p>经历了一段迷茫的时间，对于从未尝试过的东西，心里总是有些害怕，除此之外，对过去也总是有不舍。<br>想那么多做什么呢，无济于事，年轻本是资本，却好似负担了。</p>
<a id="more"></a>

<p>这一年，结束了学生时代，再也不会有什么早八早十要上了。<br>结束的第一周，十分兴奋，毕竟是期盼已久的实习工作，一拿到任务，就在绞尽脑汁地想办法，不断输出。一周后，有一种溺水的感觉，不知道做这些事情的意义，不觉得这份工作难得，不认为上海是个好地方。千般思绪涌上心头，之后的一周，甚至在考虑是不是应该去互联网试试。现在来看，和公司无关，大概是个人的认知不清，也没有找到新生活的乐趣。<br>现在，有一些优秀的解忧想法，可以分享了。</p>
<ul>
<li>看看身边有多少交大人，我身边半个开发团队有过交大教育经历。</li>
<li>多和人聊天，可以聊一些工作之外的，还可以直截了当地将困惑说出来，比如上海买房情况，平时怎么消遣，同事也都是人，每个人其实都需要适当分享想法。</li>
<li>如果觉得做个员工，不自由，公司的很多地方也让人不适。首先，公司是不是真的不行，可以康康它的行业地位，还有竞争对手们是什么情况，该跑路就跑路。然后，问一个问题，那么你想创业吗？你想要打造自己的公司吗？实现自己的想法？这是不是最自由的方案呢？这时候可以换一个思考方式了，你了解公司怎样运作的吗，你所在的公司，凭借什么才得到它现在地位？现在将你开了，你能造一个小型山寨出来吗？答案是不能的话，就意味着在公司里，还有很多东西可以学习。这是代码以外的事情，但更有趣。像我所在的地方，级别俨然行业Top，我相信其中有很多有趣的东西可以了解。</li>
<li>学会找乐趣，尤其是都市生活的乐趣，当下年轻人喜欢的，比如看电影，健身，打游戏。</li>
<li>持续学习，不要荒废读书，这是这么久以来最大的依仗。</li>
<li>换位思考，归零视角。我们总是什么还没做，就先吓到不敢行动。就算日子过得不好，就算突遭不幸，也不过是从头再来。真有那时，再考虑换方向也来得及。这么说的理由是，成功的确属于小部分人，但我们现在都是追梦者，空想是没用的，搏一把就搏一把，输了不过是打包回家。</li>
</ul>
<p>最后说些感伤的话吧，三年了，不知道当初的朋友们，得到的和想要的是否相同，现在又会选择去哪里，北上广深漂流，大洋彼岸求学，天南海北读研。<br>不论怎样，勿忘初心。</p>
]]></content>
      <categories>
        <category>Experience</category>
      </categories>
      <tags>
        <tag>Summer</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我爱你</title>
    <url>/2020/01/25/%E5%85%B3%E4%BA%8E%E6%88%91%E7%88%B1%E4%BD%A0/</url>
    <content><![CDATA[<p>倘若生命有意义，我想就是你。</p>
<a id="more"></a>

<h2 id="动物习性"><a href="#动物习性" class="headerlink" title="动物习性"></a>动物习性</h2><p>生物学家观察生物，物理学家观察世界，人类总是从各种各样的现象中总结经验，持续进步。我偶然想到，我的一生其实都在观察自己。</p>
<p>根据我二十多年的持续跟进调查，我发现我有诸多习性。比如贪玩，时常不正经，知难而退。在贪玩这一项下也有很多分支，像喜欢玩游戏，但也不是那种能玩上一整天的网瘾少年，游玩过的游戏数量也没有很多。</p>
<p>总之，诸如此类的许多定义，它们背后都有大量的事实支撑。但一定会有人想杠，说你某些定义不对，你这根本算不上贪玩，然后又举出一些别人的例子。我想说，我本不可能用文字精准表达这些观察结果，因为它们源于二十年的时光，假如我精炼程度是十比一，你也需要两年的时光才能体会。而现在你只用了一分钟不到的时间去思考我所说的东西，况且，没有人可以感同身受地领会一段内容。所以，不要杠这些单薄的词语，体会一下我所谓的习性意思。</p>
<p>后来，我读的书越来越多，走的路越来越长，见的人越来越多，不断地修炼自身，企图达到完美境界，不悲不喜，又能得所有认识的人的喜欢。但是，一些不美的事情总是重演，我在想，是不是某些习性，这一生都无法改正掉了。此外，世上仿佛真的不存在，得所有喜欢的一种状态。有人说，有多少人讨厌，就有多少人喜欢，反之亦然。</p>
<p>我尚不知道哪些认知是真的，待我大限将近或可体会更深，也可能一生都被错误所蒙蔽，谁又可知呢。</p>
<h2 id="追求快乐"><a href="#追求快乐" class="headerlink" title="追求快乐"></a>追求快乐</h2><p>我比较之后发现，可以将所有的事情都归结为，追求快乐，追求自身心灵的快乐。这也是某些习性甩不掉的原因，不美的事情会带给我一些快乐。比如在有时间努力的时候，在舒适区里放松。</p>
<p>但是这种快乐的转化并非固定的，随着我对事物认知的改变，快乐的来源会发生变化，就像有了一千万的人不再为得到一百块而特别开心，读过了富有想象的作品，不再对庸俗的杜撰动容。</p>
<p>只是人类实在是种聪明的动物，甚至会为未来的快乐做打算。在当下跳出舒适区，是为了未来能有竞争力，夺得更多的资源，从而让自己快乐。我也听说有一种人，视努力为快乐，在努力的过程中就能得到快乐，可能对这种情形来说，舒适区比较大，别人视作痛苦的东西，他们甘之如饴。在我的观察结果里，我不太像这种生物，我的确会在空闲的时间里去学习一些东西，这通常是因为想要认识世界更多，可是一旦发现，学习目标让我当下不快乐的话，我就会退回到更轻松的学习方式里。</p>
<p>在我的狭隘经济学里，现在的一块钱总是比未来的一块钱价值大。这种狭隘的方式，会让我在某些情况下损失惨重。</p>
<p>好在对于自我而言，一切都是自定义的，谈不上什么损失了。</p>
<h2 id="失去神力"><a href="#失去神力" class="headerlink" title="失去神力"></a>失去神力</h2><p>在这漫长的时光里，我们总有许多不快乐。在某些时候，我们失去了定义快乐的神力，截至目前为止的观察结果表明，是他人夺走了这种力量。</p>
<p>当我不再以孤单的视角审视世界，当我把快乐和旁人建立关系，把快乐源泉转移到需要多个人参与的事情上，我就没法再重定义这份快乐。比方说，我希望我是考试第一名，那也得其他人配合一下，别考那么好了。我想要老板给我快速升职，也得老板同意才行。</p>
<p>但类似这些愿望，并不总能实现，假如总是实现的话，人不知足，也会提出更进一步的要求，周而复始，终于不能全部实现了。反过来说，少提出一些要求，或许可以更快乐。</p>
<p>于是，一种全新的自我约束，永恒快乐模式出现了。<br><em>永远不要要求他人</em></p>
<p>只是颇有些绝灭意味，在这种约束下，人不敢为爱付出，付出了可能就忍不住要求他人回报，从而破坏了神力。</p>
<p>此外，要求他人，也是躲避不掉的事情，假如我给了医生一笔钱，然后他无动于衷，并不给我治病，这想必谁也顶不住这种欺辱。餐厅拿钱不上菜，司机送错了地方。任谁都会抓狂。</p>
<p>好在世上有诸多法律，公序良俗，以阻止这种不能容忍的事情。</p>
<p>唯有爱你这件事，说不上任何委屈。</p>
<h2 id="我爱你"><a href="#我爱你" class="headerlink" title="我爱你"></a>我爱你</h2><p>写下这个小标题，我想到了许多的我爱你。有父母，有能记起的爱情故事，也有许多悲剧。它们就仿佛被操纵的木偶，被蒙蔽的灵魂，在失去神力之后互帮互助，苦苦支撑。</p>
<p>真羡慕永远不必清醒的故事。</p>
<p>修炼再多，我还是经常听见，灵魂深处的低语。</p>
<p>我爱你，无论春秋。</p>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>关于退休的事情</title>
    <url>/2020/06/28/%E5%85%B3%E4%BA%8E%E9%80%80%E4%BC%91%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<p>年轻人应该想着退休吗。</p>
<h2 id="最想做的事情"><a href="#最想做的事情" class="headerlink" title="最想做的事情"></a>最想做的事情</h2><ul>
<li>环游世界、豪车豪宅、看演唱会、无所事事</li>
<li>只是想来想去，上述一类事情，也只会在得到时快乐一阵子，很快就会有新的欲望</li>
<li>原谅我匮乏的想象力，擅自决定世界上最好的事情是偷走你的心</li>
</ul>
<h2 id="世纪"><a href="#世纪" class="headerlink" title="世纪"></a>世纪</h2><ul>
<li>2020年是可以结婚的一岁</li>
<li>20200202是我觉得称得上倾城之恋的一天</li>
<li>往后百年，都是想念</li>
</ul>
<h2 id="小朋友"><a href="#小朋友" class="headerlink" title="小朋友"></a>小朋友</h2><ul>
<li>我的秘密和我的坦白一样多</li>
<li>你决定要先听哪个</li>
<li>听完了他们还是一样多</li>
</ul>
<h2 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h2><ul>
<li>你有许多令人意外的缺点</li>
<li>令人意外是我的喜欢丝毫未减</li>
<li>我猜你不会喜欢我的世界</li>
<li>你说还给我一个意外</li>
</ul>
<h2 id="前后"><a href="#前后" class="headerlink" title="前后"></a>前后</h2><ul>
<li>当灯光渐暗</li>
<li>我本想趁机握你的手</li>
<li>却被你抱住整个手臂</li>
</ul>
<h2 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h2><ul>
<li><em>你有没有觉得热</em></li>
<li>还好呀</li>
<li><em>那手让我牵一会</em></li>
</ul>
<h2 id="终局"><a href="#终局" class="headerlink" title="终局"></a>终局</h2><ul>
<li>I’ve been looking for you for 20 years</li>
<li>now it’s time to enter next world</li>
<li>thank you, my love</li>
</ul>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><ul>
<li>封笔</li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Dream</tag>
      </tags>
  </entry>
  <entry>
    <title>兼容legacy和uefi的pxe配置</title>
    <url>/2019/05/11/%E5%85%BC%E5%AE%B9legacy%E5%92%8Cuefi%E7%9A%84pxe%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>等到我在裸机上跑pxe的时候，发现是新旧两种机型混合，主板启动有legacy和uefi两种，woc。</p>
<a id="more"></a>

<p>思路其实很简单，dhcp有一些参数支持根据client的类型来match不同的启动文件，只需要导向到不同的启动文件，后面的事情就交给tftp了。uefi的启动文件稍稍有些不同，这里做一些记录。</p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><ul>
<li>/etc/dhcp/dhcpd.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DHCP Server Configuration file.</span><br><span class="line"></span><br><span class="line">option space PXE;</span><br><span class="line">option PXE.mtftp-ip  code 1 &#x3D; ip-address;</span><br><span class="line">option PXE.mtftp-cport code 2 &#x3D; unsigned integer 16;</span><br><span class="line">option PXE.mtftp-sport code 3 &#x3D; unsigned integer 16;</span><br><span class="line">option PXE.mtftp-tmout code 4 &#x3D; unsigned integer 8;</span><br><span class="line">option PXE.mtftp-delay code 5 &#x3D; unsigned integer 8;</span><br><span class="line">option arch code 93 &#x3D; unsigned integer 16; # RFC4578</span><br><span class="line">ddns-update-style interim;</span><br><span class="line">ignore client-updates;</span><br><span class="line">authoritative;</span><br><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">allow unknown-clients;</span><br><span class="line"></span><br><span class="line"># internal subnet for my DHCP Server</span><br><span class="line">subnet 192.168.2.0 netmask 255.255.255.0 &#123;</span><br><span class="line">range 192.168.2.200 192.168.2.255;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line"># IP of PXE Server</span><br><span class="line">class &quot;pxeclients&quot; &#123;</span><br><span class="line">  match if substring (option vendor-class-identifier, 0, 9) &#x3D; &quot;PXEClient&quot;;</span><br><span class="line">  next-server 192.168.2.11;</span><br><span class="line"></span><br><span class="line">  if option arch &#x3D; 00:07 &#123;</span><br><span class="line">    filename &quot;uefi&#x2F;shim.efi&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    filename &quot;pxelinux.0&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dhcp发放记录在<code>/var/lib/dhcpd/dhcpd.leases</code></li>
</ul>
<h2 id="Tftp"><a href="#Tftp" class="headerlink" title="Tftp"></a>Tftp</h2><ul>
<li><code>/var/lib/tftpboot</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uefi files</span></span><br><span class="line">grub.cfg  grubx64.efi  initrd.img  vmlinuz shim.efi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>initrd.img  vmlinuz</code>和之前一样，从<code>/mnt/images/pxeboot/</code>下获取。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /mnt/images/pxeboot/initrd.img /x</span><br><span class="line">cp /mnt/images/pxeboot/vmlinuz  /x</span><br><span class="line">cp /mnt/EFI/BOOT/grubx64.efi /x</span><br><span class="line">cp /boot/efi/EFI/centos/shim.efi /x</span><br><span class="line">cp /boot/efi/EFI/centos/grub.cfg /x</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># modified part of grub.cfg</span><br><span class="line"></span><br><span class="line">linuxefi uefi&#x2F;pxeboot&#x2F;vmlinuz ks&#x3D;&quot;http:&#x2F;&#x2F;192.168.2.11&#x2F;centos7.cfg&quot; nofb text biosdevname&#x3D;0 ksdevice&#x3D;bootif</span><br><span class="line">initrdefi uefi&#x2F;pxeboot&#x2F;initrd.img</span><br></pre></td></tr></table></figure>

<h2 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h2><ul>
<li>autopart比较方便，自动分区。除非有特殊需求，不然autopart挺好用的。</li>
<li>packages使用core就足够了。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://blog.51cto.com/144432/2067418" target="_blank" rel="noopener">网络启动二：之PXE：CentOS6.9+TFTP+DHCP+BIOS+UEFI部署操作系统。</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Ops</tag>
      </tags>
  </entry>
  <entry>
    <title>分我一秒</title>
    <url>/2020/02/24/%E5%88%86%E6%88%91%E4%B8%80%E7%A7%92/</url>
    <content><![CDATA[<p>借我一生太长，况且还不起，分我一秒足够。</p>
<a id="more"></a>

<h2 id="分秒"><a href="#分秒" class="headerlink" title="分秒"></a>分秒</h2><ul>
<li>我曾虚度很多时光</li>
<li>但没有你的时光，都是虚度</li>
<li>不必可惜</li>
</ul>
<h2 id="足不出户"><a href="#足不出户" class="headerlink" title="足不出户"></a>足不出户</h2><ul>
<li>坐上一整天，哪也不去</li>
<li>只是随地球旋转，我也走了好远</li>
<li>离你的距离，是少了一天，又或者多了一天</li>
</ul>
<h2 id="火柴"><a href="#火柴" class="headerlink" title="火柴"></a>火柴</h2><ul>
<li>已经有数年没见过火柴</li>
<li>如果世上只剩最后一根</li>
<li>我想擦亮它一定能实现愿望</li>
</ul>
<h2 id="这就是爱吗"><a href="#这就是爱吗" class="headerlink" title="这就是爱吗"></a>这就是爱吗</h2><ul>
<li>难道真的没有人，相信相逢的人会再相逢吗？</li>
<li>虽然有赌的成分</li>
<li>但是愿赌服输</li>
</ul>
<h2 id="富贵在天"><a href="#富贵在天" class="headerlink" title="富贵在天"></a>富贵在天</h2><ul>
<li>头一回听你念，生死有命，富贵在天</li>
<li>后四个字你几乎咬牙切齿，怎么听都是人定胜天</li>
<li>你光芒四射，唯独少了我</li>
</ul>
<h2 id="技术流"><a href="#技术流" class="headerlink" title="技术流"></a>技术流</h2><ul>
<li>有些人觉得，赢面超过一半就挺好的</li>
<li>甚至有的人，有一成机会也敢亮剑</li>
<li>我都不是，我习惯最强者必胜</li>
</ul>
<h2 id="尽头"><a href="#尽头" class="headerlink" title="尽头"></a>尽头</h2><ul>
<li>毕设写到后来，越写越慢</li>
<li>写到深夜灯光里，眼泪都滴到键盘上</li>
<li>我真不想离开这里啊</li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>塞尔达传说日记</title>
    <url>/2019/01/29/%E5%A1%9E%E5%B0%94%E8%BE%BE%E4%BC%A0%E8%AF%B4%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>任天堂独占大作，《塞尔达传说:荒野之息》。真的好玩，好玩到想写日记，我有点明白为什么游戏被称作第九艺术了。<br><strong>内含剧透，慎入。</strong></p>
<a id="more"></a>

<h2 id="初始之地"><a href="#初始之地" class="headerlink" title="初始之地"></a>初始之地</h2><ul>
<li>出门那一下真的很震撼，看着就觉得，噢，好酷，世界好大。后面发现，整个地图还要比眼前所见大好多好多。</li>
<li>砍来砍去很刺激，但是武器一下子就坏了是什么鬼啊，而且也没说要怎么维修。</li>
<li>没有滑翔伞之前，摔死是最容易的。</li>
<li>神庙这个玩法我觉得不是很新鲜，考考小朋友还差不多，之前玩过《传送门》（Portal），一个风格，但更加烧脑。</li>
<li>我能够感觉到第一个npc不是正常人，可是这种灵魂留守在这，完成使命就消散的模式，实在让我这种伤春悲秋的人开心不起来。为什么我要苟活于世，还要背负救世的责任呢，亲朋好友都离我而去，我救的是什么呢。</li>
</ul>
<h2 id="记忆之地"><a href="#记忆之地" class="headerlink" title="记忆之地"></a>记忆之地</h2><ul>
<li>这种古代风格还有相机？？有点酷炫。</li>
<li>公主为什么只拍风景，来几个自拍啊。</li>
</ul>
<h2 id="水神兽"><a href="#水神兽" class="headerlink" title="水神兽"></a>水神兽</h2><ul>
<li>这个神兽的内部构造一点也不科学，太空荡了。</li>
<li>米法为什么要喜欢林克，海利亚第一勇（zha）士（nan）？</li>
<li>第一次拯救神兽，虽然故事讲，神兽里的英杰都死了，但我还幻想了一波只是被封印占据，我打赢就能救活了。没想到还是灵魂，最后消散了。</li>
<li>我觉得最悲情的地方在于，这一世，没有和爱人长厢厮守，未能完成封印灾厄的任务，拥有的只是美好记忆和一份关于未来的希望。</li>
<li>我不能理解米法的父亲和弟弟的表现，也许是过了一百年，已经不再悲痛了，弟弟的逗比属性，父亲的大度，或许都是为了让玩家能够轻松些。而他们提的最多的是，<strong>希望</strong>。</li>
<li>《仙逆》的结局，作者写了好几个场景，王林和不同的女孩在一起的场景。我觉得一方面，那些女孩代表王林不同的时期，也爱的是他不同的地方。另一方面，是作者的美好祝愿吧。</li>
<li><strong>如果有平行宇宙，那就有一个林克和米法在一起的世界吧。</strong></li>
<li>“林克，我好像再也无法像以前那样…和你一起玩了。”。</li>
</ul>
<p><img src="/2019/01/29/%E5%A1%9E%E5%B0%94%E8%BE%BE%E4%BC%A0%E8%AF%B4%E6%97%A5%E8%AE%B0/mifa.jpeg" alt="图片加载失败"></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>搞不清楚关于图片版权的问题，网上随便搜索的图，我也不知道出处和版权声明，未作商用，希望见谅，有其他要求请邮箱联系删除。</li>
</ul>
]]></content>
      <categories>
        <category>Prose</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速准确描述问题</title>
    <url>/2019/08/15/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%87%86%E7%A1%AE%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>经常有人问我问题，我也经常需要请教别人问题。我认为越真实扼要的描述，越有助于别人理解。</p>
<a id="more"></a>

<h2 id="不要首先描述推断"><a href="#不要首先描述推断" class="headerlink" title="不要首先描述推断"></a>不要首先描述推断</h2><p>很多人一上来就问一个让人不明所以的问题，其中的信息80%源于他们自己的推断，同时对真正的需求闭口不谈。</p>
<ul>
<li>常见句型一：我已经照着教程每一步做了，为什么还是不行？<ul>
<li>这样说，只能让人觉得，教程错了，或者是过时了，软件更新换代很快，很多资料都不兼容新版本，但也有很多东西是可以控制版本的，如果环境控制好了，做个demo依然是ok的。</li>
<li>所以，是人做错的可能更大，而这时的信息对找出错误却毫无帮助。</li>
<li>请直截了当的描述使用了什么教程，走到了哪一步，出现了不同的结果，错误信息是什么，你期望的是什么。最后再是你的推断，比如教程错了，不兼容了。</li>
</ul>
</li>
<li>真实案例一：如果我的程序core dump了，那么容器会消失吗？<ul>
<li>容器这个词很难定义，要是说运行时的状态，那很显然是消失了，也就是<code>docker ps</code>看不见这个容器，<code>ps aux</code>也看不到这个容器相关内容。</li>
<li>如果指硬盘上的信息，那是不会消失的，也就是用<code>docker ps -a</code>能够看见。</li>
<li>最后这个同学的问题是，在启动容器时使用了–rm参数，使得容器停止时删除了硬盘上内容。</li>
<li>可以发现，他问的第一句话没有能提供准确的信息，甚至有很多噪音，比如core dump。</li>
<li>遇到问题应该冷静描述过程和期望。</li>
<li>略好一点的问法：容器停止时，会被删除吗？</li>
<li>但这一点也不make sense，要是停止就删除，还要ps -a做什么？而且这个问题可以搜索得到答案，不是一个值得拿来challenge别人的问题。拿出来问的问题，应当是不太好说清楚，不能搜索到完全类似的情况的。</li>
<li>觉得很nice的问法：我用命令<code>docker run --rm -v xx --net xx -p xx xx</code>启动了一个容器，容器停止后不见了，<code>docker ps -a</code>找不到。</li>
<li>这样能让更熟悉某个东西的人，更快地帮助你解决问题。</li>
</ul>
</li>
</ul>
<h2 id="需求优先"><a href="#需求优先" class="headerlink" title="需求优先"></a>需求优先</h2><p>在公司经常会因为不知道怎么实现一个需求，然后去问一问同事，这时候很可能一开口就是，”如果我使用xx技术，可以实现yy效果吗？”。这有几个问题。</p>
<ul>
<li>陷入了非常细节的部分，某个技术能否实现某个事情，正是你这个程序员要做的事情，你做出来之前，那就是无法实现，做出来了，那就是落地成功了，所以问有什么用呢？</li>
<li>也许你是想要确认你的思路，那应该更准确的描述，描述你打算怎样去实现，直接说出你的整个设计，让高手听听是否有问题。</li>
<li>没有给高手提出更优解的机会，因为没有描述原始需求。<ul>
<li>举例：写一个程序，有两个输入a、b，一个输出c。现在做测试的时候，你找到了输入a，但是没有输入b，可能是因为测试环境里没有输出b的程序，可能是因为公司的防火墙，也可能是因为你不知道有。那很可能找到一个人，开口就问，你能不能setup一个输出b的程序给我？</li>
<li>别人也不知道你拿来做什么，如果他不多问，可能他就真的去帮你找了。但实际上，你需要的只是一个输入，有现成的也可以work。为什么不说得更详细一些呢？</li>
<li>我的程序做测试，需要两个输入a、b，才能输出c，我已经通过xxxx找到了a了，输入b应该怎么办？（同时还可以说说为什么不能用和a同样的方法实现b）。</li>
<li>而且，能更好地让别人知道你在做什么，有时候可能你的方向都错了，现实是，你这个程序应该输入a和d就可以生成c，而不是a和b，那这时候就是错误的方向越走越远。</li>
</ul>
</li>
</ul>
<h2 id="向高手迈进"><a href="#向高手迈进" class="headerlink" title="向高手迈进"></a>向高手迈进</h2><p>最后想说的一点是，多问问自己，多搜索，多过几遍流程。<br>有多余时间的话，阅读所有相关手册，而不是出了问题大海捞针，首先熟悉操作手册，能够免除非常多的问题，比如容器rm参数，看懂了就不会有那个问题。<br>这一点我自己做的也不是很好，有时候喜欢从mentor那里得到一个quick answer，有能够让搜索引擎听懂的描述，也不愿意去搜索结果中找答案。这个得慢慢熟悉情况，多尝试了。<br>与君共勉。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Interaction</tag>
      </tags>
  </entry>
  <entry>
    <title>如何飞行</title>
    <url>/2019/12/30/%E5%A6%82%E4%BD%95%E9%A3%9E%E8%A1%8C/</url>
    <content><![CDATA[<p>在浩瀚宇宙里，仅有一个你，该多么孤独。</p>
<a id="more"></a>

<h2 id="许愿"><a href="#许愿" class="headerlink" title="许愿"></a>许愿</h2><ul>
<li>生日你都要问我，许了什么愿</li>
<li>每次我都说，说出来就不灵了</li>
<li>其实我什么愿也没想出来，眼里都是你</li>
</ul>
<h2 id="爱你"><a href="#爱你" class="headerlink" title="爱你"></a>爱你</h2><ul>
<li>讲个笑话</li>
<li>我真的想过</li>
<li>2020年结婚，是一月一号还是五月二十号更好？</li>
</ul>
<h2 id="年度歌单"><a href="#年度歌单" class="headerlink" title="年度歌单"></a>年度歌单</h2><ul>
<li>单曲循环了两百多次</li>
<li>我骗你说只是因为忘记关机了</li>
<li>还说歌真的很好听</li>
</ul>
<h2 id="晚安"><a href="#晚安" class="headerlink" title="晚安"></a>晚安</h2><ul>
<li>你是我的安眠药</li>
<li>也是我的睡不着</li>
</ul>
<h2 id="生也有涯"><a href="#生也有涯" class="headerlink" title="生也有涯"></a>生也有涯</h2><ul>
<li>听说闰正月要再过两百多年，在我永远到不了的时候</li>
<li>听说长江白鲟已灭绝，在我还没见过的时候</li>
<li>听说你找到了想要的幸福，在我不曾察觉的时候</li>
</ul>
<h2 id="克己复礼"><a href="#克己复礼" class="headerlink" title="克己复礼"></a>克己复礼</h2><ul>
<li>不见你时，甚是想念</li>
<li>见了你又无所适从</li>
</ul>
<h2 id="词不达意"><a href="#词不达意" class="headerlink" title="词不达意"></a>词不达意</h2><ul>
<li>上次你发了一张词不达意的海报</li>
<li>我读出的全是孤独</li>
<li>后来才懂你有多喜欢那个人</li>
<li>也好，词不达意</li>
</ul>
<h2 id="书海"><a href="#书海" class="headerlink" title="书海"></a>书海</h2><ul>
<li>要是寻到黄金屋，便可带你遨游世界</li>
<li>要是寻到颜如玉，就不用再念念不忘</li>
</ul>
<h2 id="世界末日"><a href="#世界末日" class="headerlink" title="世界末日"></a>世界末日</h2><ul>
<li>假使我问你</li>
<li>明天就是世界末日，我能抱你一下吗</li>
<li>你可听出这俏皮中的可怜</li>
</ul>
<h2 id="醉美人"><a href="#醉美人" class="headerlink" title="醉美人"></a>醉美人</h2><ul>
<li>我不喝酒，所以从没想象过醉倒在你怀里</li>
<li>后来才懂，得你拥抱</li>
<li>比苦酒入喉更难</li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>将故事写成我们</title>
    <url>/2019/10/07/%E5%B0%86%E6%95%85%E4%BA%8B%E5%86%99%E6%88%90%E6%88%91%E4%BB%AC/</url>
    <content><![CDATA[<p>少年时，每天一小吵，三天一大吵。摘两句浅薄文字，以为看透了生死。两三周就要写一篇苦水，不管人看不看得懂，听不听得惯，往日志里一扔，自以为独立。</p>
<a id="more"></a>

<h2 id="最难熬的是如果"><a href="#最难熬的是如果" class="headerlink" title="最难熬的是如果"></a>最难熬的是如果</h2><p>以前写了好些感受，后来觉得尽是在无病呻吟，就都删掉了。现在看来，是久病成良医，懂得什么会痛，怎么疗伤。</p>
<p>那时候最喜欢换位思考，将心比心。我想我付出这么多，你总该多爱我一点。我为你跨越山海，见你时，你却没有笑脸。我想一天二十四小时黏在你身边，你却总想逃离。</p>
<p>我以为痛苦皆源于爱而不得，可又不像，因为那些都过去了。你是个不甘寂寞的人，身边的人来来往往。</p>
<p>我也不知道该怎么用文字，描述这种奇妙体验，这种无奈心情。</p>
<p>我想，是潜意识的爱恋，和不停幻想的未来，捆绑了梦境，就像盗梦空间，在潜意识里放进一个萌芽，便再也无法逃脱。</p>
<p>每次见你，你欢笑，没有声音，身后是无限光亮。</p>
<p>如果我再成熟些，是不是就能留下你了。</p>
<p>不要试图提醒我忘了什么，也不要使我清醒，假装词已达意吧。</p>
<h2 id="进化生物"><a href="#进化生物" class="headerlink" title="进化生物"></a>进化生物</h2><p>写下进化两字，想到三体里写到，</p>
<blockquote>
<p>当人类进入太空，人已经不在是人。</p>
</blockquote>
<p>虽然我没有上太空，但从农村到城市的变化，亦是天翻地覆。我没觉得两者是高低之差，像不同的天地，空气不同，像两个小说世界，无法比较。</p>
<p>进化就是最终的解药。</p>
<p>得不到总是要失落的，直到不想要了。见的多了，就明白过去并不美好了。</p>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>当我写Paper的时候，我在想些什么</title>
    <url>/2019/12/21/%E5%BD%93%E6%88%91%E5%86%99Paper%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>其实一开始我是拒绝的。</p>
<a id="more"></a>

<h2 id="学徒时代"><a href="#学徒时代" class="headerlink" title="学徒时代"></a>学徒时代</h2><p>到现在，投身计算机三年多了，有时候觉得自己已逃脱学徒时代，这也是我对校园感到厌倦的原因之一。</p>
<p>在公司打工的时候，又能找到做学徒的感觉，那种，我什么都做不好的感觉。在为人处事上，怎么和前台中台以及HR小姐姐愉快聊天，怎么和老板打德扑，在技术上，怎么写好代码，不至于让Mentor在我的Commit下疯狂Comment。</p>
<p>事实上，我特别喜欢我的Mentor，在CPP这个领域，他给我一种错觉，没有他不懂的方面。我也不知道喜欢这个词是否准确，只是用崇拜和钦佩又少了些意思，因为他玩手机的样子，和媳妇甜言蜜语的样子，实在好笑。我总觉得那就是以后的我。</p>
<p>回到学校，认真体会剩下的学生时代，我承认我有一小段时间的无意义快乐，比如天天打桌球，每天工作一小会就开始玩游戏。这种特别的无意义生活，总让我有回到童年的感觉。那时候能看上一整天的电视，打上一整天的游戏，什么都不用管。我一想到我将变成怎样的巨人，在某个瞬间就学会担负责任，享受大家信任的眼光，我就兴奋且害怕。在很多人看来这是一种能力提高，变得懂事，可是呢，在我看来，更像是抹掉了许多无意义个性，保留别人喜欢的特质。我想做个怪人，仍然得你喜欢。</p>
<p>现在学期末尾，又被迫充实了一把，洋洋洒洒写了六七页的全英文Paper，我知道其实不算多，但对我真是一种煎熬。这已经不是学徒的感觉了，我回到了初中，被老师指着鼻子骂不识好歹。我想大家把我当个废物，这样我就不用受指责，但同时我又害怕我失去了许多隐藏好处，毕竟不会有人想和废物共事。</p>
<h2 id="一字并肩"><a href="#一字并肩" class="headerlink" title="一字并肩"></a>一字并肩</h2><p>前两天，一个说自己不喜欢指责的人，指责了我。恕我直言，难以感同身受。但后来我又想到，人总是这样，委屈就要推出来，说给别人，让别人也委屈一下，自己就舒服了。于是，我坦然应下了。</p>
<p>与此同时，老师和博士大哥，轮番上阵带领我写作。当大哥反问我，论文里的某一句是什么意思的时候，我一脸懵逼，想这一两个词不够明确么。现在我才懂得这个概念是什么，举例说明。</p>
<p>假如我用一句，The client builds a connection with the broker. 我就得花点笔墨来描述，具体在什么时间建立连接，这个连接共享什么信息，需要维护多久，甚至，为什么可以建立连接也得说明一下，毕竟总得有个address在前。</p>
<p>在这里我羞耻地用了一字并肩，其实我在拖后腿。</p>
<h2 id="想"><a href="#想" class="headerlink" title="想"></a>想</h2><p>最后，点一下题，正因为我此时还在接着修改Paper，所以以上所有文字，都是我写Paper时候的所想。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>心山月</title>
    <url>/2019/11/25/%E5%BF%83%E5%B1%B1%E6%9C%88/</url>
    <content><![CDATA[<p>我知道那不是山。</p>
<a id="more"></a>

<h2 id="灯火阑珊"><a href="#灯火阑珊" class="headerlink" title="灯火阑珊"></a>灯火阑珊</h2><ul>
<li>你问我见到你怎么那么开心，我想了又想，可能是因为心想事成吧</li>
</ul>
<h2 id="何处为家"><a href="#何处为家" class="headerlink" title="何处为家"></a>何处为家</h2><ul>
<li>未来，要养一只猫或者一只狗，总之你喜欢的就好，取名叫小鬼</li>
<li>生一双儿女，叫小妖小怪</li>
<li>别看了，你就是那个大魔头</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul>
<li>读书时，我们每天相伴了十六个小时</li>
<li>你总担心很快就要分离</li>
<li>我只好说，会有很多很多，陪你二十四小时的时间</li>
</ul>
<h2 id="求婚"><a href="#求婚" class="headerlink" title="求婚"></a>求婚</h2><ul>
<li>我想你先拒绝我九十九次</li>
<li>然后再答应我</li>
<li>这样你就能感受这快乐一百次</li>
</ul>
<h2 id="最伤心的事"><a href="#最伤心的事" class="headerlink" title="最伤心的事"></a>最伤心的事</h2><ul>
<li>你看不到这一句</li>
</ul>
<h2 id="愧疚"><a href="#愧疚" class="headerlink" title="愧疚"></a>愧疚</h2><ul>
<li>我经常想起你</li>
<li>却想不起任何你喜欢的东西</li>
<li>我才明白愧疚源于何处</li>
</ul>
<h2 id="一池春水"><a href="#一池春水" class="headerlink" title="一池春水"></a>一池春水</h2><ul>
<li>今天路过一座桥，看桥下水面波纹阵阵</li>
<li>想起从前老师在讲台上，又拍又呼地说，吹皱一池春水，皱字极妙</li>
<li>要我说，也没有别的字可用了</li>
</ul>
<h2 id="一生"><a href="#一生" class="headerlink" title="一生"></a>一生</h2><ul>
<li>有人说，我娶你，比我爱你更令人感动</li>
<li>可一想到你，我就觉得结婚不过是我们共同面对的一件小事</li>
<li>我要你的一生，你可愿意？</li>
</ul>
<h2 id="想了太多"><a href="#想了太多" class="headerlink" title="想了太多"></a>想了太多</h2><ul>
<li>我想，菩萨能算八十一难，那他一定能算到，我会想什么</li>
<li>连同我在想菩萨算我想什么这件事本身</li>
<li>那我应该在什么时候停止呢，幸好，对于菩萨而言，在任何时刻停止想象，都是命中注定</li>
<li>可惜你比菩萨还要难对付，猜也是错，不猜也是错</li>
</ul>
<h2 id="忽远忽近"><a href="#忽远忽近" class="headerlink" title="忽远忽近"></a>忽远忽近</h2><ul>
<li>说来也是好笑</li>
<li>你喜欢的人在天的另一边</li>
<li>竟让我体会到什么是伸出手却又收回</li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>我的大学</title>
    <url>/2020/04/04/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="既是完结，也是序章"><a href="#既是完结，也是序章" class="headerlink" title="既是完结，也是序章"></a>既是完结，也是序章</h2><h3 id="海阔凭鱼跃"><a href="#海阔凭鱼跃" class="headerlink" title="海阔凭鱼跃"></a>海阔凭鱼跃</h3><p>在去年七月，作为开发实习生工作了两个月，体会了离开学校的感觉。我被前所未有的孤独袭击，切实感受到，书里说的，上海看不到天，抬头就是两道矗立的高楼，一直延伸。</p>
<p>我那时候脑子里在想，这世界车水马龙，与我无关。在窄小的租房里躺下来，想象着从天上看我的样子，先是一张床，一个人，然后镜头慢慢拔高，看到这栋楼，这个街道，这座城市。甚至看到这颗星球，这个宇宙。半梦半醒之间，我听不到任何这世界的喧嚣，没有任何联系。这就是我感受的孤独，我开始思考为什么离开学校才有这种感觉。</p>
<p>我那个时候没有意识到，其实一直以来，都是这样，都在被孤独侵袭。只不过，求学的时候，不管我是冷是热，总有那么多同学陪伴身边，很难失去什么。那些表面的、被迫的热闹，无形中解去了这种孤独。我来自一座小城，只靠走路就能到任何一个同学的家。我习惯这种被羁绊包围的感觉，二十年。</p>
<p>现在，什么都没有了。如果想念一个人，一定要说出来，要有时常的联系。我很讨厌这种多少带一点计算的社交关系，我的时间不再足够浪费，每一次娱乐都必须把各位放上天平，细细衡量。坦白说，我不喜欢忙碌于社交，我也不会习惯，但我被那种感受束缚，导致我倍感孤独。</p>
<p>于是，没过几天，我就清醒了过来。</p>
<p>没事，都一样。</p>
<p>不管是过去还是现在，情况没有更好也没有更坏。就像一个习惯了的东西突然没了，暂时地不适应，但细想想，那些乱乱的热闹，没有什么用。</p>
<p>真遗憾，没有什么用。</p>
<h3 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h3><p>高中毕业，确是我的一次人生巅峰。</p>
<p>小白说我是有勇有谋，胆敢在高考志愿上填不调剂，也不怕掉档。我没想那么多，只是觉得，如果要我去学生物、化学一类的，我会疯掉吧，更何况，只是提前批而已，掉了也无关痛痒。</p>
<p>那时被交大的提前批提档，因为够不到工科试验班，我又拒绝调剂到生环平台，他们就把我的档案还了回来。到了本科一批，因为是在县里读的三年高中，得到贫困计划的照顾，我被直接录取到交大电院。</p>
<p>我只知道电院里有计算机，丝毫不清楚这一次阴差阳错，对我的人生有多大影响。</p>
<p>提前批的专业都是大平台，这种大平台招生在后面几年愈演愈烈，参与的专业越来越多。招进来之后，高考分数会占很大比重，比如80%，还有一部分根据大学里的一次考试决定。最后，按照这个综合排名，各位再选一次专业，然而大平台里有二十多个专业，总也有许多不如意的人，选到自己不喜欢的专业。我不太清楚各个专业的具体情况，但电院确实是近年的热门，需要相当高的位次才能进入电院。</p>
<p>因此，以我当初被退档的经历来推算，我的成绩应当是垫底部分。如果我被大平台录取，十有八九是不会进入电院了，往后余生，尚未可知。</p>
<p>那一年，电院直接招收的学生，在分专业时，高考分数只占比50%，还有50%考一次关于编程的试。我没有什么编程经验，唯一有点关系的，是在魔兽争霸的地图编辑器里，制作游戏地图，我后来明白那就是在编程，只不过我是ui去套的，没有直接写代码。侥幸的是，我学的还可以，考试分数也相当不错。最后综合排名，还在中上水平。</p>
<p>最终，我进入了软件学院。</p>
<h3 id="寄宿生活"><a href="#寄宿生活" class="headerlink" title="寄宿生活"></a>寄宿生活</h3><p>这可能是我第一次住在学校里，如果不算幼儿园时期，中午在学校里睡觉的话。</p>
<p>我没有遇到什么刁钻的室友，也没有奇怪的寝室氛围。我们这个宿舍，完整坚持到了毕业。这并不容易，真的。就在隔壁就有因为各种原因，暂缓学业，从这栋楼搬走的同学。有趣的是，我的三个室友，全都顺利读了本校的研究生，途径还各不相同，实是奇闻。</p>
<p>如果我没有记错，我的生日应该是大学后第一个到的。我们几个室友一起出去吃饭，自那以后，每个室友生日都要一起吃饭。几年来，学校周边的店大都吃过了。</p>
<p>我大学的一个遗憾，没有找到女友。幸好看室友们恋爱，也是弥补空白。老实说，这样近地感受一个人恋爱时的状态，让我经常陷入困惑。</p>
<p>我不敢问，但我想的是，“就这还不分手吗？”。</p>
<p>我没有劝分的意思，也不是嘲讽，我一方面是看不懂，另一方面是羡慕。</p>
<p>我觉得，人的缺点这么多，要有多喜欢，才能坚持下去。我们时而偏执、时而幼稚，时而奔放、时而颓唐。我没有一直勤勤恳恳，也没有一直快快乐乐，我也会给你带来烦恼和麻烦。即使这样，还要和我在一起吗。</p>
<p>后来我就把目标改成了，寻找一个想和我一起探讨这个问题的朋友，任务期限是一辈子。</p>
<h3 id="编程大师的鸡汤"><a href="#编程大师的鸡汤" class="headerlink" title="编程大师的鸡汤"></a>编程大师的鸡汤</h3><p>在我大学初期，低迷的日子里，我沉浸在图书馆二楼的文学阅览室里许久。</p>
<p>我知道，那么多的书，我看不完，但我真享受被这么一屋子的书，包围的感觉。那时候我看得最多的是推理小说，主要就是岛田庄司、绫辻行人、东野圭吾等。侦探们沉着冷静、身手敏捷、头脑灵活的样子，让人十分沉迷。</p>
<p>九把刀的小说我也读了好几本。《爱情，两好三坏》恰好击中了我那时的心境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">几乎，我们无法规定真命天子在第一时间出现。</span><br><span class="line">几乎，我们也没有办法强制喜欢的人也得喜欢自己。</span><br></pre></td></tr></table></figure>

<p>在阅读文学作品的同时，我也顺带着找一些编程相关的书籍，充分发挥这巨大图书馆的作用。也就是那时，受到了蛊惑。诸如《软件开发者路线图》、《程序员修炼之道-从小工到专家》、《编程之魂》、《黑客与画家》一类的书，让我觉得，编程大师，真酷。从此踏上了一条不归路，梦想成为最厉害的编程手。</p>
<p>在我学习的这几年里，我见到的东西越来越多，这些执念也变得没有那么深了。什么大师，还没有一套房来得安逸。口号只适合喊一喊，也不能当饭吃。而且，我渐渐发现，编程很多时候，都不只是编程，搞清楚在做什么，以及源动力在哪里，是更重要的事情。</p>
<p>只是，在我真正陷入编程那一刻：世界是复杂的，编程是简洁的。</p>
<p>我非圣人，没能时刻高洁。</p>
<p>但写代码时的我，内有激情，外有光辉。</p>
<h3 id="电竞少年梦"><a href="#电竞少年梦" class="headerlink" title="电竞少年梦"></a>电竞少年梦</h3><p>我有几个从小学就认识的网友，我们在一个qq群里相遇。时至今日，我们仍然会聚在一起玩游戏。我从不觉得腻，游戏嘛，玩一辈子都行。</p>
<p>我始终记得小时候玩跑跑卡丁车、梦幻西游、冒险岛的时光。和很多人对这几个游戏的记忆不同，我那时候很穷，就是字面意义上的穷，没有多的零花钱。所以我从来没有往游戏里充过钱。</p>
<p>因为不能充值，我对梦幻西游的概念，很长一段都停滞在十级之前，超过了十级，就要按时间收费，点卡不足账号就没法登录。尽管如此，我对十级前的剧情仍然乐此不疲，一帮小伙伴们甚至想着，如果永远不关机，是不是就可以一直欠费地玩下去。</p>
<p>那时候正是冒险岛的鼎盛时期，游戏职业也只有四个。我纯粹是因为觉得弓箭手很帅，才选择了这一职业，巧合的是，射手村那块训练场，可能是所有玩家都忘不掉的记忆。</p>
<p>我那时不懂什么叫做攻略，也不明白什么是外挂。学习技能全看哪个技能好看，也不担心技能点不够。一整个暑假刷上几十次的组队任务，凑一身破烂似的装备。</p>
<p>后来的事情，也不用详说，各有各的曲折，我们就这样，离开了那片热土。</p>
<p>在大学里，玩守望先锋、绝地求生的时候，我才恍然悟到，时光是残酷的，连电子游戏也不能幸免。即使它们可以永远刻在某块硬盘上，即使还能用技术还原曾经的服务器，我也无法触及哪怕丝毫的过往。</p>
<p>不只是游戏，那些小说、动漫、玩具，都会一一远去。大人们看到金庸的书被拍成电视剧，和我今天，看到《全职高手》、《斗罗大陆》、《斗破苍穹》、《庆余年》，是完全一样的逻辑。</p>
<p>这就是我从游戏里学到的道理：轮回之中，得见永生。</p>
<h3 id="为中华之崛起而读书"><a href="#为中华之崛起而读书" class="headerlink" title="为中华之崛起而读书"></a>为中华之崛起而读书</h3><p>不要误会，我不像是会把，这么掷地有声的话，说出来的人。</p>
<p>但我曾经是， 我无数次想象，老师让我站起来回答，为了什么而读书。然后我大声告诉他，为中华之崛起而读书。</p>
<p>在我敢于说这句话的时候，周围没人相信。等到了周围人都把我的一言一行放大来的时候，我已经不敢说这句话了。</p>
<p>在学校里，我们都忙于找实习、找科研项目，想要升到好的学校，想要进入到优秀的企业。我觉得这就是环境带给我的错觉，我们都会被环境同化，当然这并不是坏事，适应环境是本能，但是，第一名总是只有一个，一个环境里的人越多，压力就越大。</p>
<p>我看到许多，说自己身在名校，却越过越忧虑、自卑的人。我知道这也是事实，同侪压力在名校里格外严重，正所谓天外有天，人外有人。</p>
<p>我必须说明，也可能是因为我太菜了，直接躺平了，不想努力了，所以才能一脸无所谓地说，都没关系。努力是好事，但我不希望努力的同时又很难过，如果你一定要保持难过，可以不用听我废话。</p>
<p>接下来我再细说我的观点。</p>
<p>第一，做不到就不做。我总觉得，有许多话，我们从小学到大，等到了自己身上，却总是忘了运用。我说扬长避短你信，说攻其不备你也信，但就是不肯相信，自己是有短处的。既然总是玩不赢，我不玩了还不行吗？不再去想排名如何，想学就学，关注点滴的成长。水滴石穿你信，让你每天看自己的进步你又看不见了。</p>
<p>第二，为了快乐而读书。其实倒不如说，我所有的一切都是为了快乐，甚至不只是短暂的快乐，也包括长远利益，这也是为什么能够在偶尔枯燥的学习中坚持下来。我始终相信，读万卷书，行万里路，是教我怎么快乐的，所以，每当有人说，学了越多越不快乐的时候，我以为问题都是在自己身上，自己误解了读书的意义。</p>
<p>第三，百折不挠。这是最重要的一点。<br>我们总是梦想成为英雄，如果说英雄都是不屈不挠的，你肯定认可，这种故事听了太多了。到了自己身上，一点小挫折就已经倒下，却自命不凡要做英雄。我这样说，一方面是劝诫从磨炼自身开始努力，一方面是，没那个气魄就别想做英雄了，不想着做英雄，也就不会那么多不快乐。</p>
<p>我以为前两点多少是带有偏见的，因为真的也有人，怎么学也学不会，真的也有人，做不到就是绝境，退无可退。我的经历让我对此无法感同身受，但我深表理解。那种时候，我只能说，在那以前，要多想。处在那个境界的灵魂，只能自我拯救。</p>
<p>别忘了，百折不挠。</p>
<h3 id="逃课的气节"><a href="#逃课的气节" class="headerlink" title="逃课的气节"></a>逃课的气节</h3><p>忘了叫什么名字，说是高中毕业生必读的一本书，那时候不懂什么是鸡汤，就感觉书里道理很多，现在看也有不少毒鸡汤。书里说，讲得不好的课就应该逃掉，如果隔壁学校有名师名课，也应该跑去听。</p>
<p>我是真的佩服那种形式的努力：跑到其他学校听课，做志愿者，各种社团赶报告。这些事情都充斥着酷味道，大概就是值得发朋友圈的那种酷。不过，搞那些花哨操作，和学习没什么两样，有人搞得好，就有人搞得不好。学习不会让每一个人都如意，那些花哨操作也是一样，从来就不缺少负面消息。</p>
<p>我开始是个初学者，跟着后面看热闹，后来也是运气不好，没有继续下去。</p>
<p>回到正题，因为听信了”谗言”，我对一些不想听的课，都是能翘就翘，对带个电脑去，坐在教室里做其他事情，这种认真应付的手段更是特别看不起，因为它就像是屈服了一样。而且，应付就应付，认真就认真，在那里认真地应付，实在是没有气节。</p>
<p>还有像让人帮忙点到，又要欠人情，又显得奇怪，你不想听不去，你让去的人帮忙签到，这是看不起谁呢。我一向愿赌服输，翘就翘了，没抓到是我运气好，抓到我也认栽，大多数时候都懒得想办法签到。</p>
<p>现在想想，真傻，一点也不圆滑，只是我翘课次数也并不多，不管怎么操作，影响都不是很大。</p>
<p>为了避免这种两难境地，还是别翘课了，且听他废话吧。</p>
<h3 id="扛不住变迁的食堂"><a href="#扛不住变迁的食堂" class="headerlink" title="扛不住变迁的食堂"></a>扛不住变迁的食堂</h3><p>我很早就明白了，事物一成不变是种错觉。</p>
<p>我只是没有用心观察周遭事物的变化，才没有意识到，小城也会不停变化。但说起来，外婆家就不怎么变化，二十多年也是一个样子。似乎城市化越高的地方，样貌变化就越快。</p>
<p>让我难受的，并不是变化本身，而是两种截然不同的环境，带给我们的认知差异。</p>
<p>我刚到学校时，就有前辈说华联是什么样子，但我到的时候，那一块地方的商家全都清空了，不出校园就能吃烧烤的经历我是一点都没有。还没等到重新开业，没等到那些记忆让我也能共享一下，全新版本的华联就来了，还换了个名字，叫玉兰苑，有了全新的记忆，鸡蛋灌饼、麻辣香锅、奶茶。</p>
<p>再到后来，第二餐厅一楼也全部撤换。因为宿舍在西区，我前两年都没怎么吃过那个地方，直到第三年专业课的教室都在东区，才经常吃二餐的。我刚爽了几顿那个干挑面，整个又给换了，而且刚好在新学年的时候开业，新生们可能都不知道这是大装修了。如今都是些价格颇为昂贵的品牌连锁店，质量看起来是有保障了，可惜费钱。</p>
<p>这又是一次轮回，只是我的角色变换了。</p>
<h3 id="面壁人"><a href="#面壁人" class="headerlink" title="面壁人"></a>面壁人</h3><p>在公司上班，和人交流的时候，脑海里跳出了一句话。</p>
<p>“我怎么知道您是不是正在工作呢，面壁者”</p>
<p>我看不出同事们，是因为工作而不厌其烦地和我交流，还是说我的问题确实还可以，没有让他们厌烦。</p>
<p>尤其是经常要和人交流的HR这类职业，越是厉害的HR，越是浑然一体，工作就像是本能，让人丝毫无法察觉，是不是已经被下了评分。</p>
<p>在我初中高中的时候，我会反应过来，小学里的某件事情，来龙去脉是怎样的，我当初做错了什么，误会了什么。</p>
<p>等我到了大学，我意识到我初中高中又做错了什么了。之后，这类反应变得越来越快，不再需要几年的时间去反省，因为很多错误是类似的。</p>
<p>只需要几天，或者是另外一件事情的触发，就想通某些事情是怎么发生的。</p>
<p>可是，破壁真是件累人的事情。</p>
<h3 id="不存在的问题"><a href="#不存在的问题" class="headerlink" title="不存在的问题"></a>不存在的问题</h3><p>我第一次参加社团面试，时间是在晚上，去了约定的某一间教室。我还是头一次到那栋楼，连路都找不到，而且教室的灯都熄灭了。</p>
<p>几经波折，看到了学长学姐，得知预约的教室没有按时打开，我们又换到另外一间。那时我在心中腹诽，这办事也太不靠谱。</p>
<p>学姐问了我好些问题，有一个题我始终记得：</p>
<p>“如果社团的事情和你自己的安排冲突了，比如学业什么的，你会怎么做？”</p>
<p>我下意识地就说，怎么会呢？</p>
<p>为什么社团的事情会和安排冲突呢，本来不就应该避开吗？要是我没时间，我就不参加社团了。</p>
<p>学姐只说你别管，你就假设有这个问题怎么办。</p>
<p>我笑了笑，没说出任何话来。</p>
<p>后来发现世上有太多，类似的问题。从来就不会派上用场，还非得问，美其名曰看你的反应能力。我觉得都是电影看多了，鸡汤喝多了，以为那些小技巧能攫取成功。</p>
<h3 id="软件学院"><a href="#软件学院" class="headerlink" title="软件学院"></a>软件学院</h3><p>软件学院有独立的大楼，以前是作为独立院系存在的，现在算是电院下属，院中院。那些楼呈环状，几乎所有的部分都是联结起来的，却还划分了一到五号楼，初时让人好生费解。</p>
<p>一开始的记忆是二号楼，其实就是指那一间演播厅，大概能坐下几百人。入学欢迎仪式，后来的分专业说明，毕设安排都在这里进行。</p>
<p>我终于见到那个在中文版CSAPP上写序的男人，我们的院长。我觉得他颇为张扬，又有真知灼见，并且从不吝于分享。</p>
<p>第二次的记忆是三号楼，主要是三号一楼的两间教室。我们在这里上习题课，进行上机考试。最为难忘的是，大二一整个小学期都关在那个教室里写项目。</p>
<p>我那时没什么感觉，现在才了解，那一段经历是很难得的。和几个人朝夕相处一个月，深厚友谊是很自然的事情。</p>
<p>第三次的记忆是五号楼。五号楼是好几个实验室在的地方，我最早的班主任，一个研究生学长，就在五号楼这边。我那时觉得，那些一格一格的工作空间，看起来好酷。能够有个舒服的屏幕，放上喜欢的键盘，旁边再摆一排技术书籍，氛围就有了。</p>
<p>第四次，我嘻嘻哈哈地拍完了合影，记忆就变成了记忆。</p>
<h3 id="我向往的超级涵养"><a href="#我向往的超级涵养" class="headerlink" title="我向往的超级涵养"></a>我向往的超级涵养</h3><p>我遇到很多很多的人，但我最留恋和羡慕的，是那种花钱不计较，待人接物特别礼貌，一看就有个好家庭的人。我甚至在猜想，是不是被保护得太好了，让他以为这个世界如此美妙。而且看起来，这类人非常自信，有不少是因为他个人只要付出努力，就能攫取巨大的成功，如果他忽视掉努力以外的因素，譬如家境、譬如运气，可能会觉得世上的人不快乐，都是因为不努力。</p>
<p>写到这里，意识到落了俗套。我心里不觉得涵养和钱有关系，但又不得不承认，有些事，没钱做不出来。打车回家就是隐隐比等公交车来得爽快，没钱是无法逃掉束缚的。</p>
<p>我不知道什么时候我也能做到如此宠辱不惊。</p>
<p>宠辱不惊是我从大学里学到最特别的东西，因为见识了实实在在的风度，自然而然地心境愈发平和。可惜的是，年轻是另一种特性，我还是有相当的表现欲和幼稚，会把情绪写在脸上，我不曾后悔，我以为，年少不气盛，难道老了再动吗。</p>
<p>顺其自然，不同阶段做不同的人。</p>
<h3 id="学徒与熟练工与废物"><a href="#学徒与熟练工与废物" class="headerlink" title="学徒与熟练工与废物"></a>学徒与熟练工与废物</h3><p>用学徒自称，表示我需要更多的学习。</p>
<p>虽然书上说，只需要两三年，就能成为熟练工，但如今，我仍然时常认为，自己像个废物，都别说是个学徒了。有时候是自谦，有时候是真的被某些恼人的问题打击到失去自信。</p>
<p>久而久之，也渐渐习惯了这种状态，一会觉得自己天下第一，一会觉得啥也不会，就这样起起伏伏，度过了大学四年。</p>
<p>我在尽力让这个波动变小，好让我长期处于一种，知之为知之，不知为不知的稳定状态。</p>
<h3 id="天高任鸟飞"><a href="#天高任鸟飞" class="headerlink" title="天高任鸟飞"></a>天高任鸟飞</h3><p>毕业设计答辩，就像小学时候去医院打疫苗，进门前紧张得说不出话，进去就一瞬间清凉，结束了。</p>
<p>用现在的话说就是，就这？</p>
<p>问题问的多了，怕老师们觉得是做的不好，说的不好。</p>
<p>问题问的少了，又暗自担忧是不是工作没有亮点，不入老师的法眼。</p>
<p>就这样反复纠结中。</p>
<p>我，毕业了。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Graduation</tag>
      </tags>
  </entry>
  <entry>
    <title>数十公里的折返跑</title>
    <url>/2020/07/11/%E6%95%B0%E5%8D%81%E5%85%AC%E9%87%8C%E7%9A%84%E6%8A%98%E8%BF%94%E8%B7%91/</url>
    <content><![CDATA[<h2 id="可能是关于毕业的最后一段"><a href="#可能是关于毕业的最后一段" class="headerlink" title="可能是关于毕业的最后一段"></a>可能是关于毕业的最后一段</h2><h3 id="十个小时的奔袭"><a href="#十个小时的奔袭" class="headerlink" title="十个小时的奔袭"></a>十个小时的奔袭</h3><p>用掉了一天的年假，跑回学校办理各类手续，还清图书馆书籍，归档毕业设计，领取毕业证。只能说度过了精彩纷呈的一天，值得留念。</p>
<p>早上起了个大早，六点半就爬将起来。一上来就状况不断，折返了两次，一次是因为忘记把登记表电子稿发到手机，一次是忘记拿六级证书。</p>
<p>咬了咬牙，打了车，以为能追回时间。最后在九点左右抵达了学校。</p>
<p>刚到学校，我一直没去想，这次是不是最后一次回到学校，走到宿舍退宿的时候，阿姨一眼就认出了我，招了招手。我拿出钥匙，填了表，一分钟就办完了退宿。她问我现居何处，我们就寒暄了几句。问我什么时候走，我说搬完东西。</p>
<p>然后她问了一句，不回来了？</p>
<p>我想我的表情一定很难看，但我笑了出来，点了点头。我想如果我够脆弱，我会索要一个拥抱，可是我没有，所以我不脆弱。</p>
<p>后来就跑到了待了两年的实验室，补充打印几个毕设材料，令人崩溃的事情就来了。</p>
<p>前一秒看微信消息还是，老师中午到四点钟都在办公室，高高兴兴跑去，从一点四十等到了两点四十，足足浪费我一个小时，心里已经骂了一万遍。言而无信，小人也。</p>
<p>最后去跑落户的事情，路遇倾盆大雨，还要看朋友和老师对线。</p>
<ul>
<li>老师：你仔细看我们写的这个流程。</li>
<li>答：这个第三步具体去哪个办公室？教务处的哪里？</li>
<li>老师：这个我也不知道，你过去一楼问问。</li>
<li>答：？？？</li>
</ul>
<p>此时我已经心态爆炸，在微信上输出。</p>
<p>满怀愧疚地回到宿舍，为耽误了室友的出行连连抱歉，拖到五点半，几个人才从交大打车赶往外滩。</p>
<h3 id="交大牛逼"><a href="#交大牛逼" class="headerlink" title="交大牛逼"></a>交大牛逼</h3><p>在车上，室友安慰了几句一天的遭遇，我那一刻在想，身边总是有许多懂得人情世故的朋友，不谦虚地说，我也算一个。我们都会在别人不愉快时，给予帮助，并不介怀一些挫折。我作为受难者，能做的只剩下迅速恢复心情。</p>
<p>令我最快乐的事情，是那天想见的人，都能在同一个地点相见。</p>
<p>沿着外滩，每走几步，就遇到一个认识的人，一起喊交大牛逼。</p>
<h3 id="城市感"><a href="#城市感" class="headerlink" title="城市感"></a>城市感</h3><p>我很多次说起，上海的一些地方，不在我的想象里。</p>
<p>外滩附近极尽繁华，是我想象中的上海。只是往西再走几步，也能遇见一些老巷子，错综复杂的窄路。那瞬间也分不清我身在何处，像异国他乡，却也像故乡。</p>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Graduation</tag>
      </tags>
  </entry>
  <entry>
    <title>数字部件设计-FPGA课程笔记</title>
    <url>/2018/12/25/%E6%95%B0%E5%AD%97%E9%83%A8%E4%BB%B6%E8%AE%BE%E8%AE%A1-FPGA%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>数字部件设计课，使用Verilog在fpga板上做了不少东西，秒表、单周期cpu、流水线cpu、vga小游戏，小小总结一下。</p>
<a id="more"></a>

<h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><ul>
<li>Verilog是硬件描述语言，但是它跨度挺大，有四个层次。<ul>
<li>晶体管开关级。</li>
<li>逻辑门级。</li>
<li>寄存器传输级。</li>
<li>功能描述风格。</li>
</ul>
</li>
<li>我主要用到后两个层次，还是偏软件，前两个层次更低、更贴近硬件设计。</li>
<li>虽然表现形式有多种，但它的核心，我认为在于，操作的对象变为了电路，不管从何种层级描述，最终的结果就是电路。电路就两种，组合逻辑电路和时序逻辑电路。</li>
<li>组合逻辑就更多用到assign、wire。</li>
<li>时序逻辑就是@（posedge），&lt;=这样的形式。</li>
<li>还有很多关键字和语法，最终被翻译成怎样的电路，跟写法也有关系，并未深究。</li>
</ul>
<h2 id="Quartus"><a href="#Quartus" class="headerlink" title="Quartus"></a>Quartus</h2><ul>
<li>Windows上的一个FPGA开发平台，用来分析硬件描述，生成硬件相关的写入文件。</li>
<li>由于全量编译很慢，基本上也就真正写入硬件的时候用。</li>
</ul>
<h2 id="ModelSim"><a href="#ModelSim" class="headerlink" title="ModelSim"></a>ModelSim</h2><ul>
<li>Verilog模拟器，功能强大。</li>
<li>编译速度快，可以提取任意变量查看，可以模拟一些信号。</li>
</ul>
<h2 id="CPU设计"><a href="#CPU设计" class="headerlink" title="CPU设计"></a>CPU设计</h2><ul>
<li>TODO</li>
</ul>
<h2 id="VGA设计"><a href="#VGA设计" class="headerlink" title="VGA设计"></a>VGA设计</h2><ul>
<li>VGA信号就是先查表，看看行列各多少，时钟频率多少。</li>
<li>然后按要求输出RGB信号即可。</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>最后的暑期</title>
    <url>/2018/07/28/%E6%9C%80%E5%90%8E%E7%9A%84%E6%9A%91%E6%9C%9F/</url>
    <content><![CDATA[<p>转眼大学两年过去了，小学期黑屋来了又去，我们迎来最后一次暑期，下一次就要跑路实习了。学习之路仍然跌宕起伏，每次接触新技术会觉得有趣好玩，用了用就发觉问题还是有的，再用用就发觉还是自己太菜。</p>
<a id="more"></a>

<ul>
<li>偶尔会有挣扎的心理，想结束学徒生活，想见识更广阔的天地。但也害怕未知，害怕命运，就这样，浮沉中兜兜转转。 </li>
<li>从前很喜欢发情感相关的动态，直到感觉，不过是向大海丢石子，没有回应。可我真不想成为孤岛，该说些什么好呢，该做些什么好呢。</li>
<li>写应用写到有些倦了，没有实际项目，没有团队，写业务真没多大意思。好在有很多别的事情做， 希望假期里，不会太怠惰，还能学点东西。</li>
<li>十多年了，爱打游戏的状态，变不了。从冒险岛、梦幻西游，到绝地求生、逆水寒，变化真大。我以前从未想过，未来是这样的。我一直是那个只想要打败蝙蝠魔的少年，踏上了冒险的征途，可是我回不去了。</li>
</ul>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>夏天</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>私有云搭建</title>
    <url>/2019/03/01/%E7%A7%81%E6%9C%89%E4%BA%91%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>做一个能管理四十台物理机器的系统，初步设想使用openstack和openshift。</p>
<a id="more"></a>

<h2 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h2><h3 id="需求限制"><a href="#需求限制" class="headerlink" title="需求限制"></a>需求限制</h3><ul>
<li>整个系统只有一个公网ip，端口是稀有资源。</li>
<li>希望同时支持虚拟机和容器，虽然说openstack也能运行容器，但k8s才更像未来。并且我们也不需要虚拟机被经常调度，只在特定教学时期，需要快速配置一百台左右的虚拟机给学生使用。平时仍然是大规模使用容器和裸机。</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul>
<li>取5台机器部署openstack的核心组件，另取5台部署openshift的核心组件，其余30台准备好两套系统的计算节点部署要求。</li>
<li>openstack和openshift添加和去除计算节点都比较容易。</li>
<li>如果对于stateful有要求，较为容易实现的是做一个nfs服务。另一种方案是stateful应用只在有限的几台机器上调度，大多机器不保证持久化（对于k8s只需要设置调度策略即可实现，openstack需要配置nova节点的资源）。</li>
</ul>
<h2 id="前期实验"><a href="#前期实验" class="headerlink" title="前期实验"></a>前期实验</h2><h3 id="搭建小型多节点openstack"><a href="#搭建小型多节点openstack" class="headerlink" title="搭建小型多节点openstack"></a>搭建小型多节点openstack</h3><h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><ul>
<li>现在openstack组件也可以容器化运行，更容易管理，配置文件均在/etc/kolla/xxx下，可以单个组件的修改，重启容器。也可以使用脚本重部署。</li>
</ul>
<h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><h5 id="deploy-machine"><a href="#deploy-machine" class="headerlink" title="deploy machine"></a>deploy machine</h5><ul>
<li>参考官网，由于是python，使用venv会比较容易成功。</li>
<li>使用venv后，<code>password</code>和<code>global</code>文件仍然放到真实的<code>/etc/kolla/</code>下，然后就可以运行kolla-ansible了。</li>
</ul>
<h5 id="target-machine"><a href="#target-machine" class="headerlink" title="target machine"></a>target machine</h5><ul>
<li>pip install时，容易发生版本不足，需要更新，但是类似<code>requests</code> 这样的基础库，直接<code>pip --update requests</code>会报错，应该<code>pip --update --ignore-installed requests</code>。</li>
<li>安装<code>docker python SDK</code>，可能引发一个bug，必须卸载掉<code>docker-py</code>，然后安装<code>docker</code>。</li>
<li>其他软件使用yum或apt安装没有什么问题。</li>
</ul>
<h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><ul>
<li><p>一个令人困惑的参数<code>kolla_internal_vip_address: &quot;10.10.10.254&quot;</code>。</p>
<ul>
<li><a href="https://docs.openstack.org/octavia/rocky/reference/glossary.html" target="_blank" rel="noopener">官网的相关说明（最底部）</a></li>
<li>我通过在外部路由器，添加<code>10.10.10.0/24 interface</code>，并将<code>next hop</code>设为master节点所在的<code>physical switch</code>。</li>
<li>然后整个局域网内的节点都可以通过10.10.10.254访问到master了。</li>
</ul>
</li>
<li><p><code>network_interface: &quot;em1&quot;</code>，用来建立内网的网卡。</p>
</li>
<li><p><code>neutron_external_interface: &quot;p5p1&quot;</code>，用来做neutron出口的网卡。</p>
<ul>
<li><code>/etc/kolla/neutron-xxx/ml2_conf.ini</code>里有<code>external</code>的物理名称<strong>pn</strong>，这个会绑定物理网卡。</li>
<li>建立flag类型外部网络<strong>ext</strong>，绑定<code>ml2_conf.ini</code>里的外部网络名称<strong>pn</strong>，子网取物理地址的子集，<code>dhcp</code>设定不要冲突。</li>
<li><code>floating ip</code>可以从外部网络<strong>ext</strong>获取，然后绑定到内部ip，这样就能从<strong>pn</strong>访问虚拟机。</li>
</ul>
</li>
</ul>
<h5 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h5><ul>
<li>部署过程中可能会失败，我猜测原因是下载docker image超时了，只要重新运行一下即可，或者手动pull一下。</li>
</ul>
<h5 id="verify"><a href="#verify" class="headerlink" title="verify"></a>verify</h5><ul>
<li>通过NAT将<code>dashboard</code>转发出来，用户名为<code>admin</code>，密码为<code>password.xml</code>中的<code>keystone_admin_password</code>。</li>
<li>从<code>dashboard</code>上传镜像，size过大总是失败，原因不明。直接用<code>master</code>机器，<code>glance-cli</code>添加即可。</li>
<li>密钥对绑定无效，暂未解决。<ul>
<li><strong>临时办法</strong>：通过libvirt给镜像嵌入一个<code>root password</code>，先通过密码登录。</li>
</ul>
</li>
<li>没有部署存储节点，compute使用的是file类型，本地存储。节点上<code>/</code>有50G，<code>/home</code>有2T，dashboard显示节点的存储为50G，猜测是因为只能监测根目录大小，暂不清楚如何配置。<ul>
<li>想调整文件系统大小做个测试，发现<code>xfs</code>不能减小，遂放弃。</li>
<li><a href="https://www.cnblogs.com/kevingrace/p/5825963.html" target="_blank" rel="noopener">调整ext和xfs大小</a></li>
</ul>
</li>
</ul>
<h3 id="搭建openshift"><a href="#搭建openshift" class="headerlink" title="搭建openshift"></a>搭建openshift</h3><p>待续。</p>
<h2 id="正式部署"><a href="#正式部署" class="headerlink" title="正式部署"></a>正式部署</h2><p>待续。</p>
<h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><ul>
<li>libvirt</li>
<li>ethtool</li>
<li>netstat</li>
<li>traceroute</li>
<li>xfs_growfs</li>
<li>resizefs</li>
</ul>
<h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><ul>
<li><a href="https://docs.openstack.org/kolla-ansible/latest/user/quickstart.html" target="_blank" rel="noopener">Kolla Quick Start</a></li>
<li><a href="https://docs.openstack.org/kolla-ansible/latest/user/operating-kolla.html" target="_blank" rel="noopener">Kolla Operating</a></li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Unix</tag>
        <tag>Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手写Docker-CPP-2</title>
    <url>/2020/12/29/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Docker-CPP-2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上个版本中，我们实现了容器的基本操作。这一次将实现容器网络部分。</p>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>纵观OCI Runtime标准，并没有定义网络标准。根据学习和推测，我认为它是通过hook实现的网络设置。</p>
<p>Hook就是一些在容器特定<a href="https://github.com/opencontainers/runtime-spec/blob/master/runtime.md#lifecycle" target="_blank" rel="noopener">生命周期</a>被调用的程序。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"hooks": &#123;</span><br><span class="line">    "prestart": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/fix-mounts"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"fix-mounts"</span>, <span class="string">"arg1"</span>, <span class="string">"arg2"</span>],</span><br><span class="line">            <span class="attr">"env"</span>:  [ <span class="string">"key1=value1"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/setup-network"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "createRuntime": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/fix-mounts"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"fix-mounts"</span>, <span class="string">"arg1"</span>, <span class="string">"arg2"</span>],</span><br><span class="line">            <span class="attr">"env"</span>:  [ <span class="string">"key1=value1"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/setup-network"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "createContainer": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/mount-hook"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"-mount"</span>, <span class="string">"arg1"</span>, <span class="string">"arg2"</span>],</span><br><span class="line">            <span class="attr">"env"</span>:  [ <span class="string">"key1=value1"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "startContainer": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/refresh-ldcache"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "poststart": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/bin/notify-start"</span>,</span><br><span class="line">            <span class="attr">"timeout"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "poststop": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/sbin/cleanup.sh"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [<span class="string">"cleanup.sh"</span>, <span class="string">"-f"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如这个例子所示，在创建容器时，我们让Runtime调用setup-network程序。</p>
<h3 id="Persistent-Namespace"><a href="#Persistent-Namespace" class="headerlink" title="Persistent Namespace"></a>Persistent Namespace</h3><p>在第一个版本里，我们并没有在创建容器时调用<code>pviot_root</code>，而是在运行容器时才更换系统目录，创建新的命名空间。这将无法满足<code>createContainer hook</code>的要求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(Executed in Container NS) During the create operation, after the runtime environment has been created and before the pivot root or any equivalent operation.</span><br></pre></td></tr></table></figure>

<p>要实现这个hook，我们要在创建容器时就创建命名空间，并且允许hook程序对这些命名空间做一些操作。当我们运行容器时，之前的改动都必须还在，所以这些命名空间必须被持久化。</p>
<p>根据Linux手册，命名空间存放在<code>/proc/&lt;PID&gt;/ns/*flie</code>，当进程退出时，这些文件也就释放掉了，除非这些文件被bind-mount到另外的地方。</p>
<p><code>mount(&quot;/proc/pid/ns/net&quot;, &quot;/home/ubuntu/container/ns/net&quot;, MS_BIND, nullptr)</code></p>
<p>之后，可以通过setns函数来恢复这些命名空间。</p>
<p>其中困难的地方在于</p>
<ol>
<li>mnt ns必须被挂在Private mount point</li>
<li>pid ns没有必要持久化，必须保持容器进程运行，再将hook程序加入对应pid ns。每次容器运行，都创建新的pid ns</li>
</ol>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p><a href="https://github.com/genuinetools/netns" target="_blank" rel="noopener">Network Hook</a></p>
<p>Github上有一个现成的hook供我们使用，叫做netns。我们可以先用netns验证runtime工作正常，以后再实现自己的hook，从而达成全部自己实现的目标。</p>
<p>通过netns源码可知，在启动netns时，runtime需要将容器的status传递到netns的stdin。因为我在上一版本中，已经实现了将status保存为文件，这里只要将status.file打开，并设置fd为stdin，之后调用exec运行hook，将fd传递给子进程，就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// posix ensure it opens the least available fd</span></span><br><span class="line">close(<span class="built_in">stdin</span>);</span><br><span class="line">open(<span class="string">"status.json"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"status.json"</span>);</span><br><span class="line">dup2(fd, <span class="built_in">stdin</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>status里带有pid，netns通过访问/proc/pid/ns，获取到目标network namespace，再将创建的veth link过去。</p>
<p>netns默认没有打开bridge的转发功能。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudp ifconfig &lt;bridgename&gt; up</span><br><span class="line">sudo iptables -A FORWARD -o br0 -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -i br0 -j ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -s &lt;subnet&gt; ! -o &lt;bridgename&gt; -j MASQUERADE</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手写Docker-CPP</title>
    <url>/2020/11/17/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99Docker-CPP/</url>
    <content><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>该项目以《自己动手写Docker》一书作为参考，实现简易容器。<br>与原书不同的是：</p>
<ol>
<li>使用cpp实现。</li>
<li>严格遵守OCI标准，仅仅实现runtime，不包括其他行为。</li>
</ol>
<p>容器工具命名为<code>Grid</code>。</p>
<h2 id="OCI-Runtime-Spec"><a href="#OCI-Runtime-Spec" class="headerlink" title="OCI Runtime Spec"></a>OCI Runtime Spec</h2><p><a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">opencontainers/runtime-spec</a></p>
<p>runtime主要实现以下几个操作：</p>
<ol>
<li><code>create &lt;container-id&gt; &lt;path-to-bundle&gt;</code></li>
<li><code>start &lt;container-id&gt;</code></li>
<li><code>kill &lt;container-id&gt; &lt;signal&gt;</code></li>
<li><code>delete &lt;container-id&gt;</code></li>
</ol>
<p>bundle可以被认为是镜像、Rootfs等概念，即包含了一个容器所必须的文件系统部分。</p>
<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><p>获取一个bundle示例，可以通过如下指令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker create --name box busybox</span><br><span class="line">docker <span class="built_in">export</span> box -o busybox.tar</span><br><span class="line">mkdir busybox</span><br><span class="line">tar -xf busybox.tar -C busybox</span><br><span class="line">docker rm box</span><br></pre></td></tr></table></figure>

<p>export将busybox镜像提取成tar包，解压后就可以认为是一个bundle。在bundle下还需要有一个配置文件<code>config.json</code>。可以参照<a href="https://github.com/opencontainers/runtime-spec/blob/master/config.md" target="_blank" rel="noopener">标准</a>，创建一个。</p>
<p>现在，假定我们可以执行<code>./Grid create busybox /tmp/busybox</code>。</p>
<p>我们需要的代码模块有命令行参数解析，Json文件解析。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>由于runtime的输入都是positional args，cpp的各种命令行库都不能明显帮助减少工作量。至少有以下三种可行的方案：</p>
<ol>
<li>直接使用argv</li>
<li>boost option</li>
<li>GFlag</li>
</ol>
<h3 id="Json文件解析"><a href="#Json文件解析" class="headerlink" title="Json文件解析"></a>Json文件解析</h3><p>Jsoncpp的接口较为简单，易于使用。</p>
<h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p>成功解析命令行参数和配置文件后，接下来完成Create命令需要做的事情。严格来说，并没有任何关于实现的限定，不管是虚拟机，还是Namespace+AUFS，都是可以达成runtime要求的实现。</p>
<p>参照Docker的实现，我们需要创建一个AUFS，并且将容器状态持久化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Grid</span><br><span class="line">tree -d</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── containers</span><br><span class="line">│   ├── firstcontainer</span><br><span class="line">│   │   ├── mntFolder</span><br><span class="line">│   │   │   ├── bin</span><br><span class="line">│   │   │   ├── dev</span><br><span class="line">│   │   │   │   ├── pts</span><br><span class="line">│   │   │   │   └── shm</span><br><span class="line">│   │   │   ├── etc</span><br><span class="line">│   │   │   │   └── network</span><br><span class="line">│   │   │   │       ├── <span class="keyword">if</span>-down.d</span><br><span class="line">│   │   │   │       ├── <span class="keyword">if</span>-post-down.d</span><br><span class="line">│   │   │   │       ├── <span class="keyword">if</span>-pre-up.d</span><br><span class="line">│   │   │   │       └── <span class="keyword">if</span>-up.d</span><br><span class="line">│   │   │   ├── home</span><br><span class="line">│   │   │   ├── proc</span><br><span class="line">│   │   │   ├── root</span><br><span class="line">│   │   │   ├── sys</span><br><span class="line">│   │   │   ├── tmp</span><br><span class="line">│   │   │   ├── usr</span><br><span class="line">│   │   │   │   └── sbin</span><br><span class="line">│   │   │   └── var</span><br><span class="line">│   │   │       ├── spool</span><br><span class="line">│   │   │       │   └── mail</span><br><span class="line">│   │   │       └── www</span><br><span class="line">│   │   └── writeLayer</span><br><span class="line">│   └── secondcontainer</span><br><span class="line">│       ├── mntFolder</span><br><span class="line">│       │   ├── bin</span><br><span class="line">│       │   ├── dev</span><br><span class="line">│       │   │   ├── pts</span><br><span class="line">│       │   │   └── shm</span><br><span class="line">│       │   ├── etc</span><br><span class="line">│       │   │   └── network</span><br><span class="line">│       │   │       ├── <span class="keyword">if</span>-down.d</span><br><span class="line">│       │   │       ├── <span class="keyword">if</span>-post-down.d</span><br><span class="line">│       │   │       ├── <span class="keyword">if</span>-pre-up.d</span><br><span class="line">│       │   │       └── <span class="keyword">if</span>-up.d</span><br><span class="line">│       │   ├── home</span><br><span class="line">│       │   ├── proc</span><br><span class="line">│       │   ├── root</span><br><span class="line">│       │   ├── sys</span><br><span class="line">│       │   ├── tmp</span><br><span class="line">│       │   ├── usr</span><br><span class="line">│       │   │   └── sbin</span><br><span class="line">│       │   └── var</span><br><span class="line">│       │       ├── spool</span><br><span class="line">│       │       │   └── mail</span><br><span class="line">│       │       └── www</span><br><span class="line">│       └── writeLayer</span><br><span class="line">└── images</span><br><span class="line">    ├── busybox</span><br><span class="line">    │   ├── bin</span><br><span class="line">    │   ├── dev</span><br><span class="line">    │   │   ├── pts</span><br><span class="line">    │   │   └── shm</span><br><span class="line">    │   ├── etc</span><br><span class="line">    │   │   └── network</span><br><span class="line">    │   │       ├── <span class="keyword">if</span>-down.d</span><br><span class="line">    │   │       ├── <span class="keyword">if</span>-post-down.d</span><br><span class="line">    │   │       ├── <span class="keyword">if</span>-pre-up.d</span><br><span class="line">    │   │       └── <span class="keyword">if</span>-up.d</span><br><span class="line">    │   ├── home</span><br><span class="line">    │   ├── proc</span><br><span class="line">    │   ├── root</span><br><span class="line">    │   ├── sys</span><br><span class="line">    │   ├── tmp</span><br><span class="line">    │   ├── usr</span><br><span class="line">    │   │   └── sbin</span><br><span class="line">    │   └── var</span><br><span class="line">    │       ├── spool</span><br><span class="line">    │       │   └── mail</span><br><span class="line">    │       └── www</span><br><span class="line">    └── ubuntu</span><br></pre></td></tr></table></figure>

<p>我们对容器和镜像的存储如上图所示，分为container和images两个目录。</p>
<ul>
<li>images<ul>
<li>将刚才获取的bundle，放在images下。</li>
</ul>
</li>
<li>containers<ul>
<li>创建一个新的容器，containers目录下就会新创建一个目录，名字和容器id相同。</li>
<li>容器id目录下有writeLayer，mntFolder和status.json</li>
</ul>
</li>
</ul>
<p>wrtieLayer和mntFolder是两个空目录，然后执行</p>
<p><code>mount -t aufs -o br:/home/Grid/fristcontainer/writeLayer=rw:/home/Grid/images/busybox=ro none /home/Grid/fristcontainer/mntFolder</code></p>
<p>在简易版本里，可以通过调用外部命令实现mount，未来可以改进为直接使用system call。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> branches = <span class="string">"br:"</span> + writelayer + <span class="string">"=rw:"</span> + rolayer + <span class="string">"=ro"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> command = <span class="string">"mount -t aufs -o "</span> + branches + <span class="string">" none "</span> + mntfolder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (system(command.c_str()) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"aufs mount fail!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在status.json里写入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"Bundle"</span> : <span class="string">"/home/ubuntu/Grid/images/busybox"</span>,</span><br><span class="line">   <span class="string">"Created"</span> : <span class="literal">true</span>,</span><br><span class="line">   <span class="string">"Creating"</span> : <span class="literal">false</span>,</span><br><span class="line">   <span class="string">"ID"</span> : <span class="string">"firstcontainer"</span>,</span><br><span class="line">   <span class="string">"OCIVersion"</span> : <span class="string">""</span>,</span><br><span class="line">   <span class="string">"Pid"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="string">"Running"</span> : <span class="literal">false</span>,</span><br><span class="line">   <span class="string">"Stopped"</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该文件可用任意格式，仅用作维护内部状态，在调用start、kill时，修改status内容。</p>
<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>容器创建好后，便可以开始运行。</p>
<p>在最初的版本里，我们先实现交互式的容器。</p>
<p>大致工作流程如下：</p>
<ol>
<li>运行Grid <code>./Gird start firstcontainer</code> (通过环境变量指定Grid配置，帮助找到容器存储目录)</li>
<li>加载配置，加载容器信息</li>
<li>调用 <code>clone(InitProcess, stackTop, CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWIPC | SIGCHLD, this);</code> 创建一个子线程，并且在不同的命名空间里。</li>
<li>父进程 <code>waitid(P_PID, child_process, &amp;siginfo, WEXITED);</code> 等待子进程退出</li>
<li>子进程<ul>
<li>Pivot_root</li>
<li>mount proc, tmp</li>
<li>execve</li>
</ul>
</li>
</ol>
<p>config.json in bundle</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"process"</span>: &#123;</span><br><span class="line">    <span class="attr">"terminal"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"consoleSize"</span>: &#123;</span><br><span class="line">        <span class="attr">"height"</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">"width"</span>: <span class="number">80</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"uid"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"gid"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"umask"</span>: <span class="number">63</span>,</span><br><span class="line">        <span class="attr">"additionalGids"</span>: [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"env"</span>: [</span><br><span class="line">        <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,</span><br><span class="line">        <span class="string">"TERM=xterm"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"cwd"</span>: <span class="string">"/root"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">        <span class="string">"sh"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"apparmorProfile"</span>: <span class="string">"acme_secure_profile"</span>,</span><br><span class="line">    <span class="attr">"selinuxLabel"</span>: <span class="string">"system_u:system_r:svirt_lxc_net_t:s0:c124,c675"</span>,</span><br><span class="line">    <span class="attr">"noNewPrivileges"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"capabilities"</span>: &#123;</span><br><span class="line">        <span class="attr">"bounding"</span>: [</span><br><span class="line">            <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">            <span class="string">"CAP_KILL"</span>,</span><br><span class="line">            <span class="string">"CAP_NET_BIND_SERVICE"</span></span><br><span class="line">        ],</span><br><span class="line">       <span class="attr">"permitted"</span>: [</span><br><span class="line">            <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">            <span class="string">"CAP_KILL"</span>,</span><br><span class="line">            <span class="string">"CAP_NET_BIND_SERVICE"</span></span><br><span class="line">        ],</span><br><span class="line">       <span class="attr">"inheritable"</span>: [</span><br><span class="line">            <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">            <span class="string">"CAP_KILL"</span>,</span><br><span class="line">            <span class="string">"CAP_NET_BIND_SERVICE"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"effective"</span>: [</span><br><span class="line">            <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">            <span class="string">"CAP_KILL"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"ambient"</span>: [</span><br><span class="line">            <span class="string">"CAP_NET_BIND_SERVICE"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rlimits"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"RLIMIT_NOFILE"</span>,</span><br><span class="line">            <span class="attr">"hard"</span>: <span class="number">1024</span>,</span><br><span class="line">            <span class="attr">"soft"</span>: <span class="number">1024</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个版本只需要支持terminal, env, args。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>System</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读爱情</title>
    <url>/2021/11/05/%E9%98%85%E8%AF%BB%E7%88%B1%E6%83%85/</url>
    <content><![CDATA[<p>时隔良久，再度谈论爱情。要说契机呢，可能是这个人自己沉浸爱情一年多了，恰巧最近又见证别人的分分合合，感触颇多。</p>
<h2 id="关于想要的"><a href="#关于想要的" class="headerlink" title="关于想要的"></a>关于想要的</h2><p>记得之前我说，目标是寻找一个和我一起探究，为什么会有人愿意在爱情里拉扯，这个问题的人。</p>
<p>这真的是个非常妙的描述，如果你抱着这种想法去恋爱，心境会自然许多。不会问为什么她不爱我，为什么她不回消息，为什么她生气了。</p>
<p>因为本就是来学习的，反馈已经给出，答案只能自寻。</p>
<p>虽然，事实上，两个人都这样想的话，就很少会生气了。</p>
<h2 id="关于拥有的"><a href="#关于拥有的" class="headerlink" title="关于拥有的"></a>关于拥有的</h2><p>每过一段时间，我都感到有被刷新认知。比如说，原来恋爱是牵牵手，原来恋爱是时不时的嘤嘤嘤，原来恋爱是旅游逛街，谈天说地。</p>
<p>我从未自满，始终抱有敬畏，也因此我可能永远不会完整认识到，我拥有了什么。</p>
<p>如果你细数一些小事，那可能会是，有人和你说早安晚安，有人在你无聊时陪伴。</p>
<p>可是呢，这个人拥有与你同样崇高的灵魂，我会拥有她的所有吗？</p>
<h2 id="关于失去的"><a href="#关于失去的" class="headerlink" title="关于失去的"></a>关于失去的</h2><p>没有发现有什么明显的失去，非要说的话可能是一些自由时间，但总的来说还好，我觉得个人时间仍是非常足够的。</p>
<h2 id="关于世界"><a href="#关于世界" class="headerlink" title="关于世界"></a>关于世界</h2><p>如果和一个人恋爱，你将会得到特别多的机会，去感知别人是怎么看待这个世界的。</p>
<p>难免地，在一些问题上，每个人的看法会不同，甚至有非常大的区别。在那种时刻，有些人的处理方式就是坚持自我，不说不念，你爱懂不懂。我挺羡慕那种方式的，大概率这个人从不缺怜爱。更为成熟的方式应该还是多沟通交流，一次两次之后就会理解别人的想法了。</p>
<h2 id="关于金钱"><a href="#关于金钱" class="headerlink" title="关于金钱"></a>关于金钱</h2><p>不自觉想到很多句子，”没有物质的爱情只是一盘散沙，都不用风吹，走几步就散了”。</p>
<p>我总觉得，钱可以避免很多不必要的烦恼，不用纠结今天是不是浪费了一些东西，不用纠结是打车还是地铁，一些小的细节可以全凭喜好。</p>
<h2 id="无数唯一多少最"><a href="#无数唯一多少最" class="headerlink" title="无数唯一多少最"></a>无数唯一多少最</h2><p>最后的最后，不免想要问一问世上是否真的有唯一。</p>
<p>想来一直都是一会相信有，一会不相信有。反反复复之间顽童意识到，许多东西都是可复制的，儿时会为了两枚硬币落泪，长大了方知根本不值一提。</p>
<p>爱情也是一样，一旦经历过拥有和失去，就认识到没有什么无可替代。</p>
<p>可是啊，可是。</p>
<p>人是很难给自己的人生设定界限的，人是一种善于反悔的动物，即使你告诉自己世上没有唯一，你还是会有一天沉迷其中，也许以后会清醒，也许永远不会。</p>
<p>在每一句我爱你之间，你一直是我的唯一和最爱。</p>
]]></content>
      <categories>
        <category>Story</category>
      </categories>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
</search>
